

# ====== Begin of app.py ======

"""
PROFESSIONAL Construction Project Planner - FIXED VERSION
Unified Session Management & Transaction Safety
"""

import streamlit as st
import logging
import sys
import os
from sqlalchemy.orm import Session
from typing import Optional, Callable,Dict,  Any
from contextlib import contextmanager

# Add backend to path
sys.path.append(os.path.join(os.path.dirname(__file__), 'backend'))

# Configure professional logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class ConstructionApp:
    """
    FIXED Professional main application with unified session management
    """

    def __init__(self):
        self._setup_page_config()
        self._initialize_session_state()
        self._initialize_database()

    # ------------------- Initialization -------------------

    def _setup_page_config(self):
        """Setup professional page configuration"""
        st.set_page_config(
            page_title="Construction Project Planner",
            page_icon="üèóÔ∏è",
            layout="wide",
            initial_sidebar_state="expanded",
            menu_items={
                'Get Help': 'https://github.com/your-repo/construction-planner',
                'Report a bug': "https://github.com/your-repo/construction-planner/issues",
                'About': "### üèóÔ∏è Construction Project Planner\nProfessional construction scheduling and resource management system"
            }
        )

    def _initialize_session_state(self):
        """Initialize unified session state"""
        # 1. Authentication Session Manager (User identity & permissions)
        if 'auth_session_manager' not in st.session_state:
            from backend.auth.session_manager import SessionManager
            st.session_state.auth_session_manager = SessionManager()
            logger.info("‚úÖ Authentication session manager initialized")

        # 2. Application state defaults
        defaults = {
            'app_initialized': True,
            'current_page': 'login',
            'current_project_id': None,
            'current_project_name': None,
            'navigation_section': 'scheduling',
            '_previous_page': None,
            'widget_debug': False,
            'project_config': {
                'basic_info': {
                    'project_name': 'My Construction Project',
                    'project_manager': '',
                    'start_date': None,
                    'description': '',
                    'project_type': 'Commercial',
                    'client_name': '',
                    'location': ''
                },
                'zones': {},
                'advanced_settings': {
                    'work_hours_per_day': 8,
                    'acceleration_factor': 1.0,
                    'risk_allowance': 0.1
                }
            },
            'project_zones': {}
        }

        for key, value in defaults.items():
            if key not in st.session_state:
                st.session_state[key] = value

    def _initialize_database(self):
        """Initialize database connection professionally"""
        try:
            from backend.db.session import init_database
            init_database()
            logger.info("‚úÖ Database initialized successfully")
        except Exception as e:
            logger.error(f"‚ùå Database initialization failed: {e}")
            st.warning("‚ö†Ô∏è Database connection unavailable - using session storage")

    # ------------------- Session Management -------------------

    def _is_authenticated(self) -> bool:
        """Check if user is authenticated via auth session manager"""
        auth_manager = st.session_state.auth_session_manager
        return hasattr(auth_manager, 'is_authenticated') and auth_manager.is_authenticated()

    def _get_current_user_id(self) -> Optional[int]:
        """Get current user ID safely via auth session manager"""
        if self._is_authenticated():
            return st.session_state.auth_session_manager.get_user_id()
        return None

    def _initialize_services(self, db_session: Session, user_id: int) -> Dict[str, Any]:
        """
        Initialize all services with the current database session
        These services are request-scoped and not stored in session state
        """
        try:
            from backend.services.user_service import UserService
            from backend.services.project_service import ProjectService
            from backend.services.user_task_service import UserTaskService
            from backend.services.resource_service import ResourceService
            from backend.services.template_service import TemplateService
            from backend.services.zone_sequence_service import ZoneSequenceService
            from backend.services.scheduling_service import SchedulingService
            from backend.services.reporting_service import ReportingService
            from backend.services.monitoring_service import MonitoringService
            
            services = {
                'user_service': UserService(db_session),  
                'project_service': ProjectService(db_session),
                'task_service': UserTaskService(db_session),
                'resource_service': ResourceService(db_session),
                'template_service': TemplateService(db_session),
                'zone_sequence_service': ZoneSequenceService(db_session),
                'scheduling_service': SchedulingService(db_session),
                'reporting_service': ReportingService(db_session),
                'monitoring_service': MonitoringService(db_session),
            }
            
            logger.info("‚úÖ Services initialized with request-scoped session")
            return services
            
        except Exception as e:
            logger.error(f"‚ùå Error initializing services: {e}")
            return {}
    


    @contextmanager
    def _database_session_scope(self):
        """
        Professional database transaction scope for entire page lifecycle
        Auto-commit on success, auto-rollback on exception
        """
        from backend.db.session import get_db_session, safe_commit, safe_rollback
        
        session = get_db_session()
        try:
            logger.debug("üéØ Starting page transaction scope")
            yield session
            # Commit on successful completion
            safe_commit(session, "Page transaction")
            logger.debug("‚úÖ Page transaction completed successfully")
            
        except Exception as e:
            # Rollback on any exception
            safe_rollback(session, f"Page transaction failed: {str(e)}")
            logger.error(f"‚ùå Transaction rolled back due to error: {e}")
            raise
            
        finally:
            # Always close session
            try:
                session.close()
                logger.debug("üîí Database session closed")
            except Exception as e:
                logger.error(f"‚ùå Error closing session: {e}")

    # ------------------- Page Routing -------------------

    def _route_to_page(self, db_session, services: Dict, user_id: int):
        """Route to current page with provided database session"""
        page = st.session_state.get('current_page', 'login')

        # Import all page modules
        from pages import login, project_setup, register
        from frontend.pages import (
            zone_sequence, templates_manager, 
            generate_schedule, progress_monitoring, 
            performance_dashboard, reports_analytics
        )

        # Map pages to their show functions with session
        page_mapping = {
            # Authentication Pages
            'login': lambda: login.show(),
            'register': lambda: register.show(),

            # Scheduling Section
            'project_setup': lambda: project_setup.show(db_session, services, user_id),
            'zone_sequence': lambda: zone_sequence.show(db_session, services, user_id),
            'templates_manager': lambda: templates_manager.show(db_session, services, user_id),
            'generate_schedule': lambda: generate_schedule.show(db_session, services, user_id),

            # Monitoring Section
            'progress_monitoring': lambda: progress_monitoring.show(db_session, services, user_id),
            'performance_dashboard': lambda: performance_dashboard.show(db_session, services, user_id),
            'reports_analytics': lambda: reports_analytics.show(db_session, services, user_id),
        }

        # Execute page function
        page_function = page_mapping.get(page, self._render_error_page)
        page_function()

    def _render_error_page(self):
        """Render error page for unknown routes"""
        st.error(f"‚ùå Page not found: {st.session_state.get('current_page')}")
        if st.button("üè† Return to Home"):
            st.session_state.current_page = "project_setup"
            st.rerun()

    # ------------------- Interface Rendering -------------------

    def _render_authenticated_interface(self):
        """
        FIXED: Professional authenticated interface with unified session management
        """
        try:
            # Single database transaction for entire page lifecycle
            with self._database_session_scope() as db_session:
                # Get user context from auth session manager
                auth_manager = st.session_state.auth_session_manager
                user_id = auth_manager.get_user_id()
                username = auth_manager.get_username()
                user_role = auth_manager.get_user_role()

                logger.info(f"üë§ Rendering interface for: {username} (ID: {user_id}, Role: {user_role})")

                # ‚úÖ FIXED: Initialize services with current session (not stored)
                services = self._initialize_services(db_session, user_id)

                # Widget management
                if 'widget_manager' not in st.session_state:
                    from backend.utils.widget_manager import widget_manager
                    st.session_state.widget_manager = widget_manager
                
                widget_manager = st.session_state.widget_manager
                current_page = st.session_state.get('current_page', 'unknown')
                
                # Clean up previous page keys
                previous_page = st.session_state.get('_previous_page')
                if previous_page and previous_page != current_page:
                    widget_manager.cleanup_page_keys(previous_page)
                    logger.info(f"üîÑ Cleaned up widget keys for previous page: {previous_page}")
                
                st.session_state._previous_page = current_page
                
                # Render interface components
                self._render_interface_components(db_session,  services, user_id, username, user_role)

        except Exception as e:
            logger.error(f"‚ùå Error in authenticated interface: {e}")
            self._show_error_page(e)

    def _render_interface_components(self, db_session, services: Dict, user_id: int, username: str, user_role: str):
        """Render all UI components with proper session context"""
        from frontend.components.navigation.sidebar import render_main_sidebar
        from frontend.components.navigation.header import render_page_header

        # -------------------
        # Render Sidebar with user context
        # -------------------
        render_main_sidebar(db_session, user_id, st.session_state.navigation_section)

        # -------------------
        # Render Main Content Header
        # -------------------
        current_page_name = st.session_state.get('current_page', 'Dashboard')
        render_page_header(
            title=current_page_name.replace('_', ' ').title(),
            description=f"User: {username} | Role: {user_role}",
            icon="üìä",
            show_breadcrumbs=True,
            breadcrumbs=[current_page_name.replace('_', ' ').title()]
        )

        # -------------------
        # Render Page Content with database session
        # -------------------
        self._route_to_page(db_session, services,user_id)

    def _render_login_interface(self):
        """Render login page (no database session needed)"""
        try:
            from pages.login import show as show_login_page
            show_login_page()
        except Exception as e:
            logger.error(f"‚ùå Login page error: {e}")
            self._show_error_page(e)


    def _render_register_interface(self):
        """Render register page for unauthenticated users"""
        try:
            from pages.register import show as show_register_page
            show_register_page()
        except Exception as e:
            logger.error(f"‚ùå Register page error: {e}")
            self._show_error_page(e)
    # ------------------- Error Handling -------------------

    def _show_error_page(self, error: Exception):
        """Professional error page with technical details"""
        st.error("""
        ‚ùå Application Error
        We encountered an unexpected error. Please:
        1. Refresh the page
        2. Check your internet connection
        3. Contact support if the issue persists
        """)
        with st.expander("Technical Details (For Support)"):
            st.code(f"Error Type: {type(error).__name__}\nError Message: {str(error)}")

        if st.button("üîÑ Restart Application"):
            # Clear critical session state and rerun
            keys_to_keep = ['auth_session_manager', 'widget_manager']
            for key in list(st.session_state.keys()):
                if key not in keys_to_keep:
                    del st.session_state[key]
            st.rerun()

    # ------------------- Utilities -------------------

    def _show_widget_debug_info(self):
        """Show widget debugging information (optional)"""
        if st.session_state.get('widget_debug'):
            with st.sidebar.expander("üîß Widget Debug Info", expanded=False):
                if 'widget_manager' in st.session_state:
                    stats = st.session_state.widget_manager.get_registry_stats()
                    st.write(f"**Total Widget Keys:** {stats['total_keys']}")
                    st.write(f"**Active Pages:** {stats['pages']}")
                    st.write(f"**Users in Registry:** {stats['users']}")
                
                if st.button("Clear Widget Registry"):
                    if 'widget_key_registry' in st.session_state:
                        st.session_state.widget_key_registry = set()
                    if 'widget_key_context' in st.session_state:
                        st.session_state.widget_key_context = {}
                    st.rerun()

    # ------------------- Main Run Method -------------------

    def run(self):
        """Run the professional application with enhanced session management"""
        try:

            
            # Route based on authentication
            if self._is_authenticated():
                self._render_authenticated_interface()
            else:
                

                current_page = st.session_state.get('current_page', 'login')
            
                if current_page == 'register':
                    self._render_register_interface()  # You need to create this
                else:
                    self._render_login_interface()

            # Optional debug information
            self._show_widget_debug_info()
                
        except Exception as e:
            logger.error(f"‚ùå Fatal application error: {e}")
            self._show_error_page(e)

# ------------------- Entry Point -------------------

if __name__ == "__main__":
    app = ConstructionApp()
    app.run()


    

# ====== End of app.py ======



# ====== Begin of frontend/pages/templates_manager.py ======

"""
PROFESSIONAL Template Manager - REFACTORED & MODULAR
"""
import streamlit as st
import logging
from sqlalchemy.orm import Session
from typing import Dict , Any
from frontend.components.tabs.resource_library import render_resource_templates_tab
from frontend.components.tabs.task_library import render_task_library_tab
from frontend.components.tabs.template_association import render_template_associations_tab

logger = logging.getLogger(__name__)

def show(db_session: Session,services: Dict[str, Any], user_id: int):
    """REFACTORED Template manager main entry point"""
    try:
        st.title("üèóÔ∏è Gestionnaire de Templates Unifi√©")
        
        # ‚úÖ FIXED: Do NOT store db_session in session state
        # Database sessions are request-scoped and should not persist
        
        # Load professional CSS
        load_template_manager_css()
        
        if not services:
            st.error("‚ùå Erreur d'initialisation des services")
            return

        # Create THREE tabs for unified management
        tab1, tab2, tab3 = st.tabs([
            "üì¶ Biblioth√®que des Ressources",
            "üìö Biblioth√®que des T√¢ches", 
            "üîó Associations & Validation"
        ])

        # ----------------- Tab 1: Unified Resource Templates -----------------
        with tab1:
            render_resource_templates_tab(services, user_id, db_session)
        
        # ----------------- Tab 2: Task Library -----------------
        with tab2:
            render_task_library_tab(services, user_id, db_session)
        
        # ----------------- Tab 3: Template Associations -----------------
        with tab3:
            render_template_associations_tab(services, user_id, db_session)

    except Exception as e:
        logger.error(f"‚ùå Error in templates manager page: {e}")
        st.error("‚ùå Erreur lors du chargement du gestionnaire de templates")


def load_template_manager_css():
    """Load professional CSS styles for template manager with correct path"""
    try:
        css_path = "frontend/styling/template_manager.css"
        with open(css_path, "r", encoding="utf-8") as f:
            st.markdown(f"<style>{f.read()}</style>", unsafe_allow_html=True)
    except FileNotFoundError:
        # Fallback inline styles
        st.markdown("""
        <style>
            .template-manager-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                padding: 25px;
                border-radius: 15px;
                color: white;
                margin-bottom: 30px;
                box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            }
            .filter-section {
                background: #f8f9fa;
                padding: 20px;
                border-radius: 10px;
                margin-bottom: 20px;
                border-left: 4px solid #007bff;
            }
            .selected-row-actions {
                background: #e7f3ff;
                padding: 15px;
                border-radius: 8px;
                margin: 15px 0;
                border-left: 4px solid #007bff;
            }
            .submit-section {
                background: #d4edda;
                padding: 20px;
                border-radius: 10px;
                margin-top: 20px;
                border-left: 4px solid #28a745;
            }
            .template-card {
                background: white;
                padding: 20px;
                border-radius: 12px;
                box-shadow: 0 4px 15px rgba(0,0,0,0.08);
                margin-bottom: 20px;
                transition: transform 0.2s ease;
            }
            .template-card:hover {
                transform: translateY(-2px);
                box-shadow: 0 6px 20px rgba(0,0,0,0.12);
            }
            .stats-card {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 20px;
                border-radius: 12px;
                text-align: center;
                margin: 10px 0;
            }
        </style>
        """, unsafe_allow_html=True)
    except Exception as e:
        logger.error(f"‚ùå Service initialization error: {e}")
        st.error(f"‚ùå Erreur d'initialisation des services: {e}")
        return None

# ====== End of frontend/pages/templates_manager.py ======



# ====== Begin of frontend/components/tabs/task_library.py ======

"""
FIXED Task Library Tab - Using optimized task table with resource selection
"""
import streamlit as st
import logging
from typing import Dict, Any

logger = logging.getLogger(__name__)

def render_task_library_tab(services: Dict[str, Any], user_id: int, db_session=None):
    """Render task library tab with optimized table and resource selection"""
    
    st.markdown("""
    <div class="template-manager-header">
        <h1>üìö Biblioth√®que des T√¢ches</h1>
        <p>G√©rez vos templates de t√¢ches</p>
    </div>
    """, unsafe_allow_html=True)
    
    task_service = services['task_service']
    resource_service = services['resource_service']
    
    try:
        # Get tasks from service
        tasks = task_service.get_user_task_templates(user_id)
        
        # Get available resources from resource service
        available_workers = resource_service.get_user_workers(user_id)
        available_equipment = resource_service.get_user_equipment(user_id)
        
        available_resources = {
            'workers': available_workers,
            'equipment': available_equipment
        }
        
        # Display statistics
        col1, col2, col3, col4 = st.columns(4)
        with col1:
            st.metric("üìã T√¢ches", len(tasks))
        with col2:
            included_tasks = len([t for t in tasks if t.get('included', True)])
            st.metric("T√¢ches Incluses", included_tasks)
        with col3:
            disciplines = len(set(t.get('discipline', '') for t in tasks))
            st.metric("Disciplines", disciplines)
        with col4:
            quality_gates = len([t for t in tasks if t.get('quality_gate', False)])
            st.metric("Points Contr√¥le", quality_gates)
        
        # Use optimized task table WITH resource selection
        from frontend.components.data_tables.task_table import render_tasks_table
        template_service = services.get('template_service')
        render_tasks_table(tasks, task_service, user_id, available_resources, template_service)
        
        # Load Default Tasks Section
        st.markdown("---")
        st.markdown("## üì• T√¢ches par D√©faut")
        
        col1, col2 = st.columns([3, 1])
        with col1:
            st.write("Chargez les t√¢ches par d√©faut pour commencer rapidement")
        with col2:
            if st.button("üì• Charger T√¢ches D√©faut", key="load_default_tasks_main"):
                try:
                    loaded = task_service.load_default_tasks(user_id)
                    if loaded:
                        st.success("‚úÖ T√¢ches par d√©faut charg√©es!")
                        st.rerun()
                    else:
                        st.error("‚ùå Erreur lors du chargement")
                except Exception as e:
                    st.error(f"‚ùå Erreur: {e}")

    except Exception as e:
        st.error(f"‚ùå Erreur dans la biblioth√®que des t√¢ches: {e}")
        logger.error(f"Task library error: {e}")

# ====== End of frontend/components/tabs/task_library.py ======



# ====== Begin of frontend/components/tabs/resource_library.py ======

"""
Resource Library Tab - Simplified with context integration
"""

import streamlit as st
import logging
from typing import Dict, Any, List

from frontend.helpers.template_context import render_template_context_selector

logger = logging.getLogger(__name__)

def render_resource_templates_tab(services: Dict[str, Any], user_id: int, db_session=None):
    """Simplified resource templates tab"""
    
    st.markdown("""
    <div class="template-manager-header">
        <h1>üì¶ Mod√®les de Ressources</h1>
        <p>G√©rez vos mod√®les de ressources (ouvriers et √©quipements)</p>
    </div>
    """, unsafe_allow_html=True)
    
    # Render template selectors
    render_template_context_selector(services, user_id)
    
    resource_service = services['resource_service']
    task_service = services['task_service']
      
    try:
        # Get current context
        from frontend.helpers.template_context import template_context
        
        if not template_context.is_ready():
            st.info("üëÜ S√©lectionnez un mod√®le de ressources et un mod√®le de t√¢ches pour continuer")
            return
        
        current_resource = template_context.resource_template
        current_task = template_context.task_template
        
        # Display current context
        st.info(f"**Contexte actuel:** {current_resource['name']} + {current_task.get('name', 'Sans nom')}")
        
        # Template actions
        _render_template_actions(resource_service, user_id)
        
        # Get workers and equipment
        template_id = current_resource['id']
        workers = resource_service.get_user_workers(user_id, template_id)
        equipment = resource_service.get_user_equipment(user_id, template_id)
        
        # Display in tabs
        tab1, tab2 = st.tabs(["üë• Ouvriers", "üõ†Ô∏è √âquipements"])
        
        with tab1:
            from frontend.components.data_tables.worker_table import render_workers_table
            template_service = services.get('template_service')
            render_workers_table(workers, resource_service, user_id, template_id, current_resource['name'], template_service=template_service)
        
        with tab2:
            from frontend.components.data_tables.equipment_table import render_equipment_table
            render_equipment_table(equipment, resource_service, user_id, template_id, current_resource['name'])
            
    except Exception as e:
        st.error(f"‚ùå Erreur: {e}")
        logger.error(f"Resource library error: {e}")

def _render_template_actions(resource_service, user_id: int):
    """Essential template actions"""
    st.markdown("### üîß Actions Mod√®le")
    
    col1, col2, col3 = st.columns(3)
    
    with col1:
        if st.button("üíæ Sauvegarder", use_container_width=True):
            st.success("‚úÖ Mod√®le sauvegard√©")
    
    with col2:
        if st.button("üì• Charger D√©faut", use_container_width=True):
            resource_service.load_default_resources(user_id)
            st.success("‚úÖ Ressources charg√©es")
            st.rerun()
    
    with col3:
        if st.button("üîÑ Actualiser", use_container_width=True):
            st.rerun()
    
    st.markdown("---")


# ====== End of frontend/components/tabs/resource_library.py ======



# ====== Begin of frontend/components/tabs/template_association.py ======

"""
PROFESSIONAL Template Association Tab
Associates resource templates with task templates for scheduling engine
"""
import streamlit as st
import logging
from typing import Dict, Any, List, Optional
from backend.utils.widget_manager import widget_manager

logger = logging.getLogger(__name__)


def render_template_associations_tab(services: Dict[str, Any], user_id: int, db_session=None):
    """
    Render template associations tab for linking resource templates with task templates
    """
    st.markdown("""
    <div class="template-manager-header">
        <h1>üîó Associations Templates</h1>
        <p>Associez les mod√®les de ressources avec les mod√®les de t√¢ches</p>
    </div>
    """, unsafe_allow_html=True)
    
    template_service = services['template_service']
    resource_service = services['resource_service']
    task_service = services['task_service']
    
    # Template-level actions
    _render_template_actions(resource_service, user_id)
    
    try:
        # Get available templates
        resource_templates = template_service.get_available_resource_templates(user_id)
        task_templates = task_service.get_user_task_templates(user_id)
        
        if not resource_templates:
            st.warning("üì≠ Aucun mod√®le de ressource disponible. Cr√©ez d'abord des mod√®les de ressources.")
            return
        
        if not task_templates:
            st.warning("üì≠ Aucun mod√®le de t√¢che disponible. Cr√©ez d'abord des mod√®les de t√¢ches.")
            return
        
        # Display statistics
        _render_association_statistics(resource_templates, task_templates, template_service, user_id)
        
        # Main association interface
        _render_association_interface(resource_templates, task_templates, template_service, user_id)
        
        # Validation section
        _render_validation_section(resource_templates, task_templates, template_service, resource_service)
        
    except Exception as e:
        st.error(f"‚ùå Erreur dans les associations de templates: {e}")
        logger.error(f"Template associations error: {e}")
        
def _render_association_statistics(resource_templates: List[Dict], task_templates: List[Dict], template_service, user_id: int):
    """Render association statistics"""
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric("üì¶ Mod√®les Ressources", len(resource_templates))
    
    with col2:
        st.metric("üìö Mod√®les T√¢ches", len(task_templates))
    
    with col3:
        # Count associations
        total_associations = 0
        for rt in resource_templates:
            associations = template_service.get_template_associations(rt.get('id'))
            total_associations += len(associations)
        st.metric("üîó Associations", total_associations)
    
    with col4:
        # Coverage percentage
        coverage = (total_associations / max(len(task_templates), 1)) * 100
        st.metric("üìä Couverture", f"{coverage:.1f}%")

def _render_association_interface(resource_templates: List[Dict], task_templates: List[Dict], template_service, user_id: int):
    """Render main association interface"""
    st.markdown("### üîó Interface d'Association")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown("#### üì¶ Mod√®les de Ressources")
        selected_resource_template = _render_resource_template_selection(resource_templates)
    
    with col2:
        st.markdown("#### üìö T√¢ches Disponibles")
        if selected_resource_template:
            _render_task_assignment_interface(selected_resource_template, task_templates, template_service, user_id)
        else:
            st.info("üëà S√©lectionnez un mod√®le de ressource pour voir les t√¢ches disponibles")

def _render_resource_template_selection(resource_templates: List[Dict]) -> Optional[Dict]:
    """Render resource template selection"""
    template_options = {f"{rt.get('name', 'Sans nom')} (ID: {rt.get('id')})": rt for rt in resource_templates}
    
    selected_label = st.selectbox(
        "S√©lectionnez un mod√®le de ressource:",
        options=[''] + list(template_options.keys()),
        key=widget_manager.generate_key("resource_template_selector", "template_association")
    )
    
    if selected_label and selected_label in template_options:
        selected_template = template_options[selected_label]
        
        # Display template details
        with st.expander("üìã D√©tails du Mod√®le S√©lectionn√©", expanded=True):
            col1, col2 = st.columns(2)
            with col1:
                st.write(f"**Nom:** {selected_template.get('name')}")
                st.write(f"**Cat√©gorie:** {selected_template.get('category', 'Non sp√©cifi√©e')}")
                st.write(f"**Description:** {selected_template.get('description', 'Aucune')}")
            
            with col2:
                st.write(f"**Version:** {selected_template.get('version', 1)}")
                st.write(f"**Statut:** {'‚úÖ Actif' if selected_template.get('is_active', True) else '‚ùå Inactif'}")
                st.write(f"**Partag√©:** {'‚úÖ Oui' if selected_template.get('is_shared', False) else '‚ùå Non'}")
        
        return selected_template
    
    return None

def _render_task_assignment_interface(selected_resource_template: Dict, task_templates: List[Dict], template_service, user_id: int):
    """Render task assignment interface for selected resource template"""
    resource_template_id = selected_resource_template.get('id')
    
    # Get current associations
    current_associations = template_service.get_template_associations(resource_template_id)
    current_task_ids = [assoc.get('task_template_id') for assoc in current_associations]
    
    # Group tasks by discipline for better organization
    tasks_by_discipline = {}
    for task in task_templates:
        discipline = task.get('discipline', 'Non class√©')
        if discipline not in tasks_by_discipline:
            tasks_by_discipline[discipline] = []
        tasks_by_discipline[discipline] = task
    
    st.markdown("#### üéØ T√¢ches Associ√©es")
    
    # Display current associations
    if current_task_ids:
        st.success(f"‚úÖ {len(current_task_ids)} t√¢che(s) associ√©e(s) √† ce mod√®le")
        
        for task_id in current_task_ids:
            task = next((t for t in task_templates if t.get('base_task_id') == task_id), None)
            if task:
                col1, col2, col3 = st.columns([3, 1, 1])
                with col1:
                    st.write(f"**{task.get('name')}**")
                    st.caption(f"Discipline: {task.get('discipline')} | Type: {task.get('resource_type')}")
                with col2:
                    st.write(f"Dur√©e: {task.get('base_duration', 'N/A')}j")
                with col3:
                    if st.button("üóëÔ∏è", key=f"remove_{task_id}_{resource_template_id}"):
                        template_service.remove_task_association(resource_template_id, task_id)
                        st.success(f"‚úÖ Association supprim√©e: {task.get('name')}")
                        st.rerun()
    else:
        st.warning("‚ö†Ô∏è Aucune t√¢che associ√©e √† ce mod√®le de ressource")
    
    st.markdown("---")
    st.markdown("#### ‚ûï Ajouter des Associations")
    
    # Multi-select for adding associations
    available_tasks = [t for t in task_templates if t.get('base_task_id') not in current_task_ids]
    
    if available_tasks:
        task_options = {
            f"{t.get('name')} ({t.get('base_task_id')}) - {t.get('discipline')}": t.get('base_task_id') 
            for t in available_tasks
        }
        
        selected_tasks = st.multiselect(
            "S√©lectionnez les t√¢ches √† associer:",
            options=list(task_options.keys()),
            key=widget_manager.generate_key("task_association_multiselect", "template_association")
        )
        
        if selected_tasks and st.button("üîó Associer les T√¢ches S√©lectionn√©es", use_container_width=True):
            selected_task_ids = [task_options[task] for task in selected_tasks]
            success_count = 0
            
            for task_id in selected_task_ids:
                if template_service.associate_task_template(resource_template_id, task_id):
                    success_count += 1
            
            if success_count > 0:
                st.success(f"‚úÖ {success_count} t√¢che(s) associ√©e(s) avec succ√®s!")
                st.rerun()
            else:
                st.error("‚ùå Erreur lors de l'association des t√¢ches")
    else:
        st.info("üéâ Toutes les t√¢ches disponibles sont d√©j√† associ√©es √† ce mod√®le!")

def _render_validation_section(resource_templates: List[Dict], task_templates: List[Dict], template_service, resource_service):
    """Render validation section for template associations"""
    st.markdown("---")
    st.markdown("### ‚úÖ Validation des Associations")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown("#### üîç V√©rification des D√©pendances")
        
        selected_validation_template = st.selectbox(
            "S√©lectionnez un mod√®le √† valider:",
            options=[''] + [f"{rt.get('name')} (ID: {rt.get('id')})" for rt in resource_templates],
            key=widget_manager.generate_key("validation_template_selector", "template_association")
        )
        
        if selected_validation_template:
            template_id = int(selected_validation_template.split("ID: ")[1].split(")")[0])
            associations = template_service.get_template_associations(template_id)
            
            if associations:
                st.success(f"‚úÖ {len(associations)} association(s) trouv√©e(s)")
                
                # Validate each association
                validation_results = []
                for assoc in associations:
                    task_id = assoc.get('task_template_id')
                    task = next((t for t in task_templates if t.get('base_task_id') == task_id), None)
                    
                    if task:
                        # Check if resource template has the required resources
                        validation = _validate_task_dependencies(task, template_id, resource_service)
                        validation_results.append({
                            'task': task,
                            'validation': validation
                        })
                
                # Display validation results
                for result in validation_results:
                    task = result['task']
                    validation = result['validation']
                    
                    with st.expander(f"üîç {task.get('name')}", expanded=False):
                        if validation['is_valid']:
                            st.success("‚úÖ T√¢che compatible avec le mod√®le de ressources")
                        else:
                            st.error("‚ùå Incompatibilit√©s d√©tect√©es")
                            
                            if validation['missing_workers']:
                                st.write("**Ouvriers manquants:**")
                                for worker in validation['missing_workers']:
                                    st.write(f" - {worker}")
                            
                            if validation['missing_equipment']:
                                st.write("**√âquipements manquants:**")
                                for equipment in validation['missing_equipment']:
                                    st.write(f" - {equipment}")
                            
                            if validation['warnings']:
                                st.write("**Avertissements:**")
                                for warning in validation['warnings']:
                                    st.warning(warning)
            else:
                st.warning("‚ö†Ô∏è Aucune association √† valider pour ce mod√®le")
    
    with col2:
        st.markdown("#### üìä Rapport de Couverture")
        
        # Generate coverage report
        coverage_data = []
        for rt in resource_templates:
            associations = template_service.get_template_associations(rt.get('id'))
            coverage_percentage = (len(associations) / len(task_templates)) * 100 if task_templates else 0
            
            coverage_data.append({
                'Mod√®le': rt.get('name'),
                'Associations': len(associations),
                'Couverture': f"{coverage_percentage:.1f}%",
                'Statut': '‚úÖ Bonne' if coverage_percentage > 50 else '‚ö†Ô∏è Faible' if coverage_percentage > 0 else '‚ùå Aucune'
            })
        
        if coverage_data:
            import pandas as pd
            df = pd.DataFrame(coverage_data)
            st.dataframe(df, use_container_width=True, hide_index=True)
        else:
            st.info("üìä Aucune donn√©e de couverture disponible")

def _validate_task_dependencies(task: Dict, resource_template_id: int, template_service) -> Dict[str, Any]:
    """Validate task dependencies against resource template using template service"""
    try:
        return template_service.validate_task_template_dependencies(task, resource_template_id)
    except Exception as e:
        logger.error(f"Error validating task dependencies: {e}")
        return {
            'is_valid': False,
            'missing_workers': [],
            'missing_equipment': [],
            'warnings': [f"Erreur de validation: {str(e)}"]
        }
    

def _render_template_actions(resource_service, user_id: int):
    """Render template-level action buttons for association tab"""
    st.markdown("### üîß Actions au Niveau Mod√®le")
    
    # Template action buttons
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        if st.button("üíæ Sauvegarder Tous", use_container_width=True,
                    key=widget_manager.generate_key("save_all_templates_btn", "template_association")):
            _save_all_templates(resource_service, user_id)
    
    with col2:
        if st.button("‚ûï Nouveau Mod√®le", use_container_width=True,
                    key=widget_manager.generate_key("new_template_btn", "template_association")):
            _create_new_template(resource_service, user_id)
    
    with col3:
        if st.button("üì• Charger D√©faut", use_container_width=True,
                    key=widget_manager.generate_key("load_default_btn", "template_association")):
            _load_default_resources(resource_service, user_id)
    
    with col4:
        if st.button("üîÑ Actualiser", use_container_width=True,
                    key=widget_manager.generate_key("refresh_btn", "template_association")):
            st.rerun()
    
    st.markdown("---")

def _save_all_templates(resource_service, user_id: int):
    """Save all resource templates"""
    try:
        templates = resource_service.get_user_resource_templates(user_id)
        total_workers = 0
        total_equipment = 0
        
        for template in templates:
            workers = resource_service.get_user_workers(user_id, template['id'])
            equipment = resource_service.get_user_equipment(user_id, template['id'])
            total_workers += len(workers)
            total_equipment += len(equipment)
        
        st.success(f"‚úÖ Tous les mod√®les sauvegard√©s!")
        st.info(f"üìä Total: {len(templates)} mod√®les, {total_workers} ouvriers, {total_equipment} √©quipements")
        
    except Exception as e:
        st.error(f"‚ùå Erreur lors de la sauvegarde: {e}")
        logger.error(f"Error saving all templates: {e}")

def _create_new_template(resource_service, user_id: int):
    """Create a new resource template"""
    try:
        # Generate unique template name
        template_count = len(resource_service.get_user_resource_templates(user_id))
        new_template_name = f"Nouveau Mod√®le {template_count + 1}"
        
        template_data = {
            'name': new_template_name,
            'description': 'Nouveau mod√®le de ressources cr√©√© automatiquement',
            'category': 'Custom',
            'user_id': user_id
        }
        
        new_template = resource_service.create_resource_template(user_id, template_data)
        
        if new_template:
            st.success(f"‚úÖ Nouveau mod√®le cr√©√©: {new_template_name}")
            st.rerun()
        else:
            st.error("‚ùå Erreur lors de la cr√©ation du mod√®le")
            
    except Exception as e:
        st.error(f"‚ùå Erreur lors de la cr√©ation du mod√®le: {e}")
        logger.error(f"Error creating template: {e}")

def _load_default_resources(resource_service, user_id: int):
    """Load default resources"""
    try:
        with st.spinner("üì• Chargement des ressources par d√©faut..."):
            loaded_resources = resource_service.load_default_resources(user_id)
            
            if loaded_resources:
                st.success(f"‚úÖ {len(loaded_resources)} ressources par d√©faut charg√©es avec succ√®s!")
                st.rerun()
            else:
                st.error("‚ùå Erreur lors du chargement des ressources par d√©faut")
                
    except Exception as e:
        st.error(f"‚ùå Erreur lors du chargement des ressources: {e}")
        logger.error(f"Error loading default resources: {e}")

# ====== End of frontend/components/tabs/template_association.py ======



# ====== Begin of backend/services/user_task_service.py ======

"""
PROFESSIONAL User Task Service - UPDATED with duration calculation methods
"""
import logging
from typing import List, Dict, Optional, Any
from datetime import datetime
from sqlalchemy.orm import Session
logger = logging.getLogger(__name__)

class UserTaskService:
    """
    Professional service for user task operations with duration methods
    """
    
    def __init__(self, db_session: Session):
        self.db_session = db_session
        self.logger = logging.getLogger(__name__)
        self._initialize_repositories()
    
    def _initialize_repositories(self):
        """Initialize repositories"""
        try:
            from backend.db.repositories.task_repo import TaskRepository
            self.task_repo = TaskRepository(self.db_session)
            self.logger.info("‚úÖ TaskRepository initialized successfully")
        except Exception as e:
            self.logger.error(f"‚ùå TaskRepository initialization failed: {e}")
            raise
    
    def get_user_task_templates(self, user_id: int, project_id: Optional[int] = None) -> List[Dict]:
        """
        Get user task templates for frontend display with duration methods
        """
        try:  
            db_templates = self.task_repo.get_user_task_templates(user_id, project_id)
            domain_tasks = [self._db_to_domain_task(db_template) for db_template in db_templates]
            self.logger.info(f"‚úÖ Retrieved {len(domain_tasks)} task templates for user {user_id}")
            return domain_tasks
        except Exception as e:
            self.logger.error(f"‚ùå Error retrieving task templates: {e}")
            return []
    
    def get_task_template_groups(self, user_id: int) -> List[Dict]:
        """Get task templates grouped by template_name"""
        try:
            tasks = self.get_user_task_templates(user_id)
            template_groups = {}
        
            for task in tasks:
                template_name = task.get('template_name', 'Default Template')
                if template_name not in template_groups:
                    template_groups[template_name] = {
                    'template_name': template_name,
                    'tasks': [],
                    'task_count': 0,
                    'disciplines': set(),
                    'created_at': task.get('created_at')
                    }
            
                template_groups[template_name]['tasks'].append(task)
                template_groups[template_name]['task_count'] += 1
                template_groups[template_name]['disciplines'].add(task.get('discipline', 'Non sp√©cifi√©'))
        
            return list(template_groups.values())
        
        except Exception as e:
            self.logger.error(f"Error getting task template groups: {e}")
            return []
    def load_default_tasks(self,user_id: int) -> List[Dict]:
        """
        Load default tasks as user templates with duration methods
        """
        try:
            from backend.defaults.TASKS import BASE_TASKS
            
            created_tasks = [] 
            for discipline, task_list in BASE_TASKS.items(): 
                for base_task in task_list:
                    template_data = {
                    'user_id': user_id,
                    'base_task_id': getattr(base_task, 'id', 'None'),
                    'name': getattr(base_task, 'name', 'Un named'),
                    'discipline': getattr(base_task, 'discipline', 'General'),
                    'sub_discipline': getattr(base_task, 'sub_discipline', 'General'),
                    'resource_type': getattr(base_task, 'resource_type', 'worker'),
                    'task_type': getattr(base_task, 'task_type', 'worker'),
                    'base_duration': getattr(base_task, 'base_duration', 1),
                    'unit_duration': getattr(base_task, 'unit_duration', 1),
                    'duration_calculation_method': getattr(base_task, 'duration_calculation_method', 'fixed_duration'),
                    'min_crews_needed': getattr(base_task, 'min_crews_needed', 1),
                    'min_equipment_needed': getattr(base_task, 'min_equipment_needed', {}),
                    'predecessors': getattr(base_task, 'predecessors', []),
                    'repeat_on_floor': getattr(base_task, 'repeat_on_floor', True),
                    'delay': getattr(base_task, 'delay', 0),
                    'weather_sensitive': getattr(base_task, 'weather_sensitive', False),
                    'quality_gate': getattr(base_task, 'quality_gate', False),
                    'included': getattr(base_task, 'included', True)
                        }
                
                    db_template = self.task_repo.create_user_task_template(template_data)
                    if db_template:
                        domain_task = self._db_to_domain_task(db_template)
                        created_tasks.append(domain_task)
                
            self.logger.info(f"‚úÖ Loaded {len(created_tasks)} default tasks")
            return created_tasks
            
        except Exception as e:
            self.logger.error(f"‚ùå Error loading default tasks: {e}")
            return []
    
    def update_custom_task(self, user_id: int, task_id: int, updates: Dict) -> Optional[Dict]:
        """Update custom task template with duration method support"""
        try:
            # Validate duration method configuration
            validation_result = self._validate_duration_configuration(updates)
            if not validation_result['is_valid']:
                self.logger.error(f"‚ùå Invalid duration configuration: {validation_result['errors']}")
                return None
            
            db_template = self.task_repo.update_user_task_template(user_id, task_id, updates)
            
            if db_template:
                self.logger.info(f"‚úÖ Updated task {task_id} with duration method: {updates.get('duration_calculation_method')}")
                return self._db_to_domain_task(db_template)
            return None
            
        except Exception as e:
            self.logger.error(f"‚ùå Error updating custom task: {e}")
            return None
    
    def _validate_duration_configuration(self, updates: Dict) -> Dict[str, Any]:
        """Validate duration calculation method configuration"""
        errors = []
        
        method = updates.get('duration_calculation_method', 'fixed_duration')
        
        if method == 'fixed_duration':
            if 'base_duration' not in updates or updates['base_duration'] <= 0:
                errors.append("La dur√©e fixe doit √™tre sup√©rieure √† 0")
                
        elif method == 'quantity_based':
            if 'unit_duration' not in updates or updates['unit_duration'] <= 0:
                errors.append("La dur√©e unitaire doit √™tre sup√©rieure √† 0")
        
        # resource_calculation doesn't need specific validation
        
        return {
            'is_valid': len(errors) == 0,
            'errors': errors
        }
    
    def _db_to_domain_task(self, db_template) -> Dict:
        """Convert DB model to domain task dictionary with duration methods"""
        return {
            'base_task_id': db_template.base_task_id,
            'name': db_template.name,
            'discipline': db_template.discipline,
            'sub_discipline': db_template.sub_discipline,
            'resource_type': db_template.resource_type,
            'task_type': db_template.task_type,
            'base_duration': db_template.base_duration,
            'unit_duration': getattr(db_template, 'unit_duration', 0),
            'duration_calculation_method': getattr(db_template, 'duration_calculation_method', 'fixed_duration'),
            'min_crews_needed': db_template.min_crews_needed,
            'min_equipment_needed': db_template.min_equipment_needed or {},
            'predecessors': db_template.predecessors or [],
            'repeat_on_floor': db_template.repeat_on_floor,
            'delay': db_template.delay,
            'weather_sensitive': db_template.weather_sensitive,
            'quality_gate': db_template.quality_gate,
            'included': db_template.included,
            'created_at': db_template.created_at.isoformat() if db_template.created_at else None
        }
    
    # Keep existing methods for compatibility
    def import_tasks_from_json(self, uploaded_file) -> bool:
        """Import tasks from JSON file"""
        try:
            import json
            tasks_data = json.load(uploaded_file)
            user_id = 1  # From session
            
            success_count = 0
            for task_data in tasks_data:
                task_data['user_id'] = user_id
                # Ensure duration method is set
                if 'duration_calculation_method' not in task_data:
                    task_data['duration_calculation_method'] = 'fixed_duration'
                if self.task_repo.create_user_task_template(task_data):
                    success_count += 1
            
            self.logger.info(f"‚úÖ Imported {success_count} tasks from JSON")
            return success_count > 0
            
        except Exception as e:
            self.logger.error(f"‚ùå Error importing tasks from JSON: {e}")
            return False
    
    def export_tasks_to_json(self) -> str:
        """Export tasks to JSON format"""
        try:
            user_id = 1  # From session
            db_templates = self.task_repo.get_user_task_templates(user_id)
            
            tasks_data = []
            for db_template in db_templates:
                task_dict = {
                    'id': db_template.base_task_id,
                    'name': db_template.name,
                    'discipline': db_template.discipline,
                    'sub_discipline': db_template.sub_discipline,
                    'resource_type': db_template.resource_type,
                    'task_type': db_template.task_type,
                    'base_duration': db_template.base_duration,
                    'unit_duration': getattr(db_template, 'unit_duration', 0),
                    'duration_calculation_method': getattr(db_template, 'duration_calculation_method', 'fixed_duration'),
                    'min_crews_needed': db_template.min_crews_needed,
                    'min_equipment_needed': db_template.min_equipment_needed,
                    'predecessors': db_template.predecessors,
                    'repeat_on_floor': db_template.repeat_on_floor,
                    'delay': db_template.delay,
                    'weather_sensitive': db_template.weather_sensitive,
                    'quality_gate': db_template.quality_gate,
                    'included': db_template.included
                }
                tasks_data.append(task_dict)
            
            import json
            return json.dumps(tasks_data, indent=2, ensure_ascii=False)
        except Exception as e:
            self.logger.error(f"‚ùå Error exporting tasks to JSON: {e}")
            return "[]"
        



        # Add this method to UserTaskService class
    def create_custom_task(self, user_id: int, task_data: Dict) -> Optional[Dict]:
        """Create a new custom task template"""
        try:
            # Ensure required fields
            task_data['user_id'] = user_id
            if 'duration_calculation_method' not in task_data:
                task_data['duration_calculation_method'] = 'fixed_duration'
        
            db_template = self.task_repo.create_user_task_template(task_data)
        
            if db_template:
                self.logger.info(f"‚úÖ Created custom task: {task_data.get('base_task_id')}")
                return self._db_to_domain_task(db_template)
            return None
        
        except Exception as e:
            self.logger.error(f"‚ùå Error creating custom task: {e}")
            return None
        
    def delete_custom_task(self, user_id: int, task_id: int) -> bool:
        """Delete custom task template"""
        try:
            return self.task_repo.delete_user_task_template(user_id, task_id)
        except Exception as e:
            self.logger.error(f"‚ùå Error deleting custom task: {e}")
            return False

# ====== End of backend/services/user_task_service.py ======



# ====== Begin of backend/services/template_service.py ======

"""
PROFESSIONAL Template Service - Template Association Management
Handles associations between resource templates and task templates
"""
import logging
from typing import List, Dict, Optional, Any
from sqlalchemy.orm import Session
import datetime

logger = logging.getLogger(__name__)

class TemplateService:
    """
    Professional service for template association operations
    """
    
    def __init__(self, db_session: Session):
        self.db_session = db_session
        self.logger = logging.getLogger(__name__)
        
    def validate_template_compatibility(self, resource_template: Dict, task_template: Dict) -> Dict[str, Any]:
        """Essential template compatibility validation"""
        try:
            issues = []
            warnings = []
            
            # 1. Check resource requirements
            resource_check = self._check_resource_requirements(task_template, resource_template)
            if not resource_check['met']:
                issues.extend(resource_check.get('issues', []))
            
            # 2. Check equipment requirements
            equipment_check = self._check_equipment_requirements(task_template, resource_template)
            if not equipment_check['met']:
                issues.extend(equipment_check.get('issues', []))
            
            return {
                'compatible': len(issues) == 0,
                'issues': issues,
                'warnings': warnings,
                'resource_check': resource_check,
                'equipment_check': equipment_check
            }
            
        except Exception as e:
            logger.error(f"Validation error: {e}")
            return {
                'compatible': False,
                'issues': [f"Erreur validation: {str(e)}"],
                'warnings': []
            }

    def _check_resource_requirements(self, task_template: Dict, resource_template: Dict) -> Dict[str, Any]:
        """Check if resource template has required workers"""
        from backend.db.repositories.resource_repo import ResourceRepository
        resource_repo = ResourceRepository(self.db_session)
        
        required_type = task_template.get('resource_type')
        if not required_type:
            return {'met': True, 'message': 'Aucun type sp√©cifique requis'}
        
        workers = resource_repo.get_workers_by_template(resource_template['id'])
        worker_types = [w.specialty for w in workers]
        
        has_match = required_type in worker_types
        result = {
            'met': has_match,
            'required': required_type,
            'available': worker_types
        }
        
        if not has_match:
            result['issues'] = [f"Type ouvrier manquant: {required_type}"]
        
        return result

    def _check_equipment_requirements(self, task_template: Dict, resource_template: Dict) -> Dict[str, Any]:
        """Check if resource template has required equipment"""
        from backend.db.repositories.resource_repo import ResourceRepository
        resource_repo = ResourceRepository(self.db_session)
        
        required_equipment = task_template.get('min_equipment_needed', {})
        if not required_equipment:
            return {'met': True, 'message': 'Aucun √©quipement sp√©cifique requis'}
        
        equipment = resource_repo.get_equipment_by_template(resource_template['id'])
        equipment_names = [e.name for e in equipment]
        
        missing = [name for name in required_equipment.keys() if name not in equipment_names]
        result = {
            'met': len(missing) == 0,
            'required': list(required_equipment.keys()),
            'available': equipment_names,
            'missing': missing
        }
        
        if missing:
            result['issues'] = [f"√âquipements manquants: {', '.join(missing)}"]
        
        return result
    def get_available_resource_templates(self, user_id: int) -> List[Dict]:
        """Get available resource templates for user"""
        try:
            from backend.db.repositories.resource_repo import ResourceRepository
            resource_repo = ResourceRepository(self.db_session)
            
            db_templates = resource_repo.get_user_resource_templates(user_id)
            
            templates = []
            for template in db_templates:
                template_dict = {
                    'id': template.id,
                    'name': template.name,
                    'description': template.description,
                    'category': template.category,
                    'version': template.version,
                    'is_default': template.is_default,
                    'is_shared': template.is_shared,
                    'is_active': template.is_active,
                    'created_at': template.created_at.isoformat() if template.created_at else None
                }
                
                # Get resource counts
                counts = resource_repo.count_template_resources(template.id)
                template_dict['worker_count'] = counts['workers']
                template_dict['equipment_count'] = counts['equipment']
                template_dict['total_resources'] = counts['total']
                
                templates.append(template_dict)
            
            self.logger.info(f"‚úÖ Retrieved {len(templates)} resource templates for user {user_id}")
            return templates
            
        except Exception as e:
            self.logger.error(f"‚ùå Error getting resource templates: {e}")
            return []
    
    def get_template_associations(self, resource_template_id: int) -> List[Dict]:
        """Get task template associations for a resource template"""
        try:
            # In a real implementation, this would query an association table
            # For now, we'll return an empty list as placeholder
            associations = []
            
            self.logger.info(f"‚úÖ Retrieved {len(associations)} associations for template {resource_template_id}")
            return associations
            
        except Exception as e:
            self.logger.error(f"‚ùå Error getting template associations: {e}")
            return []
    
    def associate_task_template(self, resource_template_id: int, task_template_id: str) -> bool:
        """Associate a task template with a resource template"""
        try:
            # In a real implementation, this would insert into an association table
            # For now, we'll log and return True as placeholder
            self.logger.info(f"‚úÖ Associated resource template {resource_template_id} with task {task_template_id}")
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå Error associating templates: {e}")
            return False
    
    def remove_task_association(self, resource_template_id: int, task_template_id: str) -> bool:
        """Remove association between resource and task templates"""
        try:
            # In a real implementation, this would delete from an association table
            # For now, we'll log and return True as placeholder
            self.logger.info(f"‚úÖ Removed association between resource template {resource_template_id} and task {task_template_id}")
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå Error removing association: {e}")
            return False
    
    def validate_task_template_dependencies(self, task_template: Dict, resource_template_id: int) -> Dict[str, Any]:
        """Validate if a task template's resource dependencies are satisfied by a resource template"""
        try:
            from backend.db.repositories.resource_repo import ResourceRepository
            resource_repo = ResourceRepository(self.db_session)
            
            missing_workers = []
            missing_equipment = []
            warnings = []
            
            # Get resources from the template
            workers = resource_repo.get_workers_by_template(resource_template_id)
            equipment = resource_repo.get_equipment_by_template(resource_template_id)
            
            # Check worker requirements
            required_worker_type = task_template.get('resource_type')
            if required_worker_type:
                worker_available = any(
                    w.specialty == required_worker_type or w.name == required_worker_type 
                    for w in workers
                )
                if not worker_available:
                    missing_workers.append(required_worker_type)
            
            # Check equipment requirements
            required_equipment = task_template.get('min_equipment_needed', {})
            for equip_name, quantity in required_equipment.items():
                equipment_available = any(
                    e.name == equip_name or e.code == equip_name 
                    for e in equipment
                )
                if not equipment_available:
                    missing_equipment.append(f"{equip_name} (x{quantity})")
            
            # Check if task has any resource dependencies at all
            if not required_worker_type and not required_equipment:
                warnings.append("Cette t√¢che n'a pas de d√©pendances de ressources sp√©cifi√©es")
            
            return {
                'is_valid': len(missing_workers) == 0 and len(missing_equipment) == 0,
                'missing_workers': missing_workers,
                'missing_equipment': missing_equipment,
                'warnings': warnings,
                'resource_template_id': resource_template_id,
                'task_template_id': task_template.get('base_task_id')
            }
            
        except Exception as e:
            self.logger.error(f"‚ùå Error validating task dependencies: {e}")
            return {
                'is_valid': False,
                'missing_workers': [],
                'missing_equipment': [],
                'warnings': [f"Erreur de validation: {str(e)}"],
                'resource_template_id': resource_template_id,
                'task_template_id': task_template.get('base_task_id')
            }
    
    def create_template_association_table(self) -> bool:
        """Create the template association table if it doesn't exist"""
        try:
            # This would typically create an association table in the database
            # For now, we'll just log and return True
            self.logger.info("‚úÖ Template association table ready")
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå Error creating association table: {e}")
            return False
        

    def export_resource_templates(self, user_id: int) -> str:
        """
        Export resource templates to JSON format for download
        Includes templates, workers, and equipment
        """
        try:
            from backend.services.resource_service import ResourceService
            resource_service = ResourceService(self.db_session)
        
            # Get all resource data
            resource_templates = resource_service.get_user_resource_templates(user_id)
        
            export_data = {
                'export_type': 'resource_templates',
                'export_version': '1.0',
                'export_timestamp': datetime.now().isoformat(),
                'user_id': user_id,
                'resource_templates': resource_templates,
                'total_templates': len(resource_templates)
            }
        
            # Add workers and equipment for each template
            for template in resource_templates:
                template_id = template['id']
                workers = resource_service.get_workers_by_template(template_id)
                equipment = resource_service.get_equipment_by_template(template_id)
            
                template['workers'] = workers
                template['equipment'] = equipment
                template['worker_count'] = len(workers)
                template['equipment_count'] = len(equipment)
        
            import json
            return json.dumps(export_data, indent=2, ensure_ascii=False, default=str)
        
        except Exception as e:
            self.logger.error(f"‚ùå Error exporting resource templates: {e}")
            return json.dumps({'error': str(e)})

    def import_resource_templates(self, user_id: int, uploaded_file) -> bool:
        """
        Import resource templates from JSON file
        """
        try:
            import json
            from backend.services.resource_service import ResourceService
            resource_service = ResourceService(self.db_session)
        
            # Parse uploaded file
            file_content = uploaded_file.getvalue().decode('utf-8')
            import_data = json.loads(file_content)
        
            # Validate export format
            if import_data.get('export_type') != 'resource_templates':
                raise ValueError("Invalid file format: Not a resource templates export")
        
            resource_templates = import_data.get('resource_templates', [])
            imported_count = 0
        
            for template_data in resource_templates:
                try:
                    # Create or update resource template
                    existing_templates = resource_service.get_user_resource_templates(user_id)
                    existing_template = next(
                        (t for t in existing_templates if t['name'] == template_data['name']), 
                         None
                    )
                
                    if existing_template:
                        # Update existing template
                        updates = {
                            'description': template_data.get('description', ''),
                            'category': template_data.get('category', 'Custom'),
                            'version': template_data.get('version', 1) + 1
                        }
                        success = resource_service.update_resource_template(existing_template['id'], updates)
                        template_id = existing_template['id']
                    else:
                        # Create new template
                        new_template_data = {
                        'name': template_data['name'],
                        'description': template_data.get('description', ''),
                        'category': template_data.get('category', 'Custom'),
                        'user_id': user_id,
                        'is_default': False,
                        'is_shared': template_data.get('is_shared', False)
                        }
                        new_template = resource_service.create_resource_template(user_id, new_template_data)
                        template_id = new_template['id'] if new_template else None
                
                    if template_id:
                        # Import workers
                        workers = template_data.get('workers', [])
                        for worker_data in workers:
                            worker_data['user_id'] = user_id
                            worker_data['template_id'] = template_id
                            resource_service.create_worker(user_id, worker_data)
                      
                        # Import equipment
                        equipment_list = template_data.get('equipment', [])
                        for equipment_data in equipment_list:
                            equipment_data['user_id'] = user_id
                            equipment_data['template_id'] = template_id
                            resource_service.create_equipment(user_id, equipment_data)
                    
                        imported_count += 1
                    
                except Exception as template_error:
                    self.logger.error(f"Error importing template {template_data.get('name')}: {template_error}")
                    continue
        
            self.logger.info(f"‚úÖ Imported {imported_count} resource templates for user {user_id}")
            return imported_count > 0
        
        except Exception as e:
            self.logger.error(f"‚ùå Error importing resource templates: {e}")
            return False

    def export_task_templates(self, user_id: int) -> str:
        """
        Export task templates to JSON format for download
        """
        try:
            from backend.services.user_task_service import UserTaskService
            task_service = UserTaskService(self.db_session)
        
            # Get all task templates
            task_templates = task_service.get_user_task_templates(user_id)
        
            export_data = {
            'export_type': 'task_templates',
            'export_version': '1.0',
            'export_timestamp': datetime.now().isoformat(),
            'user_id': user_id,
            'task_templates': task_templates,
            'total_tasks': len(task_templates)
            }
        
            import json
            return json.dumps(export_data, indent=2, ensure_ascii=False, default=str)
        
        except Exception as e:
            self.logger.error(f"‚ùå Error exporting task templates: {e}")
            return json.dumps({'error': str(e)})

    def import_task_templates(self, user_id: int, uploaded_file) -> bool:
        """
        Import task templates from JSON file
        """
        try:
            import json
            from backend.services.user_task_service import UserTaskService
            task_service = UserTaskService(self.db_session)
        
            # Parse uploaded file
            file_content = uploaded_file.getvalue().decode('utf-8')
            import_data = json.loads(file_content)
        
            # Validate export format
            if import_data.get('export_type') != 'task_templates':
                raise ValueError("Invalid file format: Not a task templates export")
        
            task_templates = import_data.get('task_templates', [])
            imported_count = 0
        
            for task_data in task_templates:
                try:
                    # Check if task already exists
                    existing_tasks = task_service.get_user_task_templates(user_id)
                    existing_task = next(
                        (t for t in existing_tasks if t.get('base_task_id') == task_data.get('base_task_id')), 
                        None
                    )
                 
                    if existing_task:
                        # Update existing task
                        updates = {
                            'name': task_data.get('name'),
                            'discipline': task_data.get('discipline'),
                            'base_duration': task_data.get('base_duration'),
                            'duration_calculation_method': task_data.get('duration_calculation_method', 'fixed_duration'),
                            'min_crews_needed': task_data.get('min_crews_needed', 1),
                            'min_equipment_needed': task_data.get('min_equipment_needed', {}),
                            'included': task_data.get('included', True)
                        }
                        updated_task = task_service.update_custom_task(user_id, existing_task['base_task_id'], updates)
                        if updated_task:
                            imported_count += 1
                    else:
                        # Create new task
                        task_data['user_id'] = user_id
                        new_task = task_service.create_custom_task(user_id, task_data)
                        if new_task:
                            imported_count += 1
                        
                except Exception as task_error:
                    self.logger.error(f"Error importing task {task_data.get('name')}: {task_error}")
                    continue
        
            self.logger.info(f"‚úÖ Imported {imported_count} task templates for user {user_id}")
            return imported_count > 0
        
        except Exception as e:
            self.logger.error(f"‚ùå Error importing task templates: {e}")
            return False

        

# ====== End of backend/services/template_service.py ======



# ====== Begin of backend/services/resource_service.py ======

"""
PROFESSIONAL Resource Service - Workers & Equipment Management
UPDATED with proper template association handling and modification tracking
"""
import logging
from typing import List, Dict, Optional, Any
from sqlalchemy.orm import Session

logger = logging.getLogger(__name__)

class ResourceService:
    """
    Professional service for resource operations (workers + equipment)
    """
    
    def __init__(self, db_session: Session):
        self.db_session = db_session
        self.logger = logging.getLogger(__name__)
        self._initialize_repositories()
    
    def _initialize_repositories(self):
        """Initialize repositories"""
        try:
            from backend.db.repositories.resource_repo import ResourceRepository
            self.resource_repo = ResourceRepository(self.db_session)
            self.logger.info("‚úÖ ResourceRepository initialized successfully")
        except Exception as e:
            self.logger.error(f"‚ùå ResourceRepository initialization failed: {e}")
            raise
    
    def get_user_resource_templates(self, user_id: int) -> List[Dict]:
        """Get user resource templates"""
        try:
            db_templates = self.resource_repo.get_user_resource_templates(user_id)
            domain_templates = [self._db_to_domain_resource_template(db_template) for db_template in db_templates]
            self.logger.info(f"‚úÖ Retrieved {len(domain_templates)} resource templates for user {user_id}")
            return domain_templates
        except Exception as e:
            self.logger.error(f"‚ùå Error retrieving resource templates: {e}")
            return []
    
    def get_workers_by_template(self, template_id: int) -> List[Dict]:
        """Get workers by template ID"""
        try:
            db_workers = self.resource_repo.get_workers_by_template(template_id)
            return [self._db_to_domain_worker(w) for w in db_workers]
        except Exception as e:
            self.logger.error(f"Error getting workers by template: {e}")
            return []

    def get_equipment_by_template(self, template_id: int) -> List[Dict]:
        """Get equipment by template ID"""
        try:
            db_equipment = self.resource_repo.get_equipment_by_template(template_id)
            return [self._db_to_domain_equipment(e) for e in db_equipment]
        except Exception as e:
            self.logger.error(f"Error getting equipment by template: {e}")
            return []

    def get_user_workers(self, user_id: int, template_id: Optional[int] = None) -> List[Dict]:
        """Get user workers"""
        try:
            db_workers = self.resource_repo.get_user_workers(user_id, template_id)
            domain_workers = [self._db_to_domain_worker(db_worker) for db_worker in db_workers]
            self.logger.info(f"‚úÖ Retrieved {len(domain_workers)} workers for user {user_id}")
            return domain_workers
        except Exception as e:
            self.logger.error(f"‚ùå Error retrieving workers: {e}")
            return []
    
    def get_user_equipment(self, user_id: int, template_id: Optional[int] = None) -> List[Dict]:
        """Get user equipment"""
        try:
            db_equipment = self.resource_repo.get_user_equipment(user_id, template_id)
            domain_equipment = [self._db_to_domain_equipment(db_equip) for db_equip in db_equipment]
            self.logger.info(f"‚úÖ Retrieved {len(domain_equipment)} equipment for user {user_id}")
            return domain_equipment
        except Exception as e:
            self.logger.error(f"‚ùå Error retrieving equipment: {e}")
            return []
    
    def get_resource_counts(self, template_id: int) -> tuple[int, int]:
        """Get worker and equipment counts for a template"""
        try:
            workers = self.resource_repo.get_workers_by_template(template_id)
            equipment = self.resource_repo.get_equipment_by_template(template_id)
            return len(workers), len(equipment)
        except Exception as e:
            self.logger.error(f"Error getting resource counts: {e}")
            return 0, 0
    
    def create_resource_template(self, user_id: int, template_data: Dict) -> Optional[Dict]:
        """Create new resource template and return created template"""
        try:
            template_data['user_id'] = user_id
            db_template = self.resource_repo.create_resource_template(template_data)
            if db_template:
                domain_template = self._db_to_domain_resource_template(db_template)
                self.logger.info(f"‚úÖ Created resource template: {template_data['name']}")
                return domain_template
            return None
        except Exception as e:
            self.logger.error(f"‚ùå Error creating resource template: {e}")
            return None
    
    def get_template_resources(self, template_id: int) -> Dict[str, List]:
        """Get all resources (workers + equipment) for a template"""
        try:
            workers = self.resource_repo.get_workers_by_template(template_id)
            equipment = self.resource_repo.get_equipment_by_template(template_id)
            
            return {
                'workers': [self._db_to_domain_worker(w) for w in workers],
                'equipment': [self._db_to_domain_equipment(e) for e in equipment]
            }
        except Exception as e:
            logger.error(f"Error getting template resources: {e}")
            return {'workers': [], 'equipment': []}
    
    def update_resource_template(self, template_id: int, updates: Dict) -> bool:
        """Update resource template"""
        try:
            success = self.resource_repo.update_resource_template(template_id, updates)
            if success:
                self.logger.info(f"‚úÖ Updated resource template ID: {template_id}")
            return success
        except Exception as e:
            self.logger.error(f"‚ùå Error updating resource template: {e}")
            return False
    
    def create_worker(self, user_id: int, worker_data: Dict) -> Optional[Dict]:
        """Create new worker and return created worker"""
        try:
            worker_data['user_id'] = user_id
            
            # Generate code if not provided
            if not worker_data.get('code'):
                base_name = worker_data['name'][:3].upper()
                worker_data['code'] = f"WRK_{base_name}_{len(self.get_user_workers(user_id)) + 1:03d}"
            
            db_worker = self.resource_repo.create_worker(worker_data)
            if db_worker:
                domain_worker = self._db_to_domain_worker(db_worker)
                self.logger.info(f"‚úÖ Created worker: {worker_data['name']}")
                return domain_worker
            return None
        except Exception as e:
            self.logger.error(f"‚ùå Error creating worker: {e}")
            return None
    
    def update_worker(self, user_id: int, worker_id: int, updates: Dict) -> Optional[Dict]:
        """Update worker and return updated worker"""
        try:
            db_worker = self.resource_repo.update_worker(worker_id, user_id, updates)
            if db_worker:
                domain_worker = self._db_to_domain_worker(db_worker)
                self.logger.info(f"‚úÖ Updated worker ID: {worker_id}")
                return domain_worker
            return None
        except Exception as e:
            self.logger.error(f"‚ùå Error updating worker: {e}")
            return None

    def update_worker_with_template_check(self, user_id: int, worker_id: int, updates: Dict) -> Optional[Dict]:
        """Update worker and mark template as modified if it was default"""
        try:
            # First get the current worker to check template
            current_worker = self.resource_repo.get_worker_by_id(worker_id)
            if not current_worker:
                return None
            
            template_id = current_worker.template_id
            if template_id:
                # Check if template is default and mark it as modified
                self._mark_template_as_modified_if_default(template_id)
            
            # Now update the worker
            return self.update_worker(user_id, worker_id, updates)
            
        except Exception as e:
            self.logger.error(f"‚ùå Error updating worker with template check: {e}")
            return None
    
    def delete_worker(self, user_id: int, worker_id: int) -> bool:
        """Delete worker"""
        try:
            success = self.resource_repo.delete_worker(worker_id, user_id)
            if success:
                self.logger.info(f"‚úÖ Deleted worker ID: {worker_id}")
            return success
        except Exception as e:
            self.logger.error(f"‚ùå Error deleting worker: {e}")
            return False
    
    def create_equipment(self, user_id: int, equipment_data: Dict) -> Optional[Dict]:
        """Create new equipment and return created equipment"""
        try:
            equipment_data['user_id'] = user_id
            
            # Generate code if not provided
            if not equipment_data.get('code'):
                base_name = equipment_data['name'][:3].upper()
                equipment_data['code'] = f"EQP_{base_name}_{len(self.get_user_equipment(user_id)) + 1:03d}"
            
            db_equipment = self.resource_repo.create_equipment(equipment_data)
            if db_equipment:
                domain_equipment = self._db_to_domain_equipment(db_equipment)
                self.logger.info(f"‚úÖ Created equipment: {equipment_data['name']}")
                return domain_equipment
            return None
        except Exception as e:
            self.logger.error(f"‚ùå Error creating equipment: {e}")
            return None
    
    def update_equipment(self, user_id: int, equipment_id: int, updates: Dict) -> Optional[Dict]:
        """Update equipment and return updated equipment"""
        try:
            db_equipment = self.resource_repo.update_equipment(equipment_id, user_id, updates)
            if db_equipment:
                domain_equipment = self._db_to_domain_equipment(db_equipment)
                self.logger.info(f"‚úÖ Updated equipment ID: {equipment_id}")
                return domain_equipment
            return None
        except Exception as e:
            self.logger.error(f"‚ùå Error updating equipment: {e}")
            return None

    def update_equipment_with_template_check(self, user_id: int, equipment_id: int, updates: Dict) -> Optional[Dict]:
        """Update equipment and mark template as modified if it was default"""
        try:
            # First get the current equipment to check template
            current_equipment = self.resource_repo.get_equipment_by_id(equipment_id)
            if not current_equipment:
                return None
            
            template_id = current_equipment.template_id
            if template_id:
                # Check if template is default and mark it as modified
                self._mark_template_as_modified_if_default(template_id)
            
            # Now update the equipment
            return self.update_equipment(user_id, equipment_id, updates)
            
        except Exception as e:
            self.logger.error(f"‚ùå Error updating equipment with template check: {e}")
            return None
    
    def delete_equipment(self, user_id: int, equipment_id: int) -> bool:
        """Delete equipment"""
        try:
            success = self.resource_repo.delete_equipment(equipment_id, user_id)
            if success:
                self.logger.info(f"‚úÖ Deleted equipment ID: {equipment_id}")
            return success
        except Exception as e:
            self.logger.error(f"‚ùå Error deleting equipment: {e}")
            return False

    def _mark_template_as_modified_if_default(self, template_id: int):
        """Mark a template as modified (no longer default) if it was default"""
        try:
            template = self.resource_repo.get_template_by_id(template_id)
            if template and template.is_default:
                # Mark template as no longer default
                updates = {'is_default': False}
                success = self.resource_repo.update_resource_template(template_id, updates)
                if success:
                    self.logger.info(f"üìù Template {template_id} marked as modified (no longer default)")
                return success
            return False
        except Exception as e:
            self.logger.error(f"‚ùå Error marking template as modified: {e}")
            return False
    
    def load_default_resources(self, user_id: int) -> List[Dict]:
        """
        FIXED: Load default resources as user templates with proper template state management
        Returns newly created resources and handles template modification state
        """
        try:
            from backend.defaults.resources import workers, equipment
            
            created_resources = []
            
            # FIRST: Check for existing default templates
            existing_templates = self.get_user_resource_templates(user_id)
            default_template = None
            modified_default_templates = []
            
            # Separate default and modified default templates
            for template in existing_templates:
                if template.get('is_default') and 'D√©faut' in template.get('name', ''):
                    default_template = template
                    self.logger.info(f"‚úÖ Found active default template: {template['name']} (ID: {template['id']})")
                elif not template.get('is_default') and 'D√©faut' in template.get('name', ''):
                    modified_default_templates.append(template)
                    self.logger.info(f"üìù Found modified default template: {template['name']} (ID: {template['id']})")
            
            # If no active default template exists, create one
            if not default_template:
                template_data = {
                    'name': 'Ressources par D√©faut',
                    'description': 'Template de ressources par d√©faut pour la construction',
                    'user_id': user_id,
                    'category': 'Default',
                    'is_default': True
                }
                
                default_template = self.create_resource_template(user_id, template_data)
                if not default_template:
                    self.logger.error("‚ùå Failed to create default resource template")
                    return []
                
                self.logger.info(f"‚úÖ Created new default resource template: {default_template['id']}")
            
            template_id = default_template['id']
            
            # Get existing resources for THIS template to avoid duplicates
            existing_workers = self.get_workers_by_template(template_id)
            existing_equipment = self.get_equipment_by_template(template_id)
            
            existing_worker_names = {w['name'] for w in existing_workers}
            existing_equipment_names = {e['name'] for e in existing_equipment}
            
            # Load default workers
            worker_count = 0
            for worker_name, worker_resource in workers.items():
                if worker_name not in existing_worker_names:
                    worker_code = f"WRK_{worker_name[:3].upper()}"
                    worker_data = {
                        'user_id': user_id,
                        'template_id': template_id,
                        'name': worker_name,
                        'code': worker_code,
                        'specialty': getattr(worker_resource, 'specialty', worker_name),
                        'category': 'Ouvrier',
                        'base_count': getattr(worker_resource, 'count', 1),
                        'hourly_rate': getattr(worker_resource, 'hourly_rate', 0.0),
                        'daily_rate': getattr(worker_resource, 'hourly_rate', 0.0) * 8,
                        'max_workers_per_crew': getattr(worker_resource, 'max_crews', {}).get('default', 1),
                        'base_productivity_rate': 1.0,
                        'productivity_unit': 'unit√©s/jour',
                        'qualification_level': 'Qualifi√©',
                        'skills': getattr(worker_resource, 'skills', []),
                        'is_active': True
                    }
                    created_worker = self.create_worker(user_id, worker_data)
                    if created_worker:
                        created_resources.append(created_worker)
                        worker_count += 1
                        self.logger.info(f"‚úÖ Created worker: {worker_name}")
            
            # Load default equipment
            equipment_count = 0
            for equip_name, equip_resource in equipment.items():
                if equip_name not in existing_equipment_names:
                    equipment_code = f"EQP_{equip_name[:3].upper()}"
                    equipment_data = {
                        'user_id': user_id,
                        'template_id': template_id,
                        'name': equip_name,
                        'code': equipment_code,
                        'type': getattr(equip_resource, 'type', 'EnginLourd'),
                        'category': 'EnginLourd',
                        'base_count': getattr(equip_resource, 'count', 1),
                        'hourly_rate': getattr(equip_resource, 'hourly_rate', 0.0),
                        'daily_rate': getattr(equip_resource, 'hourly_rate', 0.0) * 8,
                        'max_units_per_task': getattr(equip_resource, 'max_equipment', 1),
                        'base_productivity_rate': 1.0,
                        'productivity_unit': 'unit√©s/jour',
                        'requires_operator': True,
                        'operator_type': 'ConducteurEngins',
                        'is_available': True,
                        'is_active': True
                    }
                    created_equipment = self.create_equipment(user_id, equipment_data)
                    if created_equipment:
                        created_resources.append(created_equipment)
                        equipment_count += 1
                        self.logger.info(f"‚úÖ Created equipment: {equip_name}")
            
            self.logger.info(f"‚úÖ Loaded {worker_count} workers and {equipment_count} equipment in default template {template_id}")
            
            # Return newly created resources or existing ones if no new ones
            if not created_resources and (existing_workers or existing_equipment):
                self.logger.info("‚úÖ Default resources already exist, returning existing resources")
                return existing_workers + existing_equipment
            
            return created_resources
            
        except Exception as e:
            self.logger.error(f"‚ùå Error loading default resources: {e}")
            return []
    
    def export_resources_to_json(self) -> str:
        """Export resources to JSON format"""
        try:
            user_id = 1  # From session
            workers = self.get_user_workers(user_id)
            equipment = self.get_user_equipment(user_id)
            templates = self.get_user_resource_templates(user_id)
            
            export_data = {
                'resource_templates': templates,
                'workers': workers,
                'equipment': equipment,
                'export_version': '1.0'
            }
            
            import json
            return json.dumps(export_data, indent=2, ensure_ascii=False)
        except Exception as e:
            self.logger.error(f"‚ùå Error exporting resources to JSON: {e}")
            return "{}"
    
    def import_resources_from_json(self, uploaded_file) -> bool:
        """Import resources from JSON file"""
        try:
            import json
            resources_data = json.load(uploaded_file)
            user_id = 1  # From session
            
            success_count = 0
            
            # Import workers
            if 'workers' in resources_data:
                for worker_data in resources_data['workers']:
                    worker_data['user_id'] = user_id
                    if self.create_worker(user_id, worker_data):
                        success_count += 1
            
            # Import equipment
            if 'equipment' in resources_data:
                for equipment_data in resources_data['equipment']:
                    equipment_data['user_id'] = user_id
                    if self.create_equipment(user_id, equipment_data):
                        success_count += 1
            
            self.logger.info(f"‚úÖ Imported {success_count} resources from JSON")
            return success_count > 0
            
        except Exception as e:
            self.logger.error(f"‚ùå Error importing resources from JSON: {e}")
            return False
    
    def _db_to_domain_resource_template(self, db_template) -> Dict:
        """Convert DB model to domain resource template dictionary"""
        return {
            'id': db_template.id,
            'name': db_template.name,
            'description': db_template.description,
            'category': db_template.category,
            'version': db_template.version,
            'is_default': db_template.is_default,
            'is_shared': db_template.is_shared,
            'is_active': db_template.is_active,
            'created_at': db_template.created_at.isoformat() if db_template.created_at else None
        }
    
    def _db_to_domain_worker(self, db_worker) -> Dict:
        """Convert DB model to domain worker dictionary"""
        return {
            'id': db_worker.id,
            'user_id': db_worker.user_id,
            'template_id': db_worker.template_id,
            'name': db_worker.name,
            'code': db_worker.code,
            'specialty': db_worker.specialty,
            'category': db_worker.category,
            'base_count': db_worker.base_count,
            'hourly_rate': float(db_worker.hourly_rate),
            'daily_rate': float(db_worker.daily_rate),
            'max_workers_per_crew': db_worker.max_workers_per_crew,
            'base_productivity_rate': float(db_worker.base_productivity_rate),
            'productivity_unit': db_worker.productivity_unit,
            'qualification_level': db_worker.qualification_level,
            'skills': db_worker.skills or [],
            'required_certifications': db_worker.required_certifications or [],
            'is_active': db_worker.is_active,
            'description': db_worker.description,
            'created_at': db_worker.created_at.isoformat() if db_worker.created_at else None
        }
    
    def _db_to_domain_equipment(self, db_equipment) -> Dict:
        """Convert DB model to domain equipment dictionary"""
        return {
            'id': db_equipment.id,
            'user_id': db_equipment.user_id,
            'template_id': db_equipment.template_id,
            'name': db_equipment.name,
            'code': db_equipment.code,
            'type': db_equipment.type,
            'category': db_equipment.category,
            'model': db_equipment.model,
            'base_count': db_equipment.base_count,
            'hourly_rate': float(db_equipment.hourly_rate),
            'daily_rate': float(db_equipment.daily_rate),
            'capacity': db_equipment.capacity,
            'max_units_per_task': db_equipment.max_units_per_task,
            'base_productivity_rate': float(db_equipment.base_productivity_rate),
            'productivity_unit': db_equipment.productivity_unit,
            'requires_operator': db_equipment.requires_operator,
            'operator_type': db_equipment.operator_type,
            'is_available': db_equipment.is_available,
            'is_active': db_equipment.is_active,
            'description': db_equipment.description,
            'created_at': db_equipment.created_at.isoformat() if db_equipment.created_at else None
        }

# ====== End of backend/services/resource_service.py ======



# ====== Begin of backend/db/repositories/task_repo.py ======

"""
Professional Task Repository for CRUD operations
UPDATED with duration calculation methods support
"""
import logging
from typing import List, Dict, Optional, Any
from sqlalchemy.orm import Session
from sqlalchemy import and_, or_

from backend.models.db_models import UserTaskTemplateDB
from backend.models.domain_models import BaseTask, TaskType

logger = logging.getLogger(__name__)

class TaskRepository:
    """
    Professional repository for task template operations with duration methods
    """
    
    def __init__(self, db_session: Session):
        self.db_session = db_session
        self.logger = logging.getLogger(__name__)
    
    def get_user_task_templates(self, user_id: int, project_id: Optional[int] = None) -> List[UserTaskTemplateDB]:
        """
        Get all task templates for a user with duration methods
        """
        try:
            query = self.db_session.query(UserTaskTemplateDB).filter(
                UserTaskTemplateDB.user_id == user_id,
                UserTaskTemplateDB.is_active == True
            )
            
            if project_id:
                # If you add project-specific templates later
                pass
                
            templates = query.order_by(UserTaskTemplateDB.discipline, UserTaskTemplateDB.name).all()
            self.logger.info(f"Retrieved {len(templates)} task templates for user {user_id}")
            return templates
            
        except Exception as e:
            self.logger.error(f"Error getting user task templates: {e}")
            return []
    
    def create_user_task_template(self, task_data: Dict[str, Any]) -> Optional[UserTaskTemplateDB]:
        """
        Create a new user task template with duration method support
        """
        try:
            # Check if template already exists for this user and base_task_id
            existing = self.db_session.query(UserTaskTemplateDB).filter(
                UserTaskTemplateDB.user_id == task_data['user_id'],
                UserTaskTemplateDB.base_task_id == task_data['base_task_id']
            ).first()
            
            # Set default duration method if not provided
            if 'duration_calculation_method' not in task_data:
                task_data['duration_calculation_method'] = 'fixed_duration'
            
            if existing:
                # Update existing template
                for key, value in task_data.items():
                    if hasattr(existing, key) and key not in ['id', 'created_at']:
                        setattr(existing, key, value)

                self.logger.info(f"Updated existing task template: {task_data['base_task_id']}")
                return existing
            else:
                # Create new template
                db_template = UserTaskTemplateDB(**task_data)
                self.db_session.add(db_template)
                self.db_session.flush()
                self.logger.info(f"Created new task template: {task_data['base_task_id']}")
                return db_template
                
        except Exception as e:
   
            self.logger.error(f"Error creating task template: {e}")
            return None
    
    def update_user_task_template(self, user_id: int, task_id: int, updates: Dict[str, Any]) -> Optional[UserTaskTemplateDB]:
        """
        Update a user task template with duration method support
        """
        try:
            db_template = self.db_session.query(UserTaskTemplateDB).filter(
                UserTaskTemplateDB.id == task_id,
                UserTaskTemplateDB.user_id == user_id
            ).first()
            
            if db_template:
                for key, value in updates.items():
                    if hasattr(db_template, key) and key not in ['id', 'user_id', 'created_at']:
                        setattr(db_template, key, value)
                self.logger.info(f"Updated task template {task_id} with duration method: {updates.get('duration_calculation_method')}")
                return db_template
            else:
                self.logger.warning(f"Task template {task_id} not found for user {user_id}")
                return None
                
        except Exception as e:
            self.logger.error(f"Error updating task template: {e}")
            return None
    
    # Keep existing methods for compatibility
    def get_user_task_templates_as_base_tasks(self, user_id: int, project_id: Optional[int] = None) -> Dict[str, BaseTask]:
        """
        CRITICAL: Convert user task templates to BaseTask format for the scheduler
        Now includes duration calculation methods
        """
        try:
            db_templates = self.get_user_task_templates(user_id, project_id)
            base_tasks = {}
            
            for db_template in db_templates:
                base_task_id = db_template.base_task_id
                
                # Create BaseTask object from user template with duration methods
                base_task = BaseTask(
                    id=base_task_id,
                    name=db_template.name,
                    discipline=db_template.discipline,
                    sub_discipline=db_template.sub_discipline,
                    resource_type=db_template.resource_type,
                    task_type=TaskType(db_template.task_type.upper()) if isinstance(db_template.task_type, str) else db_template.task_type,
                    base_duration=db_template.base_duration,
                    unit_duration=getattr(db_template, 'unit_duration', 0),
                    duration_calculation_method=getattr(db_template, 'duration_calculation_method', 'fixed_duration'),
                    min_crews_needed=db_template.min_crews_needed,
                    min_equipment_needed=db_template.min_equipment_needed or {},
                    predecessors=db_template.predecessors or [],
                    repeat_on_floor=db_template.repeat_on_floor,
                    delay=db_template.delay,
                    weather_sensitive=db_template.weather_sensitive,
                    quality_gate=db_template.quality_gate,
                    included=db_template.included
                )
                
                base_tasks[base_task_id] = base_task
            
            self.logger.info(f"Converted {len(base_tasks)} user templates to BaseTask format with duration methods")
            return base_tasks
            
        except Exception as e:
            self.logger.error(f"Error converting user templates to BaseTask: {e}")
            return {}
    
    def delete_user_task_template(self, user_id: int, task_id: int) -> bool:
        """
        Soft delete a user task template
        """
        try:
            db_template = self.db_session.query(UserTaskTemplateDB).filter(
                UserTaskTemplateDB.id == task_id,
                UserTaskTemplateDB.user_id == user_id
            ).first()
            
            if db_template:
                db_template.is_active = False

                self.logger.info(f"Soft deleted task template {task_id}")
                return True
            else:
                self.logger.warning(f"Task template {task_id} not found for user {user_id}")
                return False
                
        except Exception as e:
            self.logger.error(f"Error deleting task template: {e}")
            return False


# ====== End of backend/db/repositories/task_repo.py ======



# ====== Begin of backend/db/repositories/resource_repo.py ======

"""
PROFESSIONAL Resource Repository - UPDATED with Resource Template Support
Enhanced for unified resource management with proper template associations
"""
import logging
from typing import List, Dict, Optional, Any
from sqlalchemy.orm import Session
from sqlalchemy import and_, or_

from backend.models.db_models import ResourceTemplateDB, WorkerResourceDB, EquipmentResourceDB

logger = logging.getLogger(__name__)

class ResourceRepository:
    """
    UPDATED Professional repository for resource operations with template support
    """
    
    def __init__(self, db_session: Session):
        self.db_session = db_session
        self.logger = logging.getLogger(__name__)
    
    # RESOURCE TEMPLATE METHODS
    def get_user_resource_templates(self, user_id: int) -> List[ResourceTemplateDB]:
        """Get all resource templates for a user"""
        try:
            templates = self.db_session.query(ResourceTemplateDB).filter(
                ResourceTemplateDB.user_id == user_id,
                ResourceTemplateDB.is_active == True
            ).order_by(ResourceTemplateDB.name).all()
            
            self.logger.info(f"‚úÖ Retrieved {len(templates)} resource templates for user {user_id}")
            return templates
            
        except Exception as e:
            self.logger.error(f"‚ùå Error getting user resource templates: {e}")
            return []
    
    def create_resource_template(self, template_data: Dict[str, Any]) -> Optional[ResourceTemplateDB]:
        """Create a new resource template - NO COMMIT"""
        try:
            # Check if template already exists for this user and name
            existing = self.db_session.query(ResourceTemplateDB).filter(
                ResourceTemplateDB.user_id == template_data['user_id'],
                ResourceTemplateDB.name == template_data['name']
            ).first()
            
            if existing:
                self.logger.warning(f"‚ö†Ô∏è Resource template already exists: {template_data['name']}")
                return existing
            
            db_template = ResourceTemplateDB(**template_data)
            self.db_session.add(db_template)
            self.db_session.flush()
            self.logger.info(f"‚úÖ Created new resource template: {template_data['name']}")
            return db_template
            
        except Exception as e:
            self.logger.error(f"‚ùå Error creating resource template: {e}")
            return None
    
    def update_resource_template(self, template_id: int, updates: Dict[str, Any]) -> bool:
        """Update a resource template by ID - NO COMMIT"""
        try:
            db_template = self.db_session.query(ResourceTemplateDB).filter(
                ResourceTemplateDB.id == template_id
            ).first()
            
            if db_template:
                for key, value in updates.items():
                    if hasattr(db_template, key) and key not in ['id', 'user_id', 'created_at']:
                        setattr(db_template, key, value)
                self.db_session.flush()
                self.logger.info(f"‚úÖ Updated resource template ID: {template_id}")
                return True
            else:
                self.logger.warning(f"‚ö†Ô∏è Resource template ID {template_id} not found")
                return False
                
        except Exception as e:
            self.logger.error(f"‚ùå Error updating resource template: {e}")
            return False
    
    def get_workers_by_template(self, template_id: int) -> List[WorkerResourceDB]:
        """Get all workers for a specific template"""
        try:
            workers = self.db_session.query(WorkerResourceDB).filter(
                WorkerResourceDB.template_id == template_id,
                WorkerResourceDB.is_active == True
            ).order_by(WorkerResourceDB.name).all()
            
            self.logger.info(f"‚úÖ Retrieved {len(workers)} workers for template {template_id}")
            return workers
            
        except Exception as e:
            self.logger.error(f"‚ùå Error getting workers by template: {e}")
            return []
    
    def get_equipment_by_template(self, template_id: int) -> List[EquipmentResourceDB]:
        """Get all equipment for a specific template"""
        try:
            equipment = self.db_session.query(EquipmentResourceDB).filter(
                EquipmentResourceDB.template_id == template_id,
                EquipmentResourceDB.is_active == True
            ).order_by(EquipmentResourceDB.name).all()
            
            self.logger.info(f"‚úÖ Retrieved {len(equipment)} equipment for template {template_id}")
            return equipment
            
        except Exception as e:
            self.logger.error(f"‚ùå Error getting equipment by template: {e}")
            return []
    
    # WORKER METHODS
    def get_user_workers(self, user_id: int, template_id: Optional[int] = None) -> List[WorkerResourceDB]:
        """Get all workers for a user"""
        try:
            query = self.db_session.query(WorkerResourceDB).filter(
                WorkerResourceDB.user_id == user_id,
                WorkerResourceDB.is_active == True
            )
            
            if template_id:
                query = query.filter(WorkerResourceDB.template_id == template_id)
                
            workers = query.order_by(WorkerResourceDB.name).all()
            self.logger.info(f"‚úÖ Retrieved {len(workers)} workers for user {user_id}")
            return workers
            
        except Exception as e:
            self.logger.error(f"‚ùå Error getting user workers: {e}")
            return []
    
    def create_worker(self, worker_data: Dict[str, Any]) -> Optional[WorkerResourceDB]:
        """Create a new worker - NO COMMIT"""
        try:
            # Check if worker already exists for this user and code
            existing = self.db_session.query(WorkerResourceDB).filter(
                WorkerResourceDB.user_id == worker_data['user_id'],
                WorkerResourceDB.code == worker_data['code']
            ).first()
            
            if existing:
                self.logger.warning(f"‚ö†Ô∏è Worker already exists: {worker_data['code']}")
                return existing
            
            db_worker = WorkerResourceDB(**worker_data)
            self.db_session.add(db_worker)
            self.db_session.flush()
            self.logger.info(f"‚úÖ Created new worker: {worker_data['name']}")
            return db_worker
            
        except Exception as e:
            self.logger.error(f"‚ùå Error creating worker: {e}")
            return None
    
    def update_worker(self, worker_id: int, user_id: int, updates: Dict[str, Any]) -> Optional[WorkerResourceDB]:
        """Update a worker by ID - NO COMMIT"""
        try:
            db_worker = self.db_session.query(WorkerResourceDB).filter(
                WorkerResourceDB.id == worker_id,
                WorkerResourceDB.user_id == user_id
            ).first()
            
            if db_worker:
                for key, value in updates.items():
                    if hasattr(db_worker, key) and key not in ['id', 'user_id', 'created_at']:
                        setattr(db_worker, key, value)
                self.db_session.flush()
                self.logger.info(f"‚úÖ Updated worker ID: {worker_id}")
                return db_worker
            else:
                self.logger.warning(f"‚ö†Ô∏è Worker ID {worker_id} not found for user {user_id}")
                return None
                
        except Exception as e:
            self.logger.error(f"‚ùå Error updating worker: {e}")
            return None
    
    def delete_worker(self, worker_id: int, user_id: int) -> bool:
        """Soft delete a worker by ID - NO COMMIT"""
        try:
            db_worker = self.db_session.query(WorkerResourceDB).filter(
                WorkerResourceDB.id == worker_id,
                WorkerResourceDB.user_id == user_id
            ).first()
            
            if db_worker:
                db_worker.is_active = False
                self.db_session.flush()
                self.logger.info(f"‚úÖ Soft deleted worker ID: {worker_id}")
                return True
            else:
                self.logger.warning(f"‚ö†Ô∏è Worker ID {worker_id} not found for user {user_id}")
                return False
                
        except Exception as e:
            self.logger.error(f"‚ùå Error deleting worker: {e}")
            return False
    
    # EQUIPMENT METHODS
    def get_user_equipment(self, user_id: int, template_id: Optional[int] = None) -> List[EquipmentResourceDB]:
        """Get all equipment for a user"""
        try:
            query = self.db_session.query(EquipmentResourceDB).filter(
                EquipmentResourceDB.user_id == user_id,
                EquipmentResourceDB.is_active == True
            )
            
            if template_id:
                query = query.filter(EquipmentResourceDB.template_id == template_id)
                
            equipment = query.order_by(EquipmentResourceDB.name).all()
            self.logger.info(f"‚úÖ Retrieved {len(equipment)} equipment for user {user_id}")
            return equipment
            
        except Exception as e:
            self.logger.error(f"‚ùå Error getting user equipment: {e}")
            return []
    
    def create_equipment(self, equipment_data: Dict[str, Any]) -> Optional[EquipmentResourceDB]:
        """Create a new equipment - NO COMMIT"""
        try:
            # Check if equipment already exists for this user and code
            existing = self.db_session.query(EquipmentResourceDB).filter(
                EquipmentResourceDB.user_id == equipment_data['user_id'],
                EquipmentResourceDB.code == equipment_data['code']
            ).first()
            
            if existing:
                self.logger.warning(f"‚ö†Ô∏è Equipment already exists: {equipment_data['code']}")
                return existing
            
            db_equipment = EquipmentResourceDB(**equipment_data)
            self.db_session.add(db_equipment)
            self.db_session.flush()
            self.logger.info(f"‚úÖ Created new equipment: {equipment_data['name']}")
            return db_equipment
            
        except Exception as e:
            self.logger.error(f"‚ùå Error creating equipment: {e}")
            return None
    
    def update_equipment(self, equipment_id: int, user_id: int, updates: Dict[str, Any]) -> Optional[EquipmentResourceDB]:
        """Update an equipment by ID - NO COMMIT"""
        try:
            db_equipment = self.db_session.query(EquipmentResourceDB).filter(
                EquipmentResourceDB.id == equipment_id,
                EquipmentResourceDB.user_id == user_id
            ).first()
            
            if db_equipment:
                for key, value in updates.items():
                    if hasattr(db_equipment, key) and key not in ['id', 'user_id', 'created_at']:
                        setattr(db_equipment, key, value)
                self.db_session.flush()
                self.logger.info(f"‚úÖ Updated equipment ID: {equipment_id}")
                return db_equipment
            else:
                self.logger.warning(f"‚ö†Ô∏è Equipment ID {equipment_id} not found for user {user_id}")
                return None
                
        except Exception as e:
            self.logger.error(f"‚ùå Error updating equipment: {e}")
            return None
    
    def delete_equipment(self, equipment_id: int, user_id: int) -> bool:
        """Soft delete an equipment by ID - NO COMMIT"""
        try:
            db_equipment = self.db_session.query(EquipmentResourceDB).filter(
                EquipmentResourceDB.id == equipment_id,
                EquipmentResourceDB.user_id == user_id
            ).first()
            
            if db_equipment:
                db_equipment.is_active = False
                self.db_session.flush()
                self.logger.info(f"‚úÖ Soft deleted equipment ID: {equipment_id}")
                return True
            else:
                self.logger.warning(f"‚ö†Ô∏è Equipment ID {equipment_id} not found for user {user_id}")
                return False
                
        except Exception as e:
            self.logger.error(f"‚ùå Error deleting equipment: {e}")
            return False
    
    # BULK OPERATIONS
    def get_template_with_resources(self, template_id: int) -> Optional[Dict[str, Any]]:
        """Get a template with all its resources"""
        try:
            template = self.db_session.query(ResourceTemplateDB).filter(
                ResourceTemplateDB.id == template_id
            ).first()
            
            if template:
                workers = self.get_workers_by_template(template_id)
                equipment = self.get_equipment_by_template(template_id)
                
                return {
                    'template': template,
                    'workers': workers,
                    'equipment': equipment
                }
            else:
                return None
                
        except Exception as e:
            self.logger.error(f"‚ùå Error getting template with resources: {e}")
            return None
    
    def count_template_resources(self, template_id: int) -> Dict[str, int]:
        """Count resources in a template"""
        try:
            worker_count = self.db_session.query(WorkerResourceDB).filter(
                WorkerResourceDB.template_id == template_id,
                WorkerResourceDB.is_active == True
            ).count()
            
            equipment_count = self.db_session.query(EquipmentResourceDB).filter(
                EquipmentResourceDB.template_id == template_id,
                EquipmentResourceDB.is_active == True
            ).count()
            
            return {
                'workers': worker_count,
                'equipment': equipment_count,
                'total': worker_count + equipment_count
            }
            
        except Exception as e:
            self.logger.error(f"‚ùå Error counting template resources: {e}")
            return {'workers': 0, 'equipment': 0, 'total': 0}
        
    def get_worker_by_id(self, worker_id: int):
        """Get worker by ID"""
        try:
            return self.db_session.query(WorkerResourceDB).filter(
            WorkerResourceDB.id == worker_id
            ).first()
        except Exception as e:
            self.logger.error(f"Error getting worker by ID: {e}")
            return None

    def get_equipment_by_id(self, equipment_id: int):
        """Get equipment by ID"""
        try:
            return self.db_session.query(EquipmentResourceDB).filter(
            EquipmentResourceDB.id == equipment_id
            ).first()
        except Exception as e:
            self.logger.error(f"Error getting equipment by ID: {e}")
            return None

    def get_template_by_id(self, template_id: int):
        """Get template by ID"""
        try:
            return self.db_session.query(ResourceTemplateDB).filter(
            ResourceTemplateDB.id == template_id
            ).first()
        except Exception as e:
            self.logger.error(f"Error getting template by ID: {e}")
            return None

# ====== End of backend/db/repositories/resource_repo.py ======



# ====== Begin of frontend/helpers/template_context.py ======

"""
Template Context Manager for unified template state management - UPDATED
"""

import streamlit as st
from typing import Dict, Any, Optional, List, Callable
import logging

logger = logging.getLogger(__name__)

class TemplateContextManager:
    """
    Professional template context manager for unified state management
    UPDATED: Works with new service pattern from app.py
    """
    
    def __init__(self):
        self._observers: List[Callable] = []
        
        # Initialize session state for templates if not exists
        if 'template_context' not in st.session_state:
            st.session_state.template_context = {
                'resource_template': None,
                'task_template': None,
                'last_updated': None,
                'initialized': False
            }
    
    @property
    def resource_template(self) -> Optional[Dict[str, Any]]:
        return st.session_state.template_context['resource_template']
    
    @resource_template.setter
    def resource_template(self, template: Optional[Dict[str, Any]]):
        st.session_state.template_context['resource_template'] = template
        st.session_state.template_context['last_updated'] = 'resource'
        self._notify_observers()
    
    @property
    def task_template(self) -> Optional[Dict[str, Any]]:
        return st.session_state.template_context['task_template']
    
    @task_template.setter
    def task_template(self, template: Optional[Dict[str, Any]]):
        st.session_state.template_context['task_template'] = template
        st.session_state.template_context['last_updated'] = 'task'
        self._notify_observers()
    
    def get_current_context(self) -> Dict[str, Any]:
        """Get complete context with validation state"""
        context = {
            'resource_template': self.resource_template,
            'task_template': self.task_template,
            'is_ready': bool(self.resource_template and self.task_template),
            'last_updated': st.session_state.template_context.get('last_updated'),
            'initialized': st.session_state.template_context.get('initialized', False)
        }
        
        # Add compatibility info if both templates are selected
        if context['is_ready']:
            context['compatibility'] = self._get_compatibility_summary()
            
        return context
    
    def is_ready(self) -> bool:
        """Check if both resource and task templates are set."""
        return bool(self.resource_template and self.task_template)
    
    def initialize_with_services(self, services: Dict[str, Any], user_id: int):
        """Initialize context with services from app.py"""
        try:
            if st.session_state.template_context.get('initialized'):
                return
                
            # Get available templates from services
            resource_service = services['resource_service']
            task_service = services['task_service']
            
            resource_templates = resource_service.get_user_resource_templates(user_id)
            task_templates = task_service.get_user_task_templates(user_id)
            
            # Set default selections if available
            if resource_templates:
                self.resource_template = resource_templates[0]
            
            if task_templates:
                # Use the first task template group
                task_groups = task_service.get_task_template_groups(user_id)
                if task_groups:
                    self.task_template = task_groups[0]
            
            st.session_state.template_context['initialized'] = True
            logger.info("‚úÖ Template context initialized with services")
            
        except Exception as e:
            logger.error(f"‚ùå Error initializing template context with services: {e}")
    
    def clear_context(self):
        """Clear all template context"""
        st.session_state.template_context = {
            'resource_template': None,
            'task_template': None,
            'last_updated': None,
            'initialized': False
        }
        self._notify_observers()
    
    def register_observer(self, callback: Callable):
        """Register a callback to be called when context changes"""
        if callback not in self._observers:
            self._observers.append(callback)
            logger.info(f"Registered template context observer: {callback.__name__}")
    
    def unregister_observer(self, callback: Callable):
        """Unregister an observer"""
        if callback in self._observers:
            self._observers.remove(callback)
    
    def _notify_observers(self):
        """Notify all observers of context changes"""
        for callback in self._observers:
            try:
                callback()
            except Exception as e:
                logger.error(f"Error in template context observer {callback.__name__}: {e}")
    
    def _get_compatibility_summary(self) -> Dict[str, Any]:
        """Generate compatibility summary for current context"""
        if not self.resource_template or not self.task_template:
            return {}
            
        return {
            'status': 'unknown',  # Will be set by validation service
            'resource_match': True,
            'equipment_match': True,
            'notes': 'Compatibility validation pending'
        }

# Global instance for easy access
template_context = TemplateContextManager()

def get_template_context() -> TemplateContextManager:
    """Get the global template context instance"""
    return template_context

def render_template_context_selector(services: Dict[str, Any], user_id: int):
    """
    Render template context selector component - UPDATED
    Uses services passed from app.py instead of reinitializing
    """
    context = get_template_context()
    
    # Initialize context with services if not done
    if not context.get_current_context()['initialized']:
        context.initialize_with_services(services, user_id)
    
    st.markdown("### üéØ Contexte de Travail")
    
    col1, col2 = st.columns(2)
    
    with col1:
        _render_resource_template_selector(services, user_id, context)
    
    with col2:
        _render_task_template_selector(services, user_id, context)
    
    # Display current context status
    _render_context_status(context, services)

def _render_resource_template_selector(services, user_id: int, context: TemplateContextManager):
    """Render resource template selector - UPDATED"""
    resource_service = services['resource_service']
    resource_templates = resource_service.get_user_resource_templates(user_id)
    
    if resource_templates:
        template_options = {f"{rt['name']} (ID: {rt['id']})": rt for rt in resource_templates}
        
        # Get current selection
        current_template = context.resource_template
        current_key = None
        if current_template:
            current_key = f"{current_template['name']} (ID: {current_template['id']})"
        
        selected_key = st.selectbox(
            "üì¶ Mod√®le de Ressources Actif:",
            options=[''] + list(template_options.keys()),
            index=list(template_options.keys()).index(current_key) + 1 if current_key else 0,
            key="resource_context_selector_main",
            help="S√©lectionnez le mod√®le de ressources que vous modifiez"
        )
        
        if selected_key and selected_key in template_options:
            context.resource_template = template_options[selected_key]
        elif not selected_key:
            context.resource_template = None
            
    else:
        st.error("‚ùå Aucun mod√®le de ressources disponible")
        if st.button("üì• Cr√©er Mod√®le D√©faut", key="create_default_resource"):
            resource_service.load_default_resources(user_id)
            st.rerun()

def _render_task_template_selector(services, user_id: int, context: TemplateContextManager):
    """Render task template selector - UPDATED to use services from app.py"""
    task_service = services['task_service']
    
    # Get task template groups using the service method
    task_groups = task_service.get_task_template_groups(user_id)
    
    if task_groups:
        # Create display options for template groups
        template_options = {}
        for group in task_groups:
            template_name = group['template_name']
            disciplines = ', '.join(sorted(group['disciplines']))
            display_name = f"{template_name} ({group['task_count']} t√¢ches, {disciplines})"
            template_options[display_name] = group
        
        # Get current selection
        current_template = context.task_template
        current_key = None
        if current_template:
            current_template_name = current_template.get('template_name')
            if current_template_name:
                for display_name, template_data in template_options.items():
                    if template_data['template_name'] == current_template_name:
                        current_key = display_name
                        break
        
        selected_key = st.selectbox(
            "üìö Groupe de T√¢ches Actif:",
            options=[''] + list(template_options.keys()),
            index=list(template_options.keys()).index(current_key) + 1 if current_key else 0,
            key="task_context_selector_main",
            help="S√©lectionnez un groupe de t√¢ches (template) pour les taux de productivit√©"
        )
        
        if selected_key and selected_key in template_options:
            context.task_template = template_options[selected_key]
        elif not selected_key:
            context.task_template = None
            
    else:
        st.error("‚ùå Aucun groupe de t√¢ches disponible")
        if st.button("üì• Charger T√¢ches D√©faut", key="load_default_tasks"):
            task_service.load_default_tasks(user_id)
            st.rerun()

def _render_context_status(context: TemplateContextManager, services: Dict[str, Any]):
    """Render current context status - UPDATED"""
    current_context = context.get_current_context()
    
    if current_context['is_ready']:
        st.success("‚úÖ Contexte pr√™t pour les op√©rations")
        
        # Display template details
        col1, col2 = st.columns(2)
        with col1:
            st.info(f"**Ressources:** {current_context['resource_template']['name']}")
        with col2:
            template_name = current_context['task_template'].get('template_name', 'Sans nom')
            st.info(f"**T√¢ches:** {template_name}")
        
        # Validate compatibility
        if st.button("üîç Valider Compatibilit√©", key="validate_compatibility"):
            _validate_template_compatibility(context, services)
    else:
        st.warning("‚ö†Ô∏è S√©lectionnez un mod√®le de ressources ET un mod√®le de t√¢ches")

def _validate_template_compatibility(context: TemplateContextManager, services: Dict[str, Any]):
    """Validate template compatibility - UPDATED"""
    try:
        template_service = services['template_service']
        current_context = context.get_current_context()
        
        if current_context['is_ready']:
            validation = template_service.validate_template_compatibility(
                current_context['resource_template'],
                current_context['task_template']
            )
            
            if validation.get('compatible', False):
                st.success("‚úÖ Templates compatibles!")
            else:
                st.error("‚ùå Probl√®mes de compatibilit√© d√©tect√©s")
                
            # Show detailed validation results
            with st.expander("üìã D√©tails de Validation", expanded=True):
                st.json(validation)
                
    except Exception as e:
        st.error(f"‚ùå Erreur lors de la validation: {e}")

# ====== End of frontend/helpers/template_context.py ======

