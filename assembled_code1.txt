

# ====== Begin of app.py ======

"""
PROFESSIONAL Construction Project Planner - FIXED VERSION
Unified Session Management & Transaction Safety
"""

import streamlit as st
import logging
import sys
import os
from sqlalchemy.orm import Session
from typing import Optional, Callable,Dict,  Any
from contextlib import contextmanager

# Add backend to path
sys.path.append(os.path.join(os.path.dirname(__file__), 'backend'))

# Configure professional logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class ConstructionApp:
    """
    FIXED Professional main application with unified session management
    """

    def __init__(self):
        self._setup_page_config()
        self._initialize_session_state()
        self._initialize_database()

    # ------------------- Initialization -------------------

    def _setup_page_config(self):
        """Setup professional page configuration"""
        st.set_page_config(
            page_title="Construction Project Planner",
            page_icon="üèóÔ∏è",
            layout="wide",
            initial_sidebar_state="expanded",
            menu_items={
                'Get Help': 'https://github.com/your-repo/construction-planner',
                'Report a bug': "https://github.com/your-repo/construction-planner/issues",
                'About': "### üèóÔ∏è Construction Project Planner\nProfessional construction scheduling and resource management system"
            }
        )

    def _initialize_session_state(self):
        """Initialize unified session state"""
        # 1. Authentication Session Manager (User identity & permissions)
        if 'auth_session_manager' not in st.session_state:
            from backend.auth.session_manager import SessionManager
            st.session_state.auth_session_manager = SessionManager()
            logger.info("‚úÖ Authentication session manager initialized")

        # 2. Application state defaults
        defaults = {
            'app_initialized': True,
            'current_page': 'login',
            'current_project_id': None,
            'current_project_name': None,
            'navigation_section': 'scheduling',
            '_previous_page': None,
            'widget_debug': False,
            'project_config': {
                'basic_info': {
                    'project_name': 'My Construction Project',
                    'project_manager': '',
                    'start_date': None,
                    'description': '',
                    'project_type': 'Commercial',
                    'client_name': '',
                    'location': ''
                },
                'zones': {},
                'advanced_settings': {
                    'work_hours_per_day': 8,
                    'acceleration_factor': 1.0,
                    'risk_allowance': 0.1
                }
            },
            'project_zones': {}
        }

        for key, value in defaults.items():
            if key not in st.session_state:
                st.session_state[key] = value

    def _initialize_database(self):
        """Initialize database connection professionally"""
        try:
            from backend.db.session import init_database
            init_database()
            logger.info("‚úÖ Database initialized successfully")
        except Exception as e:
            logger.error(f"‚ùå Database initialization failed: {e}")
            st.warning("‚ö†Ô∏è Database connection unavailable - using session storage")

    # ------------------- Session Management -------------------

    def _is_authenticated(self) -> bool:
        """Check if user is authenticated via auth session manager"""
        auth_manager = st.session_state.auth_session_manager
        return hasattr(auth_manager, 'is_authenticated') and auth_manager.is_authenticated()

    def _get_current_user_id(self) -> Optional[int]:
        """Get current user ID safely via auth session manager"""
        if self._is_authenticated():
            return st.session_state.auth_session_manager.get_user_id()
        return None

    def _initialize_services(self, db_session: Session, user_id: int) -> Dict[str, Any]:
        """
        Initialize all services with the current database session
        These services are request-scoped and not stored in session state
        """
        try:
            from backend.services.user_service import UserService
            from backend.services.project_service import ProjectService
            from backend.services.user_task_service import UserTaskService
            from backend.services.resource_service import ResourceService
            from backend.services.template_service import TemplateService
            from backend.services.zone_sequence_service import ZoneSequenceService
            from backend.services.scheduling_service import SchedulingService
            from backend.services.reporting_service import ReportingService
            from backend.services.monitoring_service import MonitoringService
            
            services = {
                'user_service': UserService(db_session),  
                'project_service': ProjectService(db_session),
                'task_service': UserTaskService(db_session),
                'resource_service': ResourceService(db_session),
                'template_service': TemplateService(db_session),
                'zone_sequence_service': ZoneSequenceService(db_session),
                'scheduling_service': SchedulingService(db_session),
                'reporting_service': ReportingService(db_session),
                'monitoring_service': MonitoringService(db_session),
            }
            
            logger.info("‚úÖ Services initialized with request-scoped session")
            return services
            
        except Exception as e:
            logger.error(f"‚ùå Error initializing services: {e}")
            return {}
    


    @contextmanager
    def _database_session_scope(self):
        """
        Professional database transaction scope for entire page lifecycle
        Auto-commit on success, auto-rollback on exception
        """
        from backend.db.session import get_db_session, safe_commit, safe_rollback
        
        session = get_db_session()
        try:
            logger.debug("üéØ Starting page transaction scope")
            yield session
            # Commit on successful completion
            safe_commit(session, "Page transaction")
            logger.debug("‚úÖ Page transaction completed successfully")
            
        except Exception as e:
            # Rollback on any exception
            safe_rollback(session, f"Page transaction failed: {str(e)}")
            logger.error(f"‚ùå Transaction rolled back due to error: {e}")
            raise
            
        finally:
            # Always close session
            try:
                session.close()
                logger.debug("üîí Database session closed")
            except Exception as e:
                logger.error(f"‚ùå Error closing session: {e}")

    # ------------------- Page Routing -------------------

    def _route_to_page(self, db_session, services: Dict, user_id: int):
        """Route to current page with provided database session"""
        page = st.session_state.get('current_page', 'login')

        # Import all page modules
        from pages import login, project_setup, register
        from frontend.pages import (
            zone_sequence, templates_manager, 
            generate_schedule, progress_monitoring, 
            performance_dashboard, reports_analytics
        )

        # Map pages to their show functions with session
        page_mapping = {
            # Authentication Pages
            'login': lambda: login.show(),
            'register': lambda: register.show(),

            # Scheduling Section
            'project_setup': lambda: project_setup.show(db_session, services, user_id),
            'zone_sequence': lambda: zone_sequence.show(db_session, services, user_id),
            'templates_manager': lambda: templates_manager.show(db_session, services, user_id),
            'generate_schedule': lambda: generate_schedule.show(db_session, services, user_id),

            # Monitoring Section
            'progress_monitoring': lambda: progress_monitoring.show(db_session, services, user_id),
            'performance_dashboard': lambda: performance_dashboard.show(db_session, services, user_id),
            'reports_analytics': lambda: reports_analytics.show(db_session, services, user_id),
        }

        # Execute page function
        page_function = page_mapping.get(page, self._render_error_page)
        page_function()

    def _render_error_page(self):
        """Render error page for unknown routes"""
        st.error(f"‚ùå Page not found: {st.session_state.get('current_page')}")
        if st.button("üè† Return to Home"):
            st.session_state.current_page = "project_setup"
            st.rerun()

    # ------------------- Interface Rendering -------------------

    def _render_authenticated_interface(self):
        """
        FIXED: Professional authenticated interface with unified session management
        """
        try:
            # Single database transaction for entire page lifecycle
            with self._database_session_scope() as db_session:
                # Get user context from auth session manager
                auth_manager = st.session_state.auth_session_manager
                user_id = auth_manager.get_user_id()
                username = auth_manager.get_username()
                user_role = auth_manager.get_user_role()

                logger.info(f"üë§ Rendering interface for: {username} (ID: {user_id}, Role: {user_role})")

                # ‚úÖ FIXED: Initialize services with current session (not stored)
                services = self._initialize_services(db_session, user_id)

                # Widget management
                if 'widget_manager' not in st.session_state:
                    from backend.utils.widget_manager import widget_manager
                    st.session_state.widget_manager = widget_manager
                
                widget_manager = st.session_state.widget_manager
                current_page = st.session_state.get('current_page', 'unknown')
                
                # Clean up previous page keys
                previous_page = st.session_state.get('_previous_page')
                if previous_page and previous_page != current_page:
                    widget_manager.cleanup_page_keys(previous_page)
                    logger.info(f"üîÑ Cleaned up widget keys for previous page: {previous_page}")
                
                st.session_state._previous_page = current_page
                
                # Render interface components
                self._render_interface_components(db_session,  services, user_id, username, user_role)

        except Exception as e:
            logger.error(f"‚ùå Error in authenticated interface: {e}")
            self._show_error_page(e)

    def _render_interface_components(self, db_session, services: Dict, user_id: int, username: str, user_role: str):
        """Render all UI components with proper session context"""
        from frontend.components.navigation.sidebar import render_main_sidebar
        from frontend.components.navigation.header import render_page_header

        # -------------------
        # Render Sidebar with user context
        # -------------------
        render_main_sidebar(db_session, user_id, st.session_state.navigation_section)

        # -------------------
        # Render Main Content Header
        # -------------------
        current_page_name = st.session_state.get('current_page', 'Dashboard')
        render_page_header(
            title=current_page_name.replace('_', ' ').title(),
            description=f"User: {username} | Role: {user_role}",
            icon="üìä",
            show_breadcrumbs=True,
            breadcrumbs=[current_page_name.replace('_', ' ').title()]
        )

        # -------------------
        # Render Page Content with database session
        # -------------------
        self._route_to_page(db_session, services,user_id)

    def _render_login_interface(self):
        """Render login page (no database session needed)"""
        try:
            from pages.login import show as show_login_page
            show_login_page()
        except Exception as e:
            logger.error(f"‚ùå Login page error: {e}")
            self._show_error_page(e)


    def _render_register_interface(self):
        """Render register page for unauthenticated users"""
        try:
            from pages.register import show as show_register_page
            show_register_page()
        except Exception as e:
            logger.error(f"‚ùå Register page error: {e}")
            self._show_error_page(e)
    # ------------------- Error Handling -------------------

    def _show_error_page(self, error: Exception):
        """Professional error page with technical details"""
        st.error("""
        ‚ùå Application Error
        We encountered an unexpected error. Please:
        1. Refresh the page
        2. Check your internet connection
        3. Contact support if the issue persists
        """)
        with st.expander("Technical Details (For Support)"):
            st.code(f"Error Type: {type(error).__name__}\nError Message: {str(error)}")

        if st.button("üîÑ Restart Application"):
            # Clear critical session state and rerun
            keys_to_keep = ['auth_session_manager', 'widget_manager']
            for key in list(st.session_state.keys()):
                if key not in keys_to_keep:
                    del st.session_state[key]
            st.rerun()

    # ------------------- Utilities -------------------

    def _show_widget_debug_info(self):
        """Show widget debugging information (optional)"""
        if st.session_state.get('widget_debug'):
            with st.sidebar.expander("üîß Widget Debug Info", expanded=False):
                if 'widget_manager' in st.session_state:
                    stats = st.session_state.widget_manager.get_registry_stats()
                    st.write(f"**Total Widget Keys:** {stats['total_keys']}")
                    st.write(f"**Active Pages:** {stats['pages']}")
                    st.write(f"**Users in Registry:** {stats['users']}")
                
                if st.button("Clear Widget Registry"):
                    if 'widget_key_registry' in st.session_state:
                        st.session_state.widget_key_registry = set()
                    if 'widget_key_context' in st.session_state:
                        st.session_state.widget_key_context = {}
                    st.rerun()

    # ------------------- Main Run Method -------------------

    def run(self):
        """Run the professional application with enhanced session management"""
        try:

            
            # Route based on authentication
            if self._is_authenticated():
                self._render_authenticated_interface()
            else:
                

                current_page = st.session_state.get('current_page', 'login')
            
                if current_page == 'register':
                    self._render_register_interface()  # You need to create this
                else:
                    self._render_login_interface()

            # Optional debug information
            self._show_widget_debug_info()
                
        except Exception as e:
            logger.error(f"‚ùå Fatal application error: {e}")
            self._show_error_page(e)

# ------------------- Entry Point -------------------

if __name__ == "__main__":
    app = ConstructionApp()
    app.run()


    

# ====== End of app.py ======



# ====== Begin of frontend/pages/templates_manager.py ======

"""
PROFESSIONAL Template Manager - REFACTORED & MODULAR
"""
import streamlit as st
import logging
from sqlalchemy.orm import Session
from typing import Dict , Any
from frontend.components.tabs.resource_library import render_resource_templates_tab
from frontend.components.tabs.task_library import render_task_library_tab
from frontend.components.tabs.template_association import render_template_associations_tab

logger = logging.getLogger(__name__)

def show(db_session: Session, services: Dict[str, Any], user_id: int):
    """DEBUG: Template manager with detailed error tracking"""
    try:
        st.title("üèóÔ∏è Gestionnaire de Templates Unifi√©")
        
        # ‚úÖ DEBUG: Check session state before anything else
        st.write("üîç DEBUG: Session state keys:", list(st.session_state.keys()))
        
        # ‚úÖ DEBUG: Check if template_context exists
        if 'template_context' in st.session_state:
            st.write("‚úÖ DEBUG: template_context exists in session state")
        else:
            st.write("‚ùå DEBUG: template_context MISSING from session state")
            # Initialize it immediately
            st.session_state.template_context = {
                'resource_template': None,
                'task_template': None,
                'last_updated': None,
                'initialized': False
            }
            st.write("‚úÖ DEBUG: template_context created in session state")
        
        # Load professional CSS
        load_template_manager_css()
        
        if not services:
            st.error("‚ùå Erreur d'initialisation des services")
            return

        # Create THREE tabs for unified management
        tab1, tab2, tab3 = st.tabs([
            "üì¶ Biblioth√®que des Ressources",
            "üìö Biblioth√®que des T√¢ches", 
            "üîó Associations & Validation"
        ])

        # ----------------- Tab 1: Unified Resource Templates -----------------
        with tab1:
            st.write("üîç DEBUG: Before rendering resource tab")
            render_resource_templates_tab(services, user_id, db_session)
            st.write("üîç DEBUG: After rendering resource tab")
        
        # ... rest of the tabs ...

    except Exception as e:
        logger.error(f"‚ùå Error in templates manager page: {e}")
        st.error(f"‚ùå Erreur lors du chargement du gestionnaire de templates: {e}")
        import traceback
        st.code(traceback.format_exc())


def load_template_manager_css():
    """Load professional CSS styles for template manager with correct path"""
    try:
        css_path = "frontend/styling/template_manager.css"
        with open(css_path, "r", encoding="utf-8") as f:
            st.markdown(f"<style>{f.read()}</style>", unsafe_allow_html=True)
    except FileNotFoundError:
        # Fallback inline styles
        st.markdown("""
        <style>
            .template-manager-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                padding: 25px;
                border-radius: 15px;
                color: white;
                margin-bottom: 30px;
                box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            }
            .filter-section {
                background: #f8f9fa;
                padding: 20px;
                border-radius: 10px;
                margin-bottom: 20px;
                border-left: 4px solid #007bff;
            }
            .selected-row-actions {
                background: #e7f3ff;
                padding: 15px;
                border-radius: 8px;
                margin: 15px 0;
                border-left: 4px solid #007bff;
            }
            .submit-section {
                background: #d4edda;
                padding: 20px;
                border-radius: 10px;
                margin-top: 20px;
                border-left: 4px solid #28a745;
            }
            .template-card {
                background: white;
                padding: 20px;
                border-radius: 12px;
                box-shadow: 0 4px 15px rgba(0,0,0,0.08);
                margin-bottom: 20px;
                transition: transform 0.2s ease;
            }
            .template-card:hover {
                transform: translateY(-2px);
                box-shadow: 0 6px 20px rgba(0,0,0,0.12);
            }
            .stats-card {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 20px;
                border-radius: 12px;
                text-align: center;
                margin: 10px 0;
            }
        </style>
        """, unsafe_allow_html=True)
    except Exception as e:
        logger.error(f"‚ùå Service initialization error: {e}")
        st.error(f"‚ùå Erreur d'initialisation des services: {e}")
        return None

# ====== End of frontend/pages/templates_manager.py ======



# ====== Begin of frontend/components/tabs/task_library.py ======

"""
FIXED Task Library Tab - Using optimized task table with resource selection
"""
import streamlit as st
import logging
from typing import Dict, Any

logger = logging.getLogger(__name__)

def render_task_library_tab(services: Dict[str, Any], user_id: int, db_session=None):
    """Render task library tab with optimized table and resource selection"""
    
    st.markdown("""
    <div class="template-manager-header">
        <h1>üìö Biblioth√®que des T√¢ches</h1>
        <p>G√©rez vos templates de t√¢ches</p>
    </div>
    """, unsafe_allow_html=True)
    
    task_service = services['task_service']
    resource_service = services['resource_service']
    
    try:
        # Get tasks from service
        tasks = task_service.get_user_task_templates(user_id)
        
        # Get available resources from resource service
        available_workers = resource_service.get_user_workers(user_id)
        available_equipment = resource_service.get_user_equipment(user_id)
        
        available_resources = {
            'workers': available_workers,
            'equipment': available_equipment
        }
        
        # Display statistics
        col1, col2, col3, col4 = st.columns(4)
        with col1:
            st.metric("üìã T√¢ches", len(tasks))
        with col2:
            included_tasks = len([t for t in tasks if t.get('included', True)])
            st.metric("T√¢ches Incluses", included_tasks)
        with col3:
            disciplines = len(set(t.get('discipline', '') for t in tasks))
            st.metric("Disciplines", disciplines)
        with col4:
            quality_gates = len([t for t in tasks if t.get('quality_gate', False)])
            st.metric("Points Contr√¥le", quality_gates)
        
        # Use optimized task table WITH resource selection
        from frontend.components.data_tables.task_table import render_tasks_table
        template_service = services.get('template_service')
        render_tasks_table(tasks, task_service, user_id, available_resources, template_service)
        
        # Load Default Tasks Section
        st.markdown("---")
        st.markdown("## üì• T√¢ches par D√©faut")
        
        col1, col2 = st.columns([3, 1])
        with col1:
            st.write("Chargez les t√¢ches par d√©faut pour commencer rapidement")
        with col2:
            if st.button("üì• Charger T√¢ches D√©faut", key="load_default_tasks_main"):
                try:
                    loaded = task_service.load_default_tasks(user_id)
                    if loaded:
                        st.success("‚úÖ T√¢ches par d√©faut charg√©es!")
                        st.rerun()
                    else:
                        st.error("‚ùå Erreur lors du chargement")
                except Exception as e:
                    st.error(f"‚ùå Erreur: {e}")

    except Exception as e:
        st.error(f"‚ùå Erreur dans la biblioth√®que des t√¢ches: {e}")
        logger.error(f"Task library error: {e}")

# ====== End of frontend/components/tabs/task_library.py ======



# ====== Begin of frontend/components/tabs/resource_library.py ======

"""
Resource Library Tab - Simplified with context integration
"""

import streamlit as st
import logging
from typing import Dict, Any, List

from frontend.helpers.template_context import render_template_context_selector

logger = logging.getLogger(__name__)

def render_resource_templates_tab(services: Dict[str, Any], user_id: int, db_session=None):
    """Simplified resource templates tab"""
    
    st.markdown("""
    <div class="template-manager-header">
        <h1>üì¶ Mod√®les de Ressources</h1>
        <p>G√©rez vos mod√®les de ressources (ouvriers et √©quipements)</p>
    </div>
    """, unsafe_allow_html=True)
    
    # Render template selectors
    render_template_context_selector(services, user_id)
    
    resource_service = services['resource_service']
    task_service = services['task_service']
      
    try:
        # Get current context
        from frontend.helpers.template_context import template_context
        
        if not template_context.is_ready():
            st.info("üëÜ S√©lectionnez un mod√®le de ressources et un mod√®le de t√¢ches pour continuer")
            return
        
        current_resource = template_context.resource_template
        current_task = template_context.task_template
        
        # Display current context
        st.info(f"**Contexte actuel:** {current_resource['name']} + {current_task.get('name', 'Sans nom')}")
        
        # Template actions
        _render_template_actions(resource_service, user_id)
        
        # Get workers and equipment
        template_id = current_resource['id']
        workers = resource_service.get_user_workers(user_id, template_id)
        equipment = resource_service.get_user_equipment(user_id, template_id)
        
        # Display in tabs
        tab1, tab2 = st.tabs(["üë• Ouvriers", "üõ†Ô∏è √âquipements"])
        
        with tab1:
            from frontend.components.data_tables.worker_table import render_workers_table
            template_service = services.get('template_service')
            render_workers_table(workers, resource_service, user_id, template_id, current_resource['name'], template_service=template_service)
        
        with tab2:
            from frontend.components.data_tables.equipment_table import render_equipment_table
            render_equipment_table(equipment, resource_service, user_id, template_id, current_resource['name'])
            
    except Exception as e:
        st.error(f"‚ùå Erreur: {e}")
        logger.error(f"Resource library error: {e}")

def _render_template_actions(resource_service, user_id: int):
    """Essential template actions"""
    st.markdown("### üîß Actions Mod√®le")
    
    col1, col2, col3 = st.columns(3)
    
    with col1:
        if st.button("üíæ Sauvegarder", use_container_width=True):
            st.success("‚úÖ Mod√®le sauvegard√©")
    
    with col2:
        if st.button("üì• Charger D√©faut", use_container_width=True):
            resource_service.load_default_resources(user_id)
            st.success("‚úÖ Ressources charg√©es")
            st.rerun()
    
    with col3:
        if st.button("üîÑ Actualiser", use_container_width=True):
            st.rerun()
    
    st.markdown("---")


# ====== End of frontend/components/tabs/resource_library.py ======



# ====== Begin of frontend/components/tabs/template_association.py ======

"""
PROFESSIONAL Template Association Tab
Associates resource templates with task templates for scheduling engine
"""
import streamlit as st
import logging
from typing import Dict, Any, List, Optional
from backend.utils.widget_manager import widget_manager

logger = logging.getLogger(__name__)


def render_template_associations_tab(services: Dict[str, Any], user_id: int, db_session=None):
    """
    Render template associations tab for linking resource templates with task templates
    """
    st.markdown("""
    <div class="template-manager-header">
        <h1>üîó Associations Templates</h1>
        <p>Associez les mod√®les de ressources avec les mod√®les de t√¢ches</p>
    </div>
    """, unsafe_allow_html=True)
    
    template_service = services['template_service']
    resource_service = services['resource_service']
    task_service = services['task_service']
    
    # Template-level actions
    _render_template_actions(resource_service, user_id)
    
    try:
        # Get available templates
        resource_templates = template_service.get_available_resource_templates(user_id)
        task_templates = task_service.get_user_task_templates(user_id)
        
        if not resource_templates:
            st.warning("üì≠ Aucun mod√®le de ressource disponible. Cr√©ez d'abord des mod√®les de ressources.")
            return
        
        if not task_templates:
            st.warning("üì≠ Aucun mod√®le de t√¢che disponible. Cr√©ez d'abord des mod√®les de t√¢ches.")
            return
        
        # Display statistics
        _render_association_statistics(resource_templates, task_templates, template_service, user_id)
        
        # Main association interface
        _render_association_interface(resource_templates, task_templates, template_service, user_id)
        
        # Validation section
        _render_validation_section(resource_templates, task_templates, template_service, resource_service)
        
    except Exception as e:
        st.error(f"‚ùå Erreur dans les associations de templates: {e}")
        logger.error(f"Template associations error: {e}")
        
def _render_association_statistics(resource_templates: List[Dict], task_templates: List[Dict], template_service, user_id: int):
    """Render association statistics"""
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric("üì¶ Mod√®les Ressources", len(resource_templates))
    
    with col2:
        st.metric("üìö Mod√®les T√¢ches", len(task_templates))
    
    with col3:
        # Count associations
        total_associations = 0
        for rt in resource_templates:
            associations = template_service.get_template_associations(rt.get('id'))
            total_associations += len(associations)
        st.metric("üîó Associations", total_associations)
    
    with col4:
        # Coverage percentage
        coverage = (total_associations / max(len(task_templates), 1)) * 100
        st.metric("üìä Couverture", f"{coverage:.1f}%")

def _render_association_interface(resource_templates: List[Dict], task_templates: List[Dict], template_service, user_id: int):
    """Render main association interface"""
    st.markdown("### üîó Interface d'Association")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown("#### üì¶ Mod√®les de Ressources")
        selected_resource_template = _render_resource_template_selection(resource_templates)
    
    with col2:
        st.markdown("#### üìö T√¢ches Disponibles")
        if selected_resource_template:
            _render_task_assignment_interface(selected_resource_template, task_templates, template_service, user_id)
        else:
            st.info("üëà S√©lectionnez un mod√®le de ressource pour voir les t√¢ches disponibles")

def _render_resource_template_selection(resource_templates: List[Dict]) -> Optional[Dict]:
    """Render resource template selection"""
    template_options = {f"{rt.get('name', 'Sans nom')} (ID: {rt.get('id')})": rt for rt in resource_templates}
    
    selected_label = st.selectbox(
        "S√©lectionnez un mod√®le de ressource:",
        options=[''] + list(template_options.keys()),
        key=widget_manager.generate_key("resource_template_selector", "template_association")
    )
    
    if selected_label and selected_label in template_options:
        selected_template = template_options[selected_label]
        
        # Display template details
        with st.expander("üìã D√©tails du Mod√®le S√©lectionn√©", expanded=True):
            col1, col2 = st.columns(2)
            with col1:
                st.write(f"**Nom:** {selected_template.get('name')}")
                st.write(f"**Cat√©gorie:** {selected_template.get('category', 'Non sp√©cifi√©e')}")
                st.write(f"**Description:** {selected_template.get('description', 'Aucune')}")
            
            with col2:
                st.write(f"**Version:** {selected_template.get('version', 1)}")
                st.write(f"**Statut:** {'‚úÖ Actif' if selected_template.get('is_active', True) else '‚ùå Inactif'}")
                st.write(f"**Partag√©:** {'‚úÖ Oui' if selected_template.get('is_shared', False) else '‚ùå Non'}")
        
        return selected_template
    
    return None

def _render_task_assignment_interface(selected_resource_template: Dict, task_templates: List[Dict], template_service, user_id: int):
    """Render task assignment interface for selected resource template"""
    resource_template_id = selected_resource_template.get('id')
    
    # Get current associations
    current_associations = template_service.get_template_associations(resource_template_id)
    current_task_ids = [assoc.get('task_template_id') for assoc in current_associations]
    
    # Group tasks by discipline for better organization
    tasks_by_discipline = {}
    for task in task_templates:
        discipline = task.get('discipline', 'Non class√©')
        if discipline not in tasks_by_discipline:
            tasks_by_discipline[discipline] = []
        tasks_by_discipline[discipline] = task
    
    st.markdown("#### üéØ T√¢ches Associ√©es")
    
    # Display current associations
    if current_task_ids:
        st.success(f"‚úÖ {len(current_task_ids)} t√¢che(s) associ√©e(s) √† ce mod√®le")
        
        for task_id in current_task_ids:
            task = next((t for t in task_templates if t.get('base_task_id') == task_id), None)
            if task:
                col1, col2, col3 = st.columns([3, 1, 1])
                with col1:
                    st.write(f"**{task.get('name')}**")
                    st.caption(f"Discipline: {task.get('discipline')} | Type: {task.get('resource_type')}")
                with col2:
                    st.write(f"Dur√©e: {task.get('base_duration', 'N/A')}j")
                with col3:
                    if st.button("üóëÔ∏è", key=f"remove_{task_id}_{resource_template_id}"):
                        template_service.remove_task_association(resource_template_id, task_id)
                        st.success(f"‚úÖ Association supprim√©e: {task.get('name')}")
                        st.rerun()
    else:
        st.warning("‚ö†Ô∏è Aucune t√¢che associ√©e √† ce mod√®le de ressource")
    
    st.markdown("---")
    st.markdown("#### ‚ûï Ajouter des Associations")
    
    # Multi-select for adding associations
    available_tasks = [t for t in task_templates if t.get('base_task_id') not in current_task_ids]
    
    if available_tasks:
        task_options = {
            f"{t.get('name')} ({t.get('base_task_id')}) - {t.get('discipline')}": t.get('base_task_id') 
            for t in available_tasks
        }
        
        selected_tasks = st.multiselect(
            "S√©lectionnez les t√¢ches √† associer:",
            options=list(task_options.keys()),
            key=widget_manager.generate_key("task_association_multiselect", "template_association")
        )
        
        if selected_tasks and st.button("üîó Associer les T√¢ches S√©lectionn√©es", use_container_width=True):
            selected_task_ids = [task_options[task] for task in selected_tasks]
            success_count = 0
            
            for task_id in selected_task_ids:
                if template_service.associate_task_template(resource_template_id, task_id):
                    success_count += 1
            
            if success_count > 0:
                st.success(f"‚úÖ {success_count} t√¢che(s) associ√©e(s) avec succ√®s!")
                st.rerun()
            else:
                st.error("‚ùå Erreur lors de l'association des t√¢ches")
    else:
        st.info("üéâ Toutes les t√¢ches disponibles sont d√©j√† associ√©es √† ce mod√®le!")

def _render_validation_section(resource_templates: List[Dict], task_templates: List[Dict], template_service, resource_service):
    """Render validation section for template associations"""
    st.markdown("---")
    st.markdown("### ‚úÖ Validation des Associations")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown("#### üîç V√©rification des D√©pendances")
        
        selected_validation_template = st.selectbox(
            "S√©lectionnez un mod√®le √† valider:",
            options=[''] + [f"{rt.get('name')} (ID: {rt.get('id')})" for rt in resource_templates],
            key=widget_manager.generate_key("validation_template_selector", "template_association")
        )
        
        if selected_validation_template:
            template_id = int(selected_validation_template.split("ID: ")[1].split(")")[0])
            associations = template_service.get_template_associations(template_id)
            
            if associations:
                st.success(f"‚úÖ {len(associations)} association(s) trouv√©e(s)")
                
                # Validate each association
                validation_results = []
                for assoc in associations:
                    task_id = assoc.get('task_template_id')
                    task = next((t for t in task_templates if t.get('base_task_id') == task_id), None)
                    
                    if task:
                        # Check if resource template has the required resources
                        validation = _validate_task_dependencies(task, template_id, resource_service)
                        validation_results.append({
                            'task': task,
                            'validation': validation
                        })
                
                # Display validation results
                for result in validation_results:
                    task = result['task']
                    validation = result['validation']
                    
                    with st.expander(f"üîç {task.get('name')}", expanded=False):
                        if validation['is_valid']:
                            st.success("‚úÖ T√¢che compatible avec le mod√®le de ressources")
                        else:
                            st.error("‚ùå Incompatibilit√©s d√©tect√©es")
                            
                            if validation['missing_workers']:
                                st.write("**Ouvriers manquants:**")
                                for worker in validation['missing_workers']:
                                    st.write(f" - {worker}")
                            
                            if validation['missing_equipment']:
                                st.write("**√âquipements manquants:**")
                                for equipment in validation['missing_equipment']:
                                    st.write(f" - {equipment}")
                            
                            if validation['warnings']:
                                st.write("**Avertissements:**")
                                for warning in validation['warnings']:
                                    st.warning(warning)
            else:
                st.warning("‚ö†Ô∏è Aucune association √† valider pour ce mod√®le")
    
    with col2:
        st.markdown("#### üìä Rapport de Couverture")
        
        # Generate coverage report
        coverage_data = []
        for rt in resource_templates:
            associations = template_service.get_template_associations(rt.get('id'))
            coverage_percentage = (len(associations) / len(task_templates)) * 100 if task_templates else 0
            
            coverage_data.append({
                'Mod√®le': rt.get('name'),
                'Associations': len(associations),
                'Couverture': f"{coverage_percentage:.1f}%",
                'Statut': '‚úÖ Bonne' if coverage_percentage > 50 else '‚ö†Ô∏è Faible' if coverage_percentage > 0 else '‚ùå Aucune'
            })
        
        if coverage_data:
            import pandas as pd
            df = pd.DataFrame(coverage_data)
            st.dataframe(df, use_container_width=True, hide_index=True)
        else:
            st.info("üìä Aucune donn√©e de couverture disponible")

def _validate_task_dependencies(task: Dict, resource_template_id: int, template_service) -> Dict[str, Any]:
    """Validate task dependencies against resource template using template service"""
    try:
        return template_service.validate_task_template_dependencies(task, resource_template_id)
    except Exception as e:
        logger.error(f"Error validating task dependencies: {e}")
        return {
            'is_valid': False,
            'missing_workers': [],
            'missing_equipment': [],
            'warnings': [f"Erreur de validation: {str(e)}"]
        }
    

def _render_template_actions(resource_service, user_id: int):
    """Render template-level action buttons for association tab"""
    st.markdown("### üîß Actions au Niveau Mod√®le")
    
    # Template action buttons
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        if st.button("üíæ Sauvegarder Tous", use_container_width=True,
                    key=widget_manager.generate_key("save_all_templates_btn", "template_association")):
            _save_all_templates(resource_service, user_id)
    
    with col2:
        if st.button("‚ûï Nouveau Mod√®le", use_container_width=True,
                    key=widget_manager.generate_key("new_template_btn", "template_association")):
            _create_new_template(resource_service, user_id)
    
    with col3:
        if st.button("üì• Charger D√©faut", use_container_width=True,
                    key=widget_manager.generate_key("load_default_btn", "template_association")):
            _load_default_resources(resource_service, user_id)
    
    with col4:
        if st.button("üîÑ Actualiser", use_container_width=True,
                    key=widget_manager.generate_key("refresh_btn", "template_association")):
            st.rerun()
    
    st.markdown("---")

def _save_all_templates(resource_service, user_id: int):
    """Save all resource templates"""
    try:
        templates = resource_service.get_user_resource_templates(user_id)
        total_workers = 0
        total_equipment = 0
        
        for template in templates:
            workers = resource_service.get_user_workers(user_id, template['id'])
            equipment = resource_service.get_user_equipment(user_id, template['id'])
            total_workers += len(workers)
            total_equipment += len(equipment)
        
        st.success(f"‚úÖ Tous les mod√®les sauvegard√©s!")
        st.info(f"üìä Total: {len(templates)} mod√®les, {total_workers} ouvriers, {total_equipment} √©quipements")
        
    except Exception as e:
        st.error(f"‚ùå Erreur lors de la sauvegarde: {e}")
        logger.error(f"Error saving all templates: {e}")

def _create_new_template(resource_service, user_id: int):
    """Create a new resource template"""
    try:
        # Generate unique template name
        template_count = len(resource_service.get_user_resource_templates(user_id))
        new_template_name = f"Nouveau Mod√®le {template_count + 1}"
        
        template_data = {
            'name': new_template_name,
            'description': 'Nouveau mod√®le de ressources cr√©√© automatiquement',
            'category': 'Custom',
            'user_id': user_id
        }
        
        new_template = resource_service.create_resource_template(user_id, template_data)
        
        if new_template:
            st.success(f"‚úÖ Nouveau mod√®le cr√©√©: {new_template_name}")
            st.rerun()
        else:
            st.error("‚ùå Erreur lors de la cr√©ation du mod√®le")
            
    except Exception as e:
        st.error(f"‚ùå Erreur lors de la cr√©ation du mod√®le: {e}")
        logger.error(f"Error creating template: {e}")

def _load_default_resources(resource_service, user_id: int):
    """Load default resources"""
    try:
        with st.spinner("üì• Chargement des ressources par d√©faut..."):
            loaded_resources = resource_service.load_default_resources(user_id)
            
            if loaded_resources:
                st.success(f"‚úÖ {len(loaded_resources)} ressources par d√©faut charg√©es avec succ√®s!")
                st.rerun()
            else:
                st.error("‚ùå Erreur lors du chargement des ressources par d√©faut")
                
    except Exception as e:
        st.error(f"‚ùå Erreur lors du chargement des ressources: {e}")
        logger.error(f"Error loading default resources: {e}")

# ====== End of frontend/components/tabs/template_association.py ======



# ====== Begin of backend/services/user_task_service.py ======

"""
PROFESSIONAL User Task Service - UPDATED with duration calculation methods
"""
import logging
from typing import List, Dict, Optional, Any
from datetime import datetime
from sqlalchemy.orm import Session
logger = logging.getLogger(__name__)

class UserTaskService:
    """
    Professional service for user task operations with duration methods
    """
    
    def __init__(self, db_session: Session):
        self.db_session = db_session
        self.logger = logging.getLogger(__name__)
        self._initialize_repositories()
    
    def _initialize_repositories(self):
        """Initialize repositories"""
        try:
            from backend.db.repositories.task_repo import TaskRepository
            self.task_repo = TaskRepository(self.db_session)
            self.logger.info("‚úÖ TaskRepository initialized successfully")
        except Exception as e:
            self.logger.error(f"‚ùå TaskRepository initialization failed: {e}")
            raise
    
    def get_user_task_templates(self, user_id: int, project_id: Optional[int] = None) -> List[Dict]:
        """
        Get user task templates for frontend display with duration methods
        """
        try:  
            db_templates = self.task_repo.get_user_task_templates(user_id, project_id)
            domain_tasks = [self._db_to_domain_task(db_template) for db_template in db_templates]
            self.logger.info(f"‚úÖ Retrieved {len(domain_tasks)} task templates for user {user_id}")
            return domain_tasks
        except Exception as e:
            self.logger.error(f"‚ùå Error retrieving task templates: {e}")
            return []
    
    def get_task_template_groups(self, user_id: int) -> List[Dict]:
        """Get task templates grouped by template_name"""
        try:
            tasks = self.get_user_task_templates(user_id)
            template_groups = {}
        
            for task in tasks:
                template_name = task.get('template_name', 'Default Template')
                if template_name not in template_groups:
                    template_groups[template_name] = {
                    'template_name': template_name,
                    'tasks': [],
                    'task_count': 0,
                    'disciplines': set(),
                    'created_at': task.get('created_at')
                    }
            
                template_groups[template_name]['tasks'].append(task)
                template_groups[template_name]['task_count'] += 1
                template_groups[template_name]['disciplines'].add(task.get('discipline', 'Non sp√©cifi√©'))
        
            return list(template_groups.values())
        
        except Exception as e:
            self.logger.error(f"Error getting task template groups: {e}")
            return []
    def load_default_tasks(self,user_id: int) -> List[Dict]:
        """
        Load default tasks as user templates with duration methods
        """
        try:
            from backend.defaults.TASKS import BASE_TASKS
            
            created_tasks = [] 
            for discipline, task_list in BASE_TASKS.items(): 
                for base_task in task_list:
                    template_data = {
                    'user_id': user_id,
                    'base_task_id': getattr(base_task, 'id', 'None'),
                    'name': getattr(base_task, 'name', 'Un named'),
                    'discipline': getattr(base_task, 'discipline', 'General'),
                    'sub_discipline': getattr(base_task, 'sub_discipline', 'General'),
                    'resource_type': getattr(base_task, 'resource_type', 'worker'),
                    'task_type': getattr(base_task, 'task_type', 'worker'),
                    'base_duration': getattr(base_task, 'base_duration', 1),
                    'unit_duration': getattr(base_task, 'unit_duration', 1),
                    'duration_calculation_method': getattr(base_task, 'duration_calculation_method', 'fixed_duration'),
                    'min_crews_needed': getattr(base_task, 'min_crews_needed', 1),
                    'min_equipment_needed': getattr(base_task, 'min_equipment_needed', {}),
                    'predecessors': getattr(base_task, 'predecessors', []),
                    'repeat_on_floor': getattr(base_task, 'repeat_on_floor', True),
                    'delay': getattr(base_task, 'delay', 0),
                    'weather_sensitive': getattr(base_task, 'weather_sensitive', False),
                    'quality_gate': getattr(base_task, 'quality_gate', False),
                    'included': getattr(base_task, 'included', True)
                        }
                
                    db_template = self.task_repo.create_user_task_template(template_data)
                    if db_template:
                        domain_task = self._db_to_domain_task(db_template)
                        created_tasks.append(domain_task)
                
            self.logger.info(f"‚úÖ Loaded {len(created_tasks)} default tasks")
            return created_tasks
            
        except Exception as e:
            self.logger.error(f"‚ùå Error loading default tasks: {e}")
            return []
    
    def update_custom_task(self, user_id: int, task_id: int, updates: Dict) -> Optional[Dict]:
        """Update custom task template with duration method support"""
        try:
            # Validate duration method configuration
            validation_result = self._validate_duration_configuration(updates)
            if not validation_result['is_valid']:
                self.logger.error(f"‚ùå Invalid duration configuration: {validation_result['errors']}")
                return None
            
            db_template = self.task_repo.update_user_task_template(user_id, task_id, updates)
            
            if db_template:
                self.logger.info(f"‚úÖ Updated task {task_id} with duration method: {updates.get('duration_calculation_method')}")
                return self._db_to_domain_task(db_template)
            return None
            
        except Exception as e:
            self.logger.error(f"‚ùå Error updating custom task: {e}")
            return None
    
    def _validate_duration_configuration(self, updates: Dict) -> Dict[str, Any]:
        """Validate duration calculation method configuration"""
        errors = []
        
        method = updates.get('duration_calculation_method', 'fixed_duration')
        
        if method == 'fixed_duration':
            if 'base_duration' not in updates or updates['base_duration'] <= 0:
                errors.append("La dur√©e fixe doit √™tre sup√©rieure √† 0")
                
        elif method == 'quantity_based':
            if 'unit_duration' not in updates or updates['unit_duration'] <= 0:
                errors.append("La dur√©e unitaire doit √™tre sup√©rieure √† 0")
        
        # resource_calculation doesn't need specific validation
        
        return {
            'is_valid': len(errors) == 0,
            'errors': errors
        }
    
    def _db_to_domain_task(self, db_template) -> Dict:
        """Convert DB model to domain task dictionary with duration methods"""
        return {
            'base_task_id': db_template.base_task_id,
            'name': db_template.name,
            'discipline': db_template.discipline,
            'sub_discipline': db_template.sub_discipline,
            'resource_type': db_template.resource_type,
            'task_type': db_template.task_type,
            'base_duration': db_template.base_duration,
            'unit_duration': getattr(db_template, 'unit_duration', 0),
            'duration_calculation_method': getattr(db_template, 'duration_calculation_method', 'fixed_duration'),
            'min_crews_needed': db_template.min_crews_needed,
            'min_equipment_needed': db_template.min_equipment_needed or {},
            'predecessors': db_template.predecessors or [],
            'repeat_on_floor': db_template.repeat_on_floor,
            'delay': db_template.delay,
            'weather_sensitive': db_template.weather_sensitive,
            'quality_gate': db_template.quality_gate,
            'included': db_template.included,
            'created_at': db_template.created_at.isoformat() if db_template.created_at else None
        }
    
    # Keep existing methods for compatibility
    def import_tasks_from_json(self, uploaded_file) -> bool:
        """Import tasks from JSON file"""
        try:
            import json
            tasks_data = json.load(uploaded_file)
            user_id = 1  # From session
            
            success_count = 0
            for task_data in tasks_data:
                task_data['user_id'] = user_id
                # Ensure duration method is set
                if 'duration_calculation_method' not in task_data:
                    task_data['duration_calculation_method'] = 'fixed_duration'
                if self.task_repo.create_user_task_template(task_data):
                    success_count += 1
            
            self.logger.info(f"‚úÖ Imported {success_count} tasks from JSON")
            return success_count > 0
            
        except Exception as e:
            self.logger.error(f"‚ùå Error importing tasks from JSON: {e}")
            return False
    
    def export_tasks_to_json(self) -> str:
        """Export tasks to JSON format"""
        try:
            user_id = 1  # From session
            db_templates = self.task_repo.get_user_task_templates(user_id)
            
            tasks_data = []
            for db_template in db_templates:
                task_dict = {
                    'id': db_template.base_task_id,
                    'name': db_template.name,
                    'discipline': db_template.discipline,
                    'sub_discipline': db_template.sub_discipline,
                    'resource_type': db_template.resource_type,
                    'task_type': db_template.task_type,
                    'base_duration': db_template.base_duration,
                    'unit_duration': getattr(db_template, 'unit_duration', 0),
                    'duration_calculation_method': getattr(db_template, 'duration_calculation_method', 'fixed_duration'),
                    'min_crews_needed': db_template.min_crews_needed,
                    'min_equipment_needed': db_template.min_equipment_needed,
                    'predecessors': db_template.predecessors,
                    'repeat_on_floor': db_template.repeat_on_floor,
                    'delay': db_template.delay,
                    'weather_sensitive': db_template.weather_sensitive,
                    'quality_gate': db_template.quality_gate,
                    'included': db_template.included
                }
                tasks_data.append(task_dict)
            
            import json
            return json.dumps(tasks_data, indent=2, ensure_ascii=False)
        except Exception as e:
            self.logger.error(f"‚ùå Error exporting tasks to JSON: {e}")
            return "[]"
        



        # Add this method to UserTaskService class
    def create_custom_task(self, user_id: int, task_data: Dict) -> Optional[Dict]:
        """Create a new custom task template"""
        try:
            # Ensure required fields
            task_data['user_id'] = user_id
            if 'duration_calculation_method' not in task_data:
                task_data['duration_calculation_method'] = 'fixed_duration'
        
            db_template = self.task_repo.create_user_task_template(task_data)
        
            if db_template:
                self.logger.info(f"‚úÖ Created custom task: {task_data.get('base_task_id')}")
                return self._db_to_domain_task(db_template)
            return None
        
        except Exception as e:
            self.logger.error(f"‚ùå Error creating custom task: {e}")
            return None
        
    def delete_custom_task(self, user_id: int, task_id: int) -> bool:
        """Delete custom task template"""
        try:
            return self.task_repo.delete_user_task_template(user_id, task_id)
        except Exception as e:
            self.logger.error(f"‚ùå Error deleting custom task: {e}")
            return False

# ====== End of backend/services/user_task_service.py ======



# ====== Begin of backend/services/template_service.py ======

"""
PROFESSIONAL Template Service - Template Association Management
Handles associations between resource templates and task templates
"""
import logging
from typing import List, Dict, Optional, Any
from sqlalchemy.orm import Session
import datetime

logger = logging.getLogger(__name__)

class TemplateService:
    """
    Professional service for template association operations
    """
    
    def __init__(self, db_session: Session):
        self.db_session = db_session
        self.logger = logging.getLogger(__name__)
        
    def validate_template_compatibility(self, resource_template: Dict, task_template: Dict) -> Dict[str, Any]:
        """Essential template compatibility validation"""
        try:
            issues = []
            warnings = []
            
            # 1. Check resource requirements
            resource_check = self._check_resource_requirements(task_template, resource_template)
            if not resource_check['met']:
                issues.extend(resource_check.get('issues', []))
            
            # 2. Check equipment requirements
            equipment_check = self._check_equipment_requirements(task_template, resource_template)
            if not equipment_check['met']:
                issues.extend(equipment_check.get('issues', []))
            
            return {
                'compatible': len(issues) == 0,
                'issues': issues,
                'warnings': warnings,
                'resource_check': resource_check,
                'equipment_check': equipment_check
            }
            
        except Exception as e:
            logger.error(f"Validation error: {e}")
            return {
                'compatible': False,
                'issues': [f"Erreur validation: {str(e)}"],
                'warnings': []
            }

    def _check_resource_requirements(self, task_template: Dict, resource_template: Dict) -> Dict[str, Any]:
        """Check if resource template has required workers"""
        from backend.db.repositories.resource_repo import ResourceRepository
        resource_repo = ResourceRepository(self.db_session)
        
        required_type = task_template.get('resource_type')
        if not required_type:
            return {'met': True, 'message': 'Aucun type sp√©cifique requis'}
        
        workers = resource_repo.get_workers_by_template(resource_template['id'])
        worker_types = [w.specialty for w in workers]
        
        has_match = required_type in worker_types
        result = {
            'met': has_match,
            'required': required_type,
            'available': worker_types
        }
        
        if not has_match:
            result['issues'] = [f"Type ouvrier manquant: {required_type}"]
        
        return result

    def _check_equipment_requirements(self, task_template: Dict, resource_template: Dict) -> Dict[str, Any]:
        """Check if resource template has required equipment"""
        from backend.db.repositories.resource_repo import ResourceRepository
        resource_repo = ResourceRepository(self.db_session)
        
        required_equipment = task_template.get('min_equipment_needed', {})
        if not required_equipment:
            return {'met': True, 'message': 'Aucun √©quipement sp√©cifique requis'}
        
        equipment = resource_repo.get_equipment_by_template(resource_template['id'])
        equipment_names = [e.name for e in equipment]
        
        missing = [name for name in required_equipment.keys() if name not in equipment_names]
        result = {
            'met': len(missing) == 0,
            'required': list(required_equipment.keys()),
            'available': equipment_names,
            'missing': missing
        }
        
        if missing:
            result['issues'] = [f"√âquipements manquants: {', '.join(missing)}"]
        
        return result
    def get_available_resource_templates(self, user_id: int) -> List[Dict]:
        """Get available resource templates for user"""
        try:
            from backend.db.repositories.resource_repo import ResourceRepository
            resource_repo = ResourceRepository(self.db_session)
            
            db_templates = resource_repo.get_user_resource_templates(user_id)
            
            templates = []
            for template in db_templates:
                template_dict = {
                    'id': template.id,
                    'name': template.name,
                    'description': template.description,
                    'category': template.category,
                    'version': template.version,
                    'is_default': template.is_default,
                    'is_shared': template.is_shared,
                    'is_active': template.is_active,
                    'created_at': template.created_at.isoformat() if template.created_at else None
                }
                
                # Get resource counts
                counts = resource_repo.count_template_resources(template.id)
                template_dict['worker_count'] = counts['workers']
                template_dict['equipment_count'] = counts['equipment']
                template_dict['total_resources'] = counts['total']
                
                templates.append(template_dict)
            
            self.logger.info(f"‚úÖ Retrieved {len(templates)} resource templates for user {user_id}")
            return templates
            
        except Exception as e:
            self.logger.error(f"‚ùå Error getting resource templates: {e}")
            return []
    
    def get_template_associations(self, resource_template_id: int) -> List[Dict]:
        """Get task template associations for a resource template"""
        try:
            # In a real implementation, this would query an association table
            # For now, we'll return an empty list as placeholder
            associations = []
            
            self.logger.info(f"‚úÖ Retrieved {len(associations)} associations for template {resource_template_id}")
            return associations
            
        except Exception as e:
            self.logger.error(f"‚ùå Error getting template associations: {e}")
            return []
    
    def associate_task_template(self, resource_template_id: int, task_template_id: str) -> bool:
        """Associate a task template with a resource template"""
        try:
            # In a real implementation, this would insert into an association table
            # For now, we'll log and return True as placeholder
            self.logger.info(f"‚úÖ Associated resource template {resource_template_id} with task {task_template_id}")
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå Error associating templates: {e}")
            return False
    
    def remove_task_association(self, resource_template_id: int, task_template_id: str) -> bool:
        """Remove association between resource and task templates"""
        try:
            # In a real implementation, this would delete from an association table
            # For now, we'll log and return True as placeholder
            self.logger.info(f"‚úÖ Removed association between resource template {resource_template_id} and task {task_template_id}")
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå Error removing association: {e}")
            return False
    
    def validate_task_template_dependencies(self, task_template: Dict, resource_template_id: int) -> Dict[str, Any]:
        """Validate if a task template's resource dependencies are satisfied by a resource template"""
        try:
            from backend.db.repositories.resource_repo import ResourceRepository
            resource_repo = ResourceRepository(self.db_session)
            
            missing_workers = []
            missing_equipment = []
            warnings = []
            
            # Get resources from the template
            workers = resource_repo.get_workers_by_template(resource_template_id)
            equipment = resource_repo.get_equipment_by_template(resource_template_id)
            
            # Check worker requirements
            required_worker_type = task_template.get('resource_type')
            if required_worker_type:
                worker_available = any(
                    w.specialty == required_worker_type or w.name == required_worker_type 
                    for w in workers
                )
                if not worker_available:
                    missing_workers.append(required_worker_type)
            
            # Check equipment requirements
            required_equipment = task_template.get('min_equipment_needed', {})
            for equip_name, quantity in required_equipment.items():
                equipment_available = any(
                    e.name == equip_name or e.code == equip_name 
                    for e in equipment
                )
                if not equipment_available:
                    missing_equipment.append(f"{equip_name} (x{quantity})")
            
            # Check if task has any resource dependencies at all
            if not required_worker_type and not required_equipment:
                warnings.append("Cette t√¢che n'a pas de d√©pendances de ressources sp√©cifi√©es")
            
            return {
                'is_valid': len(missing_workers) == 0 and len(missing_equipment) == 0,
                'missing_workers': missing_workers,
                'missing_equipment': missing_equipment,
                'warnings': warnings,
                'resource_template_id': resource_template_id,
                'task_template_id': task_template.get('base_task_id')
            }
            
        except Exception as e:
            self.logger.error(f"‚ùå Error validating task dependencies: {e}")
            return {
                'is_valid': False,
                'missing_workers': [],
                'missing_equipment': [],
                'warnings': [f"Erreur de validation: {str(e)}"],
                'resource_template_id': resource_template_id,
                'task_template_id': task_template.get('base_task_id')
            }
    
    def create_template_association_table(self) -> bool:
        """Create the template association table if it doesn't exist"""
        try:
            # This would typically create an association table in the database
            # For now, we'll just log and return True
            self.logger.info("‚úÖ Template association table ready")
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå Error creating association table: {e}")
            return False
        

    def export_resource_templates(self, user_id: int) -> str:
        """
        Export resource templates to JSON format for download
        Includes templates, workers, and equipment
        """
        try:
            from backend.services.resource_service import ResourceService
            resource_service = ResourceService(self.db_session)
        
            # Get all resource data
            resource_templates = resource_service.get_user_resource_templates(user_id)
        
            export_data = {
                'export_type': 'resource_templates',
                'export_version': '1.0',
                'export_timestamp': datetime.now().isoformat(),
                'user_id': user_id,
                'resource_templates': resource_templates,
                'total_templates': len(resource_templates)
            }
        
            # Add workers and equipment for each template
            for template in resource_templates:
                template_id = template['id']
                workers = resource_service.get_workers_by_template(template_id)
                equipment = resource_service.get_equipment_by_template(template_id)
            
                template['workers'] = workers
                template['equipment'] = equipment
                template['worker_count'] = len(workers)
                template['equipment_count'] = len(equipment)
        
            import json
            return json.dumps(export_data, indent=2, ensure_ascii=False, default=str)
        
        except Exception as e:
            self.logger.error(f"‚ùå Error exporting resource templates: {e}")
            return json.dumps({'error': str(e)})

    def import_resource_templates(self, user_id: int, uploaded_file) -> bool:
        """
        Import resource templates from JSON file
        """
        try:
            import json
            from backend.services.resource_service import ResourceService
            resource_service = ResourceService(self.db_session)
        
            # Parse uploaded file
            file_content = uploaded_file.getvalue().decode('utf-8')
            import_data = json.loads(file_content)
        
            # Validate export format
            if import_data.get('export_type') != 'resource_templates':
                raise ValueError("Invalid file format: Not a resource templates export")
        
            resource_templates = import_data.get('resource_templates', [])
            imported_count = 0
        
            for template_data in resource_templates:
                try:
                    # Create or update resource template
                    existing_templates = resource_service.get_user_resource_templates(user_id)
                    existing_template = next(
                        (t for t in existing_templates if t['name'] == template_data['name']), 
                         None
                    )
                
                    if existing_template:
                        # Update existing template
                        updates = {
                            'description': template_data.get('description', ''),
                            'category': template_data.get('category', 'Custom'),
                            'version': template_data.get('version', 1) + 1
                        }
                        success = resource_service.update_resource_template(existing_template['id'], updates)
                        template_id = existing_template['id']
                    else:
                        # Create new template
                        new_template_data = {
                        'name': template_data['name'],
                        'description': template_data.get('description', ''),
                        'category': template_data.get('category', 'Custom'),
                        'user_id': user_id,
                        'is_default': False,
                        'is_shared': template_data.get('is_shared', False)
                        }
                        new_template = resource_service.create_resource_template(user_id, new_template_data)
                        template_id = new_template['id'] if new_template else None
                
                    if template_id:
                        # Import workers
                        workers = template_data.get('workers', [])
                        for worker_data in workers:
                            worker_data['user_id'] = user_id
                            worker_data['template_id'] = template_id
                            resource_service.create_worker(user_id, worker_data)
                      
                        # Import equipment
                        equipment_list = template_data.get('equipment', [])
                        for equipment_data in equipment_list:
                            equipment_data['user_id'] = user_id
                            equipment_data['template_id'] = template_id
                            resource_service.create_equipment(user_id, equipment_data)
                    
                        imported_count += 1
                    
                except Exception as template_error:
                    self.logger.error(f"Error importing template {template_data.get('name')}: {template_error}")
                    continue
        
            self.logger.info(f"‚úÖ Imported {imported_count} resource templates for user {user_id}")
            return imported_count > 0
        
        except Exception as e:
            self.logger.error(f"‚ùå Error importing resource templates: {e}")
            return False

    def export_task_templates(self, user_id: int) -> str:
        """
        Export task templates to JSON format for download
        """
        try:
            from backend.services.user_task_service import UserTaskService
            task_service = UserTaskService(self.db_session)
        
            # Get all task templates
            task_templates = task_service.get_user_task_templates(user_id)
        
            export_data = {
            'export_type': 'task_templates',
            'export_version': '1.0',
            'export_timestamp': datetime.now().isoformat(),
            'user_id': user_id,
            'task_templates': task_templates,
            'total_tasks': len(task_templates)
            }
        
            import json
            return json.dumps(export_data, indent=2, ensure_ascii=False, default=str)
        
        except Exception as e:
            self.logger.error(f"‚ùå Error exporting task templates: {e}")
            return json.dumps({'error': str(e)})

    def import_task_templates(self, user_id: int, uploaded_file) -> bool:
        """
        Import task templates from JSON file
        """
        try:
            import json
            from backend.services.user_task_service import UserTaskService
            task_service = UserTaskService(self.db_session)
        
            # Parse uploaded file
            file_content = uploaded_file.getvalue().decode('utf-8')
            import_data = json.loads(file_content)
        
            # Validate export format
            if import_data.get('export_type') != 'task_templates':
                raise ValueError("Invalid file format: Not a task templates export")
        
            task_templates = import_data.get('task_templates', [])
            imported_count = 0
        
            for task_data in task_templates:
                try:
                    # Check if task already exists
                    existing_tasks = task_service.get_user_task_templates(user_id)
                    existing_task = next(
                        (t for t in existing_tasks if t.get('base_task_id') == task_data.get('base_task_id')), 
                        None
                    )
                 
                    if existing_task:
                        # Update existing task
                        updates = {
                            'name': task_data.get('name'),
                            'discipline': task_data.get('discipline'),
                            'base_duration': task_data.get('base_duration'),
                            'duration_calculation_method': task_data.get('duration_calculation_method', 'fixed_duration'),
                            'min_crews_needed': task_data.get('min_crews_needed', 1),
                            'min_equipment_needed': task_data.get('min_equipment_needed', {}),
                            'included': task_data.get('included', True)
                        }
                        updated_task = task_service.update_custom_task(user_id, existing_task['base_task_id'], updates)
                        if updated_task:
                            imported_count += 1
                    else:
                        # Create new task
                        task_data['user_id'] = user_id
                        new_task = task_service.create_custom_task(user_id, task_data)
                        if new_task:
                            imported_count += 1
                        
                except Exception as task_error:
                    self.logger.error(f"Error importing task {task_data.get('name')}: {task_error}")
                    continue
        
            self.logger.info(f"‚úÖ Imported {imported_count} task templates for user {user_id}")
            return imported_count > 0
        
        except Exception as e:
            self.logger.error(f"‚ùå Error importing task templates: {e}")
            return False

        

# ====== End of backend/services/template_service.py ======



# ====== Begin of backend/services/resource_service.py ======

"""
PROFESSIONAL Resource Service - Workers & Equipment Management
UPDATED with proper template association handling and modification tracking
"""
import logging
from typing import List, Dict, Optional, Any
from sqlalchemy.orm import Session

logger = logging.getLogger(__name__)

class ResourceService:
    """
    Professional service for resource operations (workers + equipment)
    """
    
    def __init__(self, db_session: Session):
        self.db_session = db_session
        self.logger = logging.getLogger(__name__)
        self._initialize_repositories()
    
    def _initialize_repositories(self):
        """Initialize repositories"""
        try:
            from backend.db.repositories.resource_repo import ResourceRepository
            self.resource_repo = ResourceRepository(self.db_session)
            self.logger.info("‚úÖ ResourceRepository initialized successfully")
        except Exception as e:
            self.logger.error(f"‚ùå ResourceRepository initialization failed: {e}")
            raise
    
    def get_user_resource_templates(self, user_id: int) -> List[Dict]:
        """Get user resource templates"""
        try:
            db_templates = self.resource_repo.get_user_resource_templates(user_id)
            domain_templates = [self._db_to_domain_resource_template(db_template) for db_template in db_templates]
            self.logger.info(f"‚úÖ Retrieved {len(domain_templates)} resource templates for user {user_id}")
            return domain_templates
        except Exception as e:
            self.logger.error(f"‚ùå Error retrieving resource templates: {e}")
            return []
    
    def get_workers_by_template(self, template_id: int) -> List[Dict]:
        """Get workers by template ID"""
        try:
            db_workers = self.resource_repo.get_workers_by_template(template_id)
            return [self._db_to_domain_worker(w) for w in db_workers]
        except Exception as e:
            self.logger.error(f"Error getting workers by template: {e}")
            return []

    def get_equipment_by_template(self, template_id: int) -> List[Dict]:
        """Get equipment by template ID"""
        try:
            db_equipment = self.resource_repo.get_equipment_by_template(template_id)
            return [self._db_to_domain_equipment(e) for e in db_equipment]
        except Exception as e:
            self.logger.error(f"Error getting equipment by template: {e}")
            return []

    def get_user_workers(self, user_id: int, template_id: Optional[int] = None) -> List[Dict]:
        """Get user workers"""
        try:
            db_workers = self.resource_repo.get_user_workers(user_id, template_id)
            domain_workers = [self._db_to_domain_worker(db_worker) for db_worker in db_workers]
            self.logger.info(f"‚úÖ Retrieved {len(domain_workers)} workers for user {user_id}")
            return domain_workers
        except Exception as e:
            self.logger.error(f"‚ùå Error retrieving workers: {e}")
            return []
    
    def get_user_equipment(self, user_id: int, template_id: Optional[int] = None) -> List[Dict]:
        """Get user equipment"""
        try:
            db_equipment = self.resource_repo.get_user_equipment(user_id, template_id)
            domain_equipment = [self._db_to_domain_equipment(db_equip) for db_equip in db_equipment]
            self.logger.info(f"‚úÖ Retrieved {len(domain_equipment)} equipment for user {user_id}")
            return domain_equipment
        except Exception as e:
            self.logger.error(f"‚ùå Error retrieving equipment: {e}")
            return []
    
    def get_resource_counts(self, template_id: int) -> tuple[int, int]:
        """Get worker and equipment counts for a template"""
        try:
            workers = self.resource_repo.get_workers_by_template(template_id)
            equipment = self.resource_repo.get_equipment_by_template(template_id)
            return len(workers), len(equipment)
        except Exception as e:
            self.logger.error(f"Error getting resource counts: {e}")
            return 0, 0
    
    def create_resource_template(self, user_id: int, template_data: Dict) -> Optional[Dict]:
        """Create new resource template and return created template"""
        try:
            template_data['user_id'] = user_id
            db_template = self.resource_repo.create_resource_template(template_data)
            if db_template:
                domain_template = self._db_to_domain_resource_template(db_template)
                self.logger.info(f"‚úÖ Created resource template: {template_data['name']}")
                return domain_template
            return None
        except Exception as e:
            self.logger.error(f"‚ùå Error creating resource template: {e}")
            return None
    
    def get_template_resources(self, template_id: int) -> Dict[str, List]:
        """Get all resources (workers + equipment) for a template"""
        try:
            workers = self.resource_repo.get_workers_by_template(template_id)
            equipment = self.resource_repo.get_equipment_by_template(template_id)
            
            return {
                'workers': [self._db_to_domain_worker(w) for w in workers],
                'equipment': [self._db_to_domain_equipment(e) for e in equipment]
            }
        except Exception as e:
            logger.error(f"Error getting template resources: {e}")
            return {'workers': [], 'equipment': []}
    
    def update_resource_template(self, template_id: int, updates: Dict) -> bool:
        """Update resource template"""
        try:
            success = self.resource_repo.update_resource_template(template_id, updates)
            if success:
                self.logger.info(f"‚úÖ Updated resource template ID: {template_id}")
            return success
        except Exception as e:
            self.logger.error(f"‚ùå Error updating resource template: {e}")
            return False
    
    def create_worker(self, user_id: int, worker_data: Dict) -> Optional[Dict]:
        """Create new worker and return created worker"""
        try:
            worker_data['user_id'] = user_id
            
            # Generate code if not provided
            if not worker_data.get('code'):
                base_name = worker_data['name'][:3].upper()
                worker_data['code'] = f"WRK_{base_name}_{len(self.get_user_workers(user_id)) + 1:03d}"
            
            db_worker = self.resource_repo.create_worker(worker_data)
            if db_worker:
                domain_worker = self._db_to_domain_worker(db_worker)
                self.logger.info(f"‚úÖ Created worker: {worker_data['name']}")
                return domain_worker
            return None
        except Exception as e:
            self.logger.error(f"‚ùå Error creating worker: {e}")
            return None
    
    def update_worker(self, user_id: int, worker_id: int, updates: Dict) -> Optional[Dict]:
        """Update worker and return updated worker"""
        try:
            db_worker = self.resource_repo.update_worker(worker_id, user_id, updates)
            if db_worker:
                domain_worker = self._db_to_domain_worker(db_worker)
                self.logger.info(f"‚úÖ Updated worker ID: {worker_id}")
                return domain_worker
            return None
        except Exception as e:
            self.logger.error(f"‚ùå Error updating worker: {e}")
            return None

    def update_worker_with_template_check(self, user_id: int, worker_id: int, updates: Dict) -> Optional[Dict]:
        """Update worker and mark template as modified if it was default"""
        try:
            # First get the current worker to check template
            current_worker = self.resource_repo.get_worker_by_id(worker_id)
            if not current_worker:
                return None
            
            template_id = current_worker.template_id
            if template_id:
                # Check if template is default and mark it as modified
                self._mark_template_as_modified_if_default(template_id)
            
            # Now update the worker
            return self.update_worker(user_id, worker_id, updates)
            
        except Exception as e:
            self.logger.error(f"‚ùå Error updating worker with template check: {e}")
            return None
    
    def delete_worker(self, user_id: int, worker_id: int) -> bool:
        """Delete worker"""
        try:
            success = self.resource_repo.delete_worker(worker_id, user_id)
            if success:
                self.logger.info(f"‚úÖ Deleted worker ID: {worker_id}")
            return success
        except Exception as e:
            self.logger.error(f"‚ùå Error deleting worker: {e}")
            return False
    
    def create_equipment(self, user_id: int, equipment_data: Dict) -> Optional[Dict]:
        """Create new equipment and return created equipment"""
        try:
            equipment_data['user_id'] = user_id
            
            # Generate code if not provided
            if not equipment_data.get('code'):
                base_name = equipment_data['name'][:3].upper()
                equipment_data['code'] = f"EQP_{base_name}_{len(self.get_user_equipment(user_id)) + 1:03d}"
            
            db_equipment = self.resource_repo.create_equipment(equipment_data)
            if db_equipment:
                domain_equipment = self._db_to_domain_equipment(db_equipment)
                self.logger.info(f"‚úÖ Created equipment: {equipment_data['name']}")
                return domain_equipment
            return None
        except Exception as e:
            self.logger.error(f"‚ùå Error creating equipment: {e}")
            return None
    
    def update_equipment(self, user_id: int, equipment_id: int, updates: Dict) -> Optional[Dict]:
        """Update equipment and return updated equipment"""
        try:
            db_equipment = self.resource_repo.update_equipment(equipment_id, user_id, updates)
            if db_equipment:
                domain_equipment = self._db_to_domain_equipment(db_equipment)
                self.logger.info(f"‚úÖ Updated equipment ID: {equipment_id}")
                return domain_equipment
            return None
        except Exception as e:
            self.logger.error(f"‚ùå Error updating equipment: {e}")
            return None

    def update_equipment_with_template_check(self, user_id: int, equipment_id: int, updates: Dict) -> Optional[Dict]:
        """Update equipment and mark template as modified if it was default"""
        try:
            # First get the current equipment to check template
            current_equipment = self.resource_repo.get_equipment_by_id(equipment_id)
            if not current_equipment:
                return None
            
            template_id = current_equipment.template_id
            if template_id:
                # Check if template is default and mark it as modified
                self._mark_template_as_modified_if_default(template_id)
            
            # Now update the equipment
            return self.update_equipment(user_id, equipment_id, updates)
            
        except Exception as e:
            self.logger.error(f"‚ùå Error updating equipment with template check: {e}")
            return None
    
    def delete_equipment(self, user_id: int, equipment_id: int) -> bool:
        """Delete equipment"""
        try:
            success = self.resource_repo.delete_equipment(equipment_id, user_id)
            if success:
                self.logger.info(f"‚úÖ Deleted equipment ID: {equipment_id}")
            return success
        except Exception as e:
            self.logger.error(f"‚ùå Error deleting equipment: {e}")
            return False

    def _mark_template_as_modified_if_default(self, template_id: int):
        """Mark a template as modified (no longer default) if it was default"""
        try:
            template = self.resource_repo.get_template_by_id(template_id)
            if template and template.is_default:
                # Mark template as no longer default
                updates = {'is_default': False}
                success = self.resource_repo.update_resource_template(template_id, updates)
                if success:
                    self.logger.info(f"üìù Template {template_id} marked as modified (no longer default)")
                return success
            return False
        except Exception as e:
            self.logger.error(f"‚ùå Error marking template as modified: {e}")
            return False
    
    def load_default_resources(self, user_id: int) -> List[Dict]:
        """
        FIXED: Load default resources as user templates with proper template state management
        Returns newly created resources and handles template modification state
        """
        try:
            from backend.defaults.resources import workers, equipment
            
            created_resources = []
            
            # FIRST: Check for existing default templates
            existing_templates = self.get_user_resource_templates(user_id)
            default_template = None
            modified_default_templates = []
            
            # Separate default and modified default templates
            for template in existing_templates:
                if template.get('is_default') and 'D√©faut' in template.get('name', ''):
                    default_template = template
                    self.logger.info(f"‚úÖ Found active default template: {template['name']} (ID: {template['id']})")
                elif not template.get('is_default') and 'D√©faut' in template.get('name', ''):
                    modified_default_templates.append(template)
                    self.logger.info(f"üìù Found modified default template: {template['name']} (ID: {template['id']})")
            
            # If no active default template exists, create one
            if not default_template:
                template_data = {
                    'name': 'Ressources par D√©faut',
                    'description': 'Template de ressources par d√©faut pour la construction',
                    'user_id': user_id,
                    'category': 'Default',
                    'is_default': True
                }
                
                default_template = self.create_resource_template(user_id, template_data)
                if not default_template:
                    self.logger.error("‚ùå Failed to create default resource template")
                    return []
                
                self.logger.info(f"‚úÖ Created new default resource template: {default_template['id']}")
            
            template_id = default_template['id']
            
            # Get existing resources for THIS template to avoid duplicates
            existing_workers = self.get_workers_by_template(template_id)
            existing_equipment = self.get_equipment_by_template(template_id)
            
            existing_worker_names = {w['name'] for w in existing_workers}
            existing_equipment_names = {e['name'] for e in existing_equipment}
            
            # Load default workers
            worker_count = 0
            for worker_name, worker_resource in workers.items():
                if worker_name not in existing_worker_names:
                    worker_code = f"WRK_{worker_name[:3].upper()}"
                    worker_data = {
                        'user_id': user_id,
                        'template_id': template_id,
                        'name': worker_name,
                        'code': worker_code,
                        'specialty': getattr(worker_resource, 'specialty', worker_name),
                        'category': 'Ouvrier',
                        'base_count': getattr(worker_resource, 'count', 1),
                        'hourly_rate': getattr(worker_resource, 'hourly_rate', 0.0),
                        'daily_rate': getattr(worker_resource, 'hourly_rate', 0.0) * 8,
                        'max_workers_per_crew': getattr(worker_resource, 'max_crews', {}).get('default', 1),
                        'base_productivity_rate': 1.0,
                        'productivity_unit': 'unit√©s/jour',
                        'qualification_level': 'Qualifi√©',
                        'skills': getattr(worker_resource, 'skills', []),
                        'is_active': True
                    }
                    created_worker = self.create_worker(user_id, worker_data)
                    if created_worker:
                        created_resources.append(created_worker)
                        worker_count += 1
                        self.logger.info(f"‚úÖ Created worker: {worker_name}")
            
            # Load default equipment
            equipment_count = 0
            for equip_name, equip_resource in equipment.items():
                if equip_name not in existing_equipment_names:
                    equipment_code = f"EQP_{equip_name[:3].upper()}"
                    equipment_data = {
                        'user_id': user_id,
                        'template_id': template_id,
                        'name': equip_name,
                        'code': equipment_code,
                        'type': getattr(equip_resource, 'type', 'EnginLourd'),
                        'category': 'EnginLourd',
                        'base_count': getattr(equip_resource, 'count', 1),
                        'hourly_rate': getattr(equip_resource, 'hourly_rate', 0.0),
                        'daily_rate': getattr(equip_resource, 'hourly_rate', 0.0) * 8,
                        'max_units_per_task': getattr(equip_resource, 'max_equipment', 1),
                        'base_productivity_rate': 1.0,
                        'productivity_unit': 'unit√©s/jour',
                        'requires_operator': True,
                        'operator_type': 'ConducteurEngins',
                        'is_available': True,
                        'is_active': True
                    }
                    created_equipment = self.create_equipment(user_id, equipment_data)
                    if created_equipment:
                        created_resources.append(created_equipment)
                        equipment_count += 1
                        self.logger.info(f"‚úÖ Created equipment: {equip_name}")
            
            self.logger.info(f"‚úÖ Loaded {worker_count} workers and {equipment_count} equipment in default template {template_id}")
            
            # Return newly created resources or existing ones if no new ones
            if not created_resources and (existing_workers or existing_equipment):
                self.logger.info("‚úÖ Default resources already exist, returning existing resources")
                return existing_workers + existing_equipment
            
            return created_resources
            
        except Exception as e:
            self.logger.error(f"‚ùå Error loading default resources: {e}")
            return []
    
    def export_resources_to_json(self) -> str:
        """Export resources to JSON format"""
        try:
            user_id = 1  # From session
            workers = self.get_user_workers(user_id)
            equipment = self.get_user_equipment(user_id)
            templates = self.get_user_resource_templates(user_id)
            
            export_data = {
                'resource_templates': templates,
                'workers': workers,
                'equipment': equipment,
                'export_version': '1.0'
            }
            
            import json
            return json.dumps(export_data, indent=2, ensure_ascii=False)
        except Exception as e:
            self.logger.error(f"‚ùå Error exporting resources to JSON: {e}")
            return "{}"
    
    def import_resources_from_json(self, uploaded_file) -> bool:
        """Import resources from JSON file"""
        try:
            import json
            resources_data = json.load(uploaded_file)
            user_id = 1  # From session
            
            success_count = 0
            
            # Import workers
            if 'workers' in resources_data:
                for worker_data in resources_data['workers']:
                    worker_data['user_id'] = user_id
                    if self.create_worker(user_id, worker_data):
                        success_count += 1
            
            # Import equipment
            if 'equipment' in resources_data:
                for equipment_data in resources_data['equipment']:
                    equipment_data['user_id'] = user_id
                    if self.create_equipment(user_id, equipment_data):
                        success_count += 1
            
            self.logger.info(f"‚úÖ Imported {success_count} resources from JSON")
            return success_count > 0
            
        except Exception as e:
            self.logger.error(f"‚ùå Error importing resources from JSON: {e}")
            return False
    
    def _db_to_domain_resource_template(self, db_template) -> Dict:
        """Convert DB model to domain resource template dictionary"""
        return {
            'id': db_template.id,
            'name': db_template.name,
            'description': db_template.description,
            'category': db_template.category,
            'version': db_template.version,
            'is_default': db_template.is_default,
            'is_shared': db_template.is_shared,
            'is_active': db_template.is_active,
            'created_at': db_template.created_at.isoformat() if db_template.created_at else None
        }
    
    def _db_to_domain_worker(self, db_worker) -> Dict:
        """Convert DB model to domain worker dictionary"""
        return {
            'id': db_worker.id,
            'user_id': db_worker.user_id,
            'template_id': db_worker.template_id,
            'name': db_worker.name,
            'code': db_worker.code,
            'specialty': db_worker.specialty,
            'category': db_worker.category,
            'base_count': db_worker.base_count,
            'hourly_rate': float(db_worker.hourly_rate),
            'daily_rate': float(db_worker.daily_rate),
            'max_workers_per_crew': db_worker.max_workers_per_crew,
            'base_productivity_rate': float(db_worker.base_productivity_rate),
            'productivity_unit': db_worker.productivity_unit,
            'qualification_level': db_worker.qualification_level,
            'skills': db_worker.skills or [],
            'required_certifications': db_worker.required_certifications or [],
            'is_active': db_worker.is_active,
            'description': db_worker.description,
            'created_at': db_worker.created_at.isoformat() if db_worker.created_at else None
        }
    
    def _db_to_domain_equipment(self, db_equipment) -> Dict:
        """Convert DB model to domain equipment dictionary"""
        return {
            'id': db_equipment.id,
            'user_id': db_equipment.user_id,
            'template_id': db_equipment.template_id,
            'name': db_equipment.name,
            'code': db_equipment.code,
            'type': db_equipment.type,
            'category': db_equipment.category,
            'model': db_equipment.model,
            'base_count': db_equipment.base_count,
            'hourly_rate': float(db_equipment.hourly_rate),
            'daily_rate': float(db_equipment.daily_rate),
            'capacity': db_equipment.capacity,
            'max_units_per_task': db_equipment.max_units_per_task,
            'base_productivity_rate': float(db_equipment.base_productivity_rate),
            'productivity_unit': db_equipment.productivity_unit,
            'requires_operator': db_equipment.requires_operator,
            'operator_type': db_equipment.operator_type,
            'is_available': db_equipment.is_available,
            'is_active': db_equipment.is_active,
            'description': db_equipment.description,
            'created_at': db_equipment.created_at.isoformat() if db_equipment.created_at else None
        }

# ====== End of backend/services/resource_service.py ======



# ====== Begin of backend/db/repositories/task_repo.py ======

"""
Professional Task Repository for CRUD operations
UPDATED with duration calculation methods support
"""
import logging
from typing import List, Dict, Optional, Any
from sqlalchemy.orm import Session
from sqlalchemy import and_, or_

from backend.models.db_models import UserTaskTemplateDB
from backend.models.domain_models import BaseTask, TaskType

logger = logging.getLogger(__name__)

class TaskRepository:
    """
    Professional repository for task template operations with duration methods
    """
    
    def __init__(self, db_session: Session):
        self.db_session = db_session
        self.logger = logging.getLogger(__name__)
    
    def get_user_task_templates(self, user_id: int, project_id: Optional[int] = None) -> List[UserTaskTemplateDB]:
        """
        Get all task templates for a user with duration methods
        """
        try:
            query = self.db_session.query(UserTaskTemplateDB).filter(
                UserTaskTemplateDB.user_id == user_id,
                UserTaskTemplateDB.is_active == True
            )
            
            if project_id:
                # If you add project-specific templates later
                pass
                
            templates = query.order_by(UserTaskTemplateDB.discipline, UserTaskTemplateDB.name).all()
            self.logger.info(f"Retrieved {len(templates)} task templates for user {user_id}")
            return templates
            
        except Exception as e:
            self.logger.error(f"Error getting user task templates: {e}")
            return []
    
    def create_user_task_template(self, task_data: Dict[str, Any]) -> Optional[UserTaskTemplateDB]:
        """
        Create a new user task template with duration method support
        """
        try:
            # Check if template already exists for this user and base_task_id
            existing = self.db_session.query(UserTaskTemplateDB).filter(
                UserTaskTemplateDB.user_id == task_data['user_id'],
                UserTaskTemplateDB.base_task_id == task_data['base_task_id']
            ).first()
            
            # Set default duration method if not provided
            if 'duration_calculation_method' not in task_data:
                task_data['duration_calculation_method'] = 'fixed_duration'
            
            if existing:
                # Update existing template
                for key, value in task_data.items():
                    if hasattr(existing, key) and key not in ['id', 'created_at']:
                        setattr(existing, key, value)

                self.logger.info(f"Updated existing task template: {task_data['base_task_id']}")
                return existing
            else:
                # Create new template
                db_template = UserTaskTemplateDB(**task_data)
                self.db_session.add(db_template)
                self.db_session.flush()
                self.logger.info(f"Created new task template: {task_data['base_task_id']}")
                return db_template
                
        except Exception as e:
   
            self.logger.error(f"Error creating task template: {e}")
            return None
    
    def update_user_task_template(self, user_id: int, task_id: int, updates: Dict[str, Any]) -> Optional[UserTaskTemplateDB]:
        """
        Update a user task template with duration method support
        """
        try:
            db_template = self.db_session.query(UserTaskTemplateDB).filter(
                UserTaskTemplateDB.id == task_id,
                UserTaskTemplateDB.user_id == user_id
            ).first()
            
            if db_template:
                for key, value in updates.items():
                    if hasattr(db_template, key) and key not in ['id', 'user_id', 'created_at']:
                        setattr(db_template, key, value)
                self.logger.info(f"Updated task template {task_id} with duration method: {updates.get('duration_calculation_method')}")
                return db_template
            else:
                self.logger.warning(f"Task template {task_id} not found for user {user_id}")
                return None
                
        except Exception as e:
            self.logger.error(f"Error updating task template: {e}")
            return None
    
    # Keep existing methods for compatibility
    def get_user_task_templates_as_base_tasks(self, user_id: int, project_id: Optional[int] = None) -> Dict[str, BaseTask]:
        """
        CRITICAL: Convert user task templates to BaseTask format for the scheduler
        Now includes duration calculation methods
        """
        try:
            db_templates = self.get_user_task_templates(user_id, project_id)
            base_tasks = {}
            
            for db_template in db_templates:
                base_task_id = db_template.base_task_id
                
                # Create BaseTask object from user template with duration methods
                base_task = BaseTask(
                    id=base_task_id,
                    name=db_template.name,
                    discipline=db_template.discipline,
                    sub_discipline=db_template.sub_discipline,
                    resource_type=db_template.resource_type,
                    task_type=TaskType(db_template.task_type.upper()) if isinstance(db_template.task_type, str) else db_template.task_type,
                    base_duration=db_template.base_duration,
                    unit_duration=getattr(db_template, 'unit_duration', 0),
                    duration_calculation_method=getattr(db_template, 'duration_calculation_method', 'fixed_duration'),
                    min_crews_needed=db_template.min_crews_needed,
                    min_equipment_needed=db_template.min_equipment_needed or {},
                    predecessors=db_template.predecessors or [],
                    repeat_on_floor=db_template.repeat_on_floor,
                    delay=db_template.delay,
                    weather_sensitive=db_template.weather_sensitive,
                    quality_gate=db_template.quality_gate,
                    included=db_template.included
                )
                
                base_tasks[base_task_id] = base_task
            
            self.logger.info(f"Converted {len(base_tasks)} user templates to BaseTask format with duration methods")
            return base_tasks
            
        except Exception as e:
            self.logger.error(f"Error converting user templates to BaseTask: {e}")
            return {}
    
    def delete_user_task_template(self, user_id: int, task_id: int) -> bool:
        """
        Soft delete a user task template
        """
        try:
            db_template = self.db_session.query(UserTaskTemplateDB).filter(
                UserTaskTemplateDB.id == task_id,
                UserTaskTemplateDB.user_id == user_id
            ).first()
            
            if db_template:
                db_template.is_active = False

                self.logger.info(f"Soft deleted task template {task_id}")
                return True
            else:
                self.logger.warning(f"Task template {task_id} not found for user {user_id}")
                return False
                
        except Exception as e:
            self.logger.error(f"Error deleting task template: {e}")
            return False


# ====== End of backend/db/repositories/task_repo.py ======



# ====== Begin of backend/db/repositories/resource_repo.py ======

"""
PROFESSIONAL Resource Repository - UPDATED with Resource Template Support
Enhanced for unified resource management with proper template associations
"""
import logging
from typing import List, Dict, Optional, Any
from sqlalchemy.orm import Session
from sqlalchemy import and_, or_

from backend.models.db_models import ResourceTemplateDB, WorkerResourceDB, EquipmentResourceDB

logger = logging.getLogger(__name__)

class ResourceRepository:
    """
    UPDATED Professional repository for resource operations with template support
    """
    
    def __init__(self, db_session: Session):
        self.db_session = db_session
        self.logger = logging.getLogger(__name__)
    
    # RESOURCE TEMPLATE METHODS
    def get_user_resource_templates(self, user_id: int) -> List[ResourceTemplateDB]:
        """Get all resource templates for a user"""
        try:
            templates = self.db_session.query(ResourceTemplateDB).filter(
                ResourceTemplateDB.user_id == user_id,
                ResourceTemplateDB.is_active == True
            ).order_by(ResourceTemplateDB.name).all()
            
            self.logger.info(f"‚úÖ Retrieved {len(templates)} resource templates for user {user_id}")
            return templates
            
        except Exception as e:
            self.logger.error(f"‚ùå Error getting user resource templates: {e}")
            return []
    
    def create_resource_template(self, template_data: Dict[str, Any]) -> Optional[ResourceTemplateDB]:
        """Create a new resource template - NO COMMIT"""
        try:
            # Check if template already exists for this user and name
            existing = self.db_session.query(ResourceTemplateDB).filter(
                ResourceTemplateDB.user_id == template_data['user_id'],
                ResourceTemplateDB.name == template_data['name']
            ).first()
            
            if existing:
                self.logger.warning(f"‚ö†Ô∏è Resource template already exists: {template_data['name']}")
                return existing
            
            db_template = ResourceTemplateDB(**template_data)
            self.db_session.add(db_template)
            self.db_session.flush()
            self.logger.info(f"‚úÖ Created new resource template: {template_data['name']}")
            return db_template
            
        except Exception as e:
            self.logger.error(f"‚ùå Error creating resource template: {e}")
            return None
    
    def update_resource_template(self, template_id: int, updates: Dict[str, Any]) -> bool:
        """Update a resource template by ID - NO COMMIT"""
        try:
            db_template = self.db_session.query(ResourceTemplateDB).filter(
                ResourceTemplateDB.id == template_id
            ).first()
            
            if db_template:
                for key, value in updates.items():
                    if hasattr(db_template, key) and key not in ['id', 'user_id', 'created_at']:
                        setattr(db_template, key, value)
                self.db_session.flush()
                self.logger.info(f"‚úÖ Updated resource template ID: {template_id}")
                return True
            else:
                self.logger.warning(f"‚ö†Ô∏è Resource template ID {template_id} not found")
                return False
                
        except Exception as e:
            self.logger.error(f"‚ùå Error updating resource template: {e}")
            return False
    
    def get_workers_by_template(self, template_id: int) -> List[WorkerResourceDB]:
        """Get all workers for a specific template"""
        try:
            workers = self.db_session.query(WorkerResourceDB).filter(
                WorkerResourceDB.template_id == template_id,
                WorkerResourceDB.is_active == True
            ).order_by(WorkerResourceDB.name).all()
            
            self.logger.info(f"‚úÖ Retrieved {len(workers)} workers for template {template_id}")
            return workers
            
        except Exception as e:
            self.logger.error(f"‚ùå Error getting workers by template: {e}")
            return []
    
    def get_equipment_by_template(self, template_id: int) -> List[EquipmentResourceDB]:
        """Get all equipment for a specific template"""
        try:
            equipment = self.db_session.query(EquipmentResourceDB).filter(
                EquipmentResourceDB.template_id == template_id,
                EquipmentResourceDB.is_active == True
            ).order_by(EquipmentResourceDB.name).all()
            
            self.logger.info(f"‚úÖ Retrieved {len(equipment)} equipment for template {template_id}")
            return equipment
            
        except Exception as e:
            self.logger.error(f"‚ùå Error getting equipment by template: {e}")
            return []
    
    # WORKER METHODS
    def get_user_workers(self, user_id: int, template_id: Optional[int] = None) -> List[WorkerResourceDB]:
        """Get all workers for a user"""
        try:
            query = self.db_session.query(WorkerResourceDB).filter(
                WorkerResourceDB.user_id == user_id,
                WorkerResourceDB.is_active == True
            )
            
            if template_id:
                query = query.filter(WorkerResourceDB.template_id == template_id)
                
            workers = query.order_by(WorkerResourceDB.name).all()
            self.logger.info(f"‚úÖ Retrieved {len(workers)} workers for user {user_id}")
            return workers
            
        except Exception as e:
            self.logger.error(f"‚ùå Error getting user workers: {e}")
            return []
    
    def create_worker(self, worker_data: Dict[str, Any]) -> Optional[WorkerResourceDB]:
        """Create a new worker - NO COMMIT"""
        try:
            # Check if worker already exists for this user and code
            existing = self.db_session.query(WorkerResourceDB).filter(
                WorkerResourceDB.user_id == worker_data['user_id'],
                WorkerResourceDB.code == worker_data['code']
            ).first()
            
            if existing:
                self.logger.warning(f"‚ö†Ô∏è Worker already exists: {worker_data['code']}")
                return existing
            
            db_worker = WorkerResourceDB(**worker_data)
            self.db_session.add(db_worker)
            self.db_session.flush()
            self.logger.info(f"‚úÖ Created new worker: {worker_data['name']}")
            return db_worker
            
        except Exception as e:
            self.logger.error(f"‚ùå Error creating worker: {e}")
            return None
    
    def update_worker(self, worker_id: int, user_id: int, updates: Dict[str, Any]) -> Optional[WorkerResourceDB]:
        """Update a worker by ID - NO COMMIT"""
        try:
            db_worker = self.db_session.query(WorkerResourceDB).filter(
                WorkerResourceDB.id == worker_id,
                WorkerResourceDB.user_id == user_id
            ).first()
            
            if db_worker:
                for key, value in updates.items():
                    if hasattr(db_worker, key) and key not in ['id', 'user_id', 'created_at']:
                        setattr(db_worker, key, value)
                self.db_session.flush()
                self.logger.info(f"‚úÖ Updated worker ID: {worker_id}")
                return db_worker
            else:
                self.logger.warning(f"‚ö†Ô∏è Worker ID {worker_id} not found for user {user_id}")
                return None
                
        except Exception as e:
            self.logger.error(f"‚ùå Error updating worker: {e}")
            return None
    
    def delete_worker(self, worker_id: int, user_id: int) -> bool:
        """Soft delete a worker by ID - NO COMMIT"""
        try:
            db_worker = self.db_session.query(WorkerResourceDB).filter(
                WorkerResourceDB.id == worker_id,
                WorkerResourceDB.user_id == user_id
            ).first()
            
            if db_worker:
                db_worker.is_active = False
                self.db_session.flush()
                self.logger.info(f"‚úÖ Soft deleted worker ID: {worker_id}")
                return True
            else:
                self.logger.warning(f"‚ö†Ô∏è Worker ID {worker_id} not found for user {user_id}")
                return False
                
        except Exception as e:
            self.logger.error(f"‚ùå Error deleting worker: {e}")
            return False
    
    # EQUIPMENT METHODS
    def get_user_equipment(self, user_id: int, template_id: Optional[int] = None) -> List[EquipmentResourceDB]:
        """Get all equipment for a user"""
        try:
            query = self.db_session.query(EquipmentResourceDB).filter(
                EquipmentResourceDB.user_id == user_id,
                EquipmentResourceDB.is_active == True
            )
            
            if template_id:
                query = query.filter(EquipmentResourceDB.template_id == template_id)
                
            equipment = query.order_by(EquipmentResourceDB.name).all()
            self.logger.info(f"‚úÖ Retrieved {len(equipment)} equipment for user {user_id}")
            return equipment
            
        except Exception as e:
            self.logger.error(f"‚ùå Error getting user equipment: {e}")
            return []
    
    def create_equipment(self, equipment_data: Dict[str, Any]) -> Optional[EquipmentResourceDB]:
        """Create a new equipment - NO COMMIT"""
        try:
            # Check if equipment already exists for this user and code
            existing = self.db_session.query(EquipmentResourceDB).filter(
                EquipmentResourceDB.user_id == equipment_data['user_id'],
                EquipmentResourceDB.code == equipment_data['code']
            ).first()
            
            if existing:
                self.logger.warning(f"‚ö†Ô∏è Equipment already exists: {equipment_data['code']}")
                return existing
            
            db_equipment = EquipmentResourceDB(**equipment_data)
            self.db_session.add(db_equipment)
            self.db_session.flush()
            self.logger.info(f"‚úÖ Created new equipment: {equipment_data['name']}")
            return db_equipment
            
        except Exception as e:
            self.logger.error(f"‚ùå Error creating equipment: {e}")
            return None
    
    def update_equipment(self, equipment_id: int, user_id: int, updates: Dict[str, Any]) -> Optional[EquipmentResourceDB]:
        """Update an equipment by ID - NO COMMIT"""
        try:
            db_equipment = self.db_session.query(EquipmentResourceDB).filter(
                EquipmentResourceDB.id == equipment_id,
                EquipmentResourceDB.user_id == user_id
            ).first()
            
            if db_equipment:
                for key, value in updates.items():
                    if hasattr(db_equipment, key) and key not in ['id', 'user_id', 'created_at']:
                        setattr(db_equipment, key, value)
                self.db_session.flush()
                self.logger.info(f"‚úÖ Updated equipment ID: {equipment_id}")
                return db_equipment
            else:
                self.logger.warning(f"‚ö†Ô∏è Equipment ID {equipment_id} not found for user {user_id}")
                return None
                
        except Exception as e:
            self.logger.error(f"‚ùå Error updating equipment: {e}")
            return None
    
    def delete_equipment(self, equipment_id: int, user_id: int) -> bool:
        """Soft delete an equipment by ID - NO COMMIT"""
        try:
            db_equipment = self.db_session.query(EquipmentResourceDB).filter(
                EquipmentResourceDB.id == equipment_id,
                EquipmentResourceDB.user_id == user_id
            ).first()
            
            if db_equipment:
                db_equipment.is_active = False
                self.db_session.flush()
                self.logger.info(f"‚úÖ Soft deleted equipment ID: {equipment_id}")
                return True
            else:
                self.logger.warning(f"‚ö†Ô∏è Equipment ID {equipment_id} not found for user {user_id}")
                return False
                
        except Exception as e:
            self.logger.error(f"‚ùå Error deleting equipment: {e}")
            return False
    
    # BULK OPERATIONS
    def get_template_with_resources(self, template_id: int) -> Optional[Dict[str, Any]]:
        """Get a template with all its resources"""
        try:
            template = self.db_session.query(ResourceTemplateDB).filter(
                ResourceTemplateDB.id == template_id
            ).first()
            
            if template:
                workers = self.get_workers_by_template(template_id)
                equipment = self.get_equipment_by_template(template_id)
                
                return {
                    'template': template,
                    'workers': workers,
                    'equipment': equipment
                }
            else:
                return None
                
        except Exception as e:
            self.logger.error(f"‚ùå Error getting template with resources: {e}")
            return None
    
    def count_template_resources(self, template_id: int) -> Dict[str, int]:
        """Count resources in a template"""
        try:
            worker_count = self.db_session.query(WorkerResourceDB).filter(
                WorkerResourceDB.template_id == template_id,
                WorkerResourceDB.is_active == True
            ).count()
            
            equipment_count = self.db_session.query(EquipmentResourceDB).filter(
                EquipmentResourceDB.template_id == template_id,
                EquipmentResourceDB.is_active == True
            ).count()
            
            return {
                'workers': worker_count,
                'equipment': equipment_count,
                'total': worker_count + equipment_count
            }
            
        except Exception as e:
            self.logger.error(f"‚ùå Error counting template resources: {e}")
            return {'workers': 0, 'equipment': 0, 'total': 0}
        
    def get_worker_by_id(self, worker_id: int):
        """Get worker by ID"""
        try:
            return self.db_session.query(WorkerResourceDB).filter(
            WorkerResourceDB.id == worker_id
            ).first()
        except Exception as e:
            self.logger.error(f"Error getting worker by ID: {e}")
            return None

    def get_equipment_by_id(self, equipment_id: int):
        """Get equipment by ID"""
        try:
            return self.db_session.query(EquipmentResourceDB).filter(
            EquipmentResourceDB.id == equipment_id
            ).first()
        except Exception as e:
            self.logger.error(f"Error getting equipment by ID: {e}")
            return None

    def get_template_by_id(self, template_id: int):
        """Get template by ID"""
        try:
            return self.db_session.query(ResourceTemplateDB).filter(
            ResourceTemplateDB.id == template_id
            ).first()
        except Exception as e:
            self.logger.error(f"Error getting template by ID: {e}")
            return None

# ====== End of backend/db/repositories/resource_repo.py ======



# ====== Begin of frontend/helpers/template_context.py ======

"""
FIXED Template Context Manager with LAZY initialization
"""

import streamlit as st
from typing import Dict, Any, Optional, List, Callable
import logging

logger = logging.getLogger(__name__)

class TemplateContextManager:
    """
    FIXED: Lazy template context manager that doesn't access session state on import
    """
    
    def __init__(self):
        self._observers: List[Callable] = []
        # ‚úÖ REMOVE initialization from __init__ - do it lazily
    
    def _ensure_initialized(self):
        """Ensure template context is initialized in session state - LAZY"""
        if 'template_context' not in st.session_state:
            st.session_state.template_context = {
                'resource_template': None,
                'task_template': None,
                'last_updated': None,
                'initialized': False
            }
            logger.info("‚úÖ Template context initialized in session state")
    
    @property
    def resource_template(self) -> Optional[Dict[str, Any]]:
        self._ensure_initialized()  # ‚úÖ Initialize only when accessed
        return st.session_state.template_context['resource_template']
    
    @resource_template.setter
    def resource_template(self, template: Optional[Dict[str, Any]]):
        self._ensure_initialized()  # ‚úÖ Initialize only when accessed
        st.session_state.template_context['resource_template'] = template
        st.session_state.template_context['last_updated'] = 'resource'
        self._notify_observers()
    
    @property
    def task_template(self) -> Optional[Dict[str, Any]]:
        self._ensure_initialized()  # ‚úÖ Initialize only when accessed
        return st.session_state.template_context['task_template']
    
    @task_template.setter
    def task_template(self, template: Optional[Dict[str, Any]]):
        self._ensure_initialized()  # ‚úÖ Initialize only when accessed
        st.session_state.template_context['task_template'] = template
        st.session_state.template_context['last_updated'] = 'task'
        self._notify_observers()
    
    def get_current_context(self) -> Dict[str, Any]:
        """Get complete context with validation state"""
        self._ensure_initialized()  # ‚úÖ Initialize only when accessed
        
        context = {
            'resource_template': self.resource_template,
            'task_template': self.task_template,
            'is_ready': bool(self.resource_template and self.task_template),
            'last_updated': st.session_state.template_context.get('last_updated'),
            'initialized': st.session_state.template_context.get('initialized', False)
        }
        
        # Add compatibility info if both templates are selected
        if context['is_ready']:
            context['compatibility'] = self._get_compatibility_summary()
            
        return context
    
    def is_ready(self) -> bool:
        """Check if both resource and task templates are set."""
        self._ensure_initialized()  # ‚úÖ Initialize only when accessed
        return bool(self.resource_template and self.task_template)
    
    def initialize_with_services(self, services: Dict[str, Any], user_id: int):
        """Initialize context with services from app.py"""
        self._ensure_initialized()  # ‚úÖ Initialize only when accessed
        
        try:
            if st.session_state.template_context.get('initialized'):
                return
                
            # Get available templates from services
            resource_service = services['resource_service']
            task_service = services['task_service']
            
            resource_templates = resource_service.get_user_resource_templates(user_id)
            task_templates = task_service.get_user_task_templates(user_id)
            
            # Set default selections if available
            if resource_templates:
                self.resource_template = resource_templates[0]
            
            if task_templates:
                # Use the first task template group
                task_groups = task_service.get_task_template_groups(user_id)
                if task_groups:
                    self.task_template = task_groups[0]
            
            st.session_state.template_context['initialized'] = True
            logger.info("‚úÖ Template context initialized with services")
            
        except Exception as e:
            logger.error(f"‚ùå Error initializing template context with services: {e}")
    
    # ... rest of the methods remain the same ...

# Global instance - but it won't initialize session state until first access
template_context = TemplateContextManager()

def get_template_context() -> TemplateContextManager:
    """Get the global template context instance"""
    return template_context

def render_template_context_selector(services: Dict[str, Any], user_id: int):
    """
    Render template context selector component - UPDATED with safe access
    """
    context = get_template_context()
    
    # Initialize context with services if not done
    current_context = context.get_current_context()  # ‚úÖ This will initialize if needed
    if not current_context['initialized']:
        context.initialize_with_services(services, user_id)
    
    st.markdown("### üéØ Contexte de Travail")
    
    col1, col2 = st.columns(2)
    
    with col1:
        _render_resource_template_selector(services, user_id, context)
    
    with col2:
        _render_task_template_selector(services, user_id, context)
    
    # Display current context status
    _render_context_status(context, services)

def _render_resource_template_selector(services, user_id: int, context: TemplateContextManager):
    """Render resource template selector - UPDATED"""
    resource_service = services['resource_service']
    resource_templates = resource_service.get_user_resource_templates(user_id)
    
    if resource_templates:
        template_options = {f"{rt['name']} (ID: {rt['id']})": rt for rt in resource_templates}
        
        # Get current selection
        current_template = context.resource_template
        current_key = None
        if current_template:
            current_key = f"{current_template['name']} (ID: {current_template['id']})"
        
        selected_key = st.selectbox(
            "üì¶ Mod√®le de Ressources Actif:",
            options=[''] + list(template_options.keys()),
            index=list(template_options.keys()).index(current_key) + 1 if current_key else 0,
            key="resource_context_selector_main",
            help="S√©lectionnez le mod√®le de ressources que vous modifiez"
        )
        
        if selected_key and selected_key in template_options:
            context.resource_template = template_options[selected_key]
        elif not selected_key:
            context.resource_template = None
            
    else:
        st.error("‚ùå Aucun mod√®le de ressources disponible")
        if st.button("üì• Cr√©er Mod√®le D√©faut", key="create_default_resource"):
            resource_service.load_default_resources(user_id)
            st.rerun()

def _render_task_template_selector(services, user_id: int, context: TemplateContextManager):
    """Render task template selector - UPDATED to use services from app.py"""
    task_service = services['task_service']
    
    # Get task template groups using the service method
    task_groups = task_service.get_task_template_groups(user_id)
    
    if task_groups:
        # Create display options for template groups
        template_options = {}
        for group in task_groups:
            template_name = group['template_name']
            disciplines = ', '.join(sorted(group['disciplines']))
            display_name = f"{template_name} ({group['task_count']} t√¢ches, {disciplines})"
            template_options[display_name] = group
        
        # Get current selection
        current_template = context.task_template
        current_key = None
        if current_template:
            current_template_name = current_template.get('template_name')
            if current_template_name:
                for display_name, template_data in template_options.items():
                    if template_data['template_name'] == current_template_name:
                        current_key = display_name
                        break
        
        selected_key = st.selectbox(
            "üìö Groupe de T√¢ches Actif:",
            options=[''] + list(template_options.keys()),
            index=list(template_options.keys()).index(current_key) + 1 if current_key else 0,
            key="task_context_selector_main",
            help="S√©lectionnez un groupe de t√¢ches (template) pour les taux de productivit√©"
        )
        
        if selected_key and selected_key in template_options:
            context.task_template = template_options[selected_key]
        elif not selected_key:
            context.task_template = None
            
    else:
        st.error("‚ùå Aucun groupe de t√¢ches disponible")
        if st.button("üì• Charger T√¢ches D√©faut", key="load_default_tasks"):
            task_service.load_default_tasks(user_id)
            st.rerun()

def _render_context_status(context: TemplateContextManager, services: Dict[str, Any]):
    """Render current context status - UPDATED"""
    current_context = context.get_current_context()
    
    if current_context['is_ready']:
        st.success("‚úÖ Contexte pr√™t pour les op√©rations")
        
        # Display template details
        col1, col2 = st.columns(2)
        with col1:
            st.info(f"**Ressources:** {current_context['resource_template']['name']}")
        with col2:
            template_name = current_context['task_template'].get('template_name', 'Sans nom')
            st.info(f"**T√¢ches:** {template_name}")
        
        # Validate compatibility
        if st.button("üîç Valider Compatibilit√©", key="validate_compatibility"):
            _validate_template_compatibility(context, services)
    else:
        st.warning("‚ö†Ô∏è S√©lectionnez un mod√®le de ressources ET un mod√®le de t√¢ches")

def _validate_template_compatibility(context: TemplateContextManager, services: Dict[str, Any]):
    """Validate template compatibility - UPDATED"""
    try:
        template_service = services['template_service']
        current_context = context.get_current_context()
        
        if current_context['is_ready']:
            validation = template_service.validate_template_compatibility(
                current_context['resource_template'],
                current_context['task_template']
            )
            
            if validation.get('compatible', False):
                st.success("‚úÖ Templates compatibles!")
            else:
                st.error("‚ùå Probl√®mes de compatibilit√© d√©tect√©s")
                
            # Show detailed validation results
            with st.expander("üìã D√©tails de Validation", expanded=True):
                st.json(validation)
                
    except Exception as e:
        st.error(f"‚ùå Erreur lors de la validation: {e}")

# ====== End of frontend/helpers/template_context.py ======



# ====== Begin of frontend/components/data_tables/task_table.py ======

"""
OPTIMIZED Task Table Component - Civil Engineering Scheduling
Professional, simplified, and maintainable with widget manager
"""
import streamlit as st
import pandas as pd
import json
from typing import List, Dict, Optional, Any
import logging
from backend.utils.widget_manager import widget_manager

from frontend.helpers.template_context import template_context

logger = logging.getLogger(__name__)

# French column mapping
FRENCH_COLUMNS = {
    "base_task_id": "ID T√¢che", "name": "Nom", "discipline": "Discipline", 
    "sub_discipline": "Sous-Discipline", "resource_type": "Type Ressource",
    "task_type": "Type", "base_duration": "Dur√©e Base", 
    "unit_duration": "Dur√©e Unitaire", "duration_calculation_method": "M√©thode Calcul",
    "min_crews_needed": "√âquipes Min", "max_crews_allowed": "√âquipes Max",
    "min_equipment_needed": "√âquipements Min", "max_equipment_allowed": "√âquipements Max",
    "predecessors": "Pr√©d√©cesseurs", "repeat_on_floor": "R√©p√©tition √âtage",
    "delay": "D√©lai", "weather_sensitive": "Sensible M√©t√©o", 
    "quality_gate": "Point Contr√¥le", "included": "Incluse"
}

# Duration calculation methods
DURATION_METHODS = {
    "fixed_duration": "Dur√©e Fixe",
    "quantity_based": "Bas√© sur la Quantit√©", 
    "resource_calculation": "Calcul par Ressources"
}


def render_tasks_table(tasks: List[Dict], task_service, user_id: int, available_resources: Dict[str, List[Dict]] = None, template_service=None):
    """Main task table with essential context integration"""
    # Show context status
    if template_context.is_ready():
        resource = template_context.resource_template
        task = template_context.task_template
        st.success(f"üéØ Contexte: {resource['name']} + {task.get('name', 'Sans nom')}")
    
    # Initialize state
    if 'task_form_state' not in st.session_state:
        st.session_state.task_form_state = {'mode': None, 'current_task': None}
    
    state = st.session_state.task_form_state
    
    # Apply filters
    filtered_tasks = _render_task_filters(tasks)
    
    # Show statistics
    _render_statistics(tasks, filtered_tasks)
    
    # Handle form mode
    if state['mode']:
        _render_task_form(state, tasks, task_service, user_id, available_resources, template_service)
        return
    
    # Main table interface
    _render_table_interface(filtered_tasks, task_service, user_id)

def _render_statistics(all_tasks: List[Dict], filtered_tasks: List[Dict]):
    """Essential statistics"""
    total_count = len(all_tasks)
    filtered_count = len(filtered_tasks)
    included_count = len([t for t in filtered_tasks if t.get('included', True)])
    
    col1, col2, col3 = st.columns(3)
    col1.metric("üìã T√¢ches", f"{filtered_count}/{total_count}")
    col2.metric("‚úÖ Incluses", included_count)
    col3.metric("üéØ Contexte", "‚úÖ" if template_context.is_ready() else "‚ö†Ô∏è")

def _render_task_filters(tasks: List[Dict]) -> List[Dict]:
    """Essential filters"""
    if not tasks:
        return []
    
    disciplines = sorted(set(t.get('discipline', '') for t in tasks if t.get('discipline')))
    
    col1, col2 = st.columns(2)
    with col1:
        selected_discipline = st.selectbox(
            "Discipline",
            options=['Toutes'] + disciplines,
            key=widget_manager.generate_key("filter_discipline", "task_table")
        )
    with col2:
        included_only = st.checkbox("Afficher seulement les incluses", value=True,
                                  key=widget_manager.generate_key("filter_included", "task_table"))
    
    # Apply filters
    filtered = tasks
    if selected_discipline != 'Toutes':
        filtered = [t for t in filtered if t.get('discipline') == selected_discipline]
    if included_only:
        filtered = [t for t in filtered if t.get('included', True)]
    
    return filtered

def _render_table_interface(tasks: List[Dict], task_service, user_id: int):
    """Main table interface"""
    selected_task = _render_task_selection(tasks)
    
    # Action buttons
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        if st.button("‚ûï Nouvelle T√¢che", use_container_width=True):
            st.session_state.task_form_state = {'mode': 'new', 'current_task': None}
            st.rerun()
    
    with col2:
        disabled = selected_task is None
        if st.button("‚úèÔ∏è Modifier", use_container_width=True, disabled=disabled):
            st.session_state.task_form_state = {'mode': 'edit', 'current_task': selected_task}
            st.rerun()
    
    with col3:
        if st.button("üìã Dupliquer", use_container_width=True, disabled=disabled):
            st.session_state.task_form_state = {'mode': 'duplicate', 'current_task': selected_task}
            st.rerun()
    
    with col4:
        if st.button("üóëÔ∏è Supprimer", use_container_width=True, disabled=disabled):
            _delete_task(selected_task, tasks, task_service, user_id)
            st.rerun()
    
    # Context actions
    if template_context.is_ready() and selected_task:
        st.markdown("---")
        if st.button("üîó Tester Compatibilit√©", use_container_width=True):
            _test_compatibility(selected_task, template_service)
    
    # Data table
    _render_data_table(tasks)

def _test_compatibility(task: Dict, template_service=None):
    """Test task compatibility with current context"""
    try:
        if template_service is None:
            st.error("‚ùå Service de template non disponible")
            return
        
        validation = template_service.validate_template_compatibility(
            template_context.resource_template,
            task
        )
        
        if validation['compatible']:
            st.success("‚úÖ T√¢che compatible avec le contexte!")
        else:
            st.error("‚ùå Probl√®mes de compatibilit√©")
            
        # Show issues
        if validation['issues']:
            st.write("**Probl√®mes:**")
            for issue in validation['issues']:
                st.write(f"- {issue}")
                
    except Exception as e:
        st.error(f"‚ùå Erreur: {e}")

def _render_task_selection(tasks: List[Dict]) -> Optional[Dict]:
    """Task selection dropdown"""
    if not tasks:
        st.info("üì≠ Aucune t√¢che disponible")
        return None
        
    options = {f"{t.get('name', 'Sans nom')} ({t.get('base_task_id', 'N/A')})": t for t in tasks}
    
    selected = st.selectbox(
        "S√©lectionner une t√¢che:",
        options=[''] + list(options.keys()),
        key=widget_manager.generate_key("task_selector", "task_table")
    )
    
    if selected and selected in options:
        return options[selected]
    
    return None

def _render_data_table(tasks: List[Dict]):
    """Data table display"""
    if not tasks:
        st.info("üì≠ Aucune t√¢che √† afficher")
        return
    
    df = _tasks_to_dataframe(tasks)
    
    edited_df = st.data_editor(
        df,
        use_container_width=True,
        hide_index=True,
        column_config={
            "Incluse": st.column_config.CheckboxColumn("Incluse"),
            "Dur√©e Base": st.column_config.NumberColumn("Dur√©e (jours)", min_value=1),
            "√âquipes Min": st.column_config.NumberColumn("√âquipes Min", min_value=1)
        },
        key=widget_manager.generate_key("task_data_editor", "task_table")
    )
    
    if st.button("üíæ Sauvegarder Modifications", use_container_width=True):
        _save_table_changes(edited_df, tasks)
        st.success("‚úÖ Modifications sauvegard√©es!")
        st.rerun()

def _tasks_to_dataframe(tasks: List[Dict]) -> pd.DataFrame:
    """Convert tasks to DataFrame"""
    if not tasks:
        return pd.DataFrame()
    
    display_data = []
    for task in tasks:
        row = {}
        for eng_col, fr_col in FRENCH_COLUMNS.items():
            if eng_col in task:
                value = task[eng_col]
                if eng_col == 'min_equipment_needed':
                    equipment = task.get('min_equipment_needed', {})
                    row[fr_col] = ", ".join([f"{k}({v})" for k, v in equipment.items()]) if equipment else "Aucun"
                elif eng_col == 'predecessors':
                    preds = task.get('predecessors', [])
                    row[fr_col] = ", ".join(preds) if preds else "Aucun"
                elif eng_col in ['repeat_on_floor', 'weather_sensitive', 'quality_gate', 'included']:
                    row[fr_col] = '‚úÖ' if value else '‚ùå'
                else:
                    row[fr_col] = value
        
        display_data.append(row)
    
    return pd.DataFrame(display_data)

def _render_task_form(state: Dict, all_tasks: List[Dict], task_service, user_id: int, available_resources: Dict[str, List[Dict]] = None, template_service=None):
    """Unified form for new/edit/duplicate operations"""
    mode = state['mode']
    task = state['current_task']
    
    st.markdown("---")
    
    if mode == 'edit':
        title = f"‚úèÔ∏è Modification: {task.get('name')}"
        submit_label = "üíæ Sauvegarder"
    elif mode == 'duplicate':
        title = "üìã Duplication de T√¢che"
        submit_label = "‚úÖ Cr√©er Copie"
        task = task.copy() if task else None
    else:  # new
        title = "‚ûï Nouvelle T√¢che"
        submit_label = "‚ûï Cr√©er T√¢che"
        task = _get_default_task_template()
    
    st.subheader(title)
    
    with st.form(key=widget_manager.generate_key("task_form", "task_table")):
        # Basic Information
        task = _render_basic_info_section(task, mode)
        
        # Duration Calculation
        task = _render_duration_section(task)
        
        # Resource Selection (Workers & Equipment)
        task = _render_resource_selection_section(task, available_resources)
        
        # Predecessors
        task = _render_predecessors_section(task, all_tasks)
        
        # Options
        task = _render_options_section(task)
        
        # Form Actions
        col1, col2 = st.columns(2)
        with col1:
            if st.form_submit_button(submit_label, use_container_width=True,
                                   key=widget_manager.generate_key("form_submit", "task_table")):
                if _validate_task(task, all_tasks, mode):
                    _save_task(task, all_tasks, task_service, user_id, mode)
        
        with col2:
            if st.form_submit_button("‚ùå Annuler", use_container_width=True,
                                   key=widget_manager.generate_key("form_cancel", "task_table")):
                st.session_state.task_form_state = {'mode': None, 'current_task': None}
                st.rerun()

def _render_basic_info_section(task: Dict, mode: str) -> Dict:
    """Essential task information"""
    st.markdown("### üìù Informations de Base")
    
    col1, col2 = st.columns(2)
    with col1:
        task["name"] = st.text_input(
            "Nom de la t√¢che *", 
            value=task.get("name", ""),
            key=widget_manager.generate_key("task_name", "task_table")
        )
        task["discipline"] = st.text_input(
            "Discipline *", 
            value=task.get("discipline", ""),
            key=widget_manager.generate_key("task_discipline", "task_table")
        )
        
    with col2:
        task["sub_discipline"] = st.text_input(
            "Sous-discipline *", 
            value=task.get("sub_discipline", ""),
            key=widget_manager.generate_key("task_sub_discipline", "task_table")
        )
        task["resource_type"] = st.text_input(
            "Type de ressource", 
            value=task.get("resource_type", ""),
            key=widget_manager.generate_key("task_resource_type", "task_table")
        )
    
    task["task_type"] = st.selectbox(
        "Type de t√¢che *",
        options=["worker", "equipment", "parallel", "hybrid"],
        index=["worker", "equipment", "parallel", "hybrid"].index(task.get("task_type", "execution")),
        key=widget_manager.generate_key("task_task_type", "task_table")
    )
    
    return task

def _render_duration_section(task: Dict) -> Dict:
    """Duration calculation with business logic"""
    st.markdown("### ‚è±Ô∏è Calcul de la Dur√©e")
    
    # Method selection
    current_method = task.get("duration_calculation_method", "fixed_duration")
    method_display = DURATION_METHODS.get(current_method, current_method)
    
    selected_display = st.selectbox(
        "M√©thode de calcul *",
        options=list(DURATION_METHODS.values()),
        index=list(DURATION_METHODS.values()).index(method_display),
        key=widget_manager.generate_key("duration_method", "task_table")
    )
    
    # Get method key from display name
    method = next(k for k, v in DURATION_METHODS.items() if v == selected_display)
    task["duration_calculation_method"] = method
    
    # Dynamic fields based on method
    col1, col2 = st.columns(2)
    with col1:
        if method == "fixed_duration":
            task["base_duration"] = st.number_input(
                "Dur√©e fixe (jours) *", 
                value=task.get("base_duration", 1), 
                min_value=1,
                key=widget_manager.generate_key("base_duration", "task_table")
            )
            task["unit_duration"] = 0
        elif method == "quantity_based":
            task["unit_duration"] = st.number_input(
                "Dur√©e par unit√© (jours) *", 
                value=task.get("unit_duration", 1), 
                min_value=1,
                key=widget_manager.generate_key("unit_duration", "task_table")
            )
            task["base_duration"] = 0
        else:  # resource_calculation
            task["base_duration"] = 0
            task["unit_duration"] = 0
            st.info("‚úÖ Dur√©e calcul√©e automatiquement selon les ressources disponibles")
    
    with col2:
        task["min_crews_needed"] = st.number_input(
            "√âquipes minimum *", 
            value=task.get("min_crews_needed", 1), 
            min_value=1,
            key=widget_manager.generate_key("min_crews", "task_table")
        )
        
        task["max_crews_allowed"] = st.number_input(
            "√âquipes maximum", 
            value=task.get("max_crews_allowed", task.get("min_crews_needed", 1)), 
            min_value=task.get("min_crews_needed", 1),
            key=widget_manager.generate_key("max_crews", "task_table")
        )
    
    return task

def _render_resource_selection_section(task: Dict, available_resources: Dict[str, List[Dict]] = None) -> Dict:
    """Resource selection section - workers and equipment from resource templates"""
    st.markdown("### üë•üõ†Ô∏è S√©lection des Ressources")
    
    # Initialize available resources if not provided
    if available_resources is None:
        available_resources = {'workers': [], 'equipment': []}
    
    workers = available_resources.get('workers', [])
    equipment = available_resources.get('equipment', [])
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown("#### üë• Ouvriers Requis")
        
        if not workers:
            st.warning("‚ö†Ô∏è Aucun ouvrier disponible. Configurez d'abord les ouvriers dans le mod√®le de ressources.")
        else:
            # Worker type selection
            worker_options = {f"{w.get('name', '')} ({w.get('specialty', '')})": w for w in workers}
            current_worker_type = task.get('resource_type', '')
            
            # Find matching worker
            selected_worker_key = None
            for key, worker_data in worker_options.items():
                if worker_data.get('name') == current_worker_type or worker_data.get('specialty') == current_worker_type:
                    selected_worker_key = key
                    break
            
            selected_worker = st.selectbox(
                "Type d'ouvrier requis",
                options=[''] + list(worker_options.keys()),
                index=list(worker_options.keys()).index(selected_worker_key) + 1 if selected_worker_key else 0,
                key=widget_manager.generate_key("worker_type_select", "task_table")
            )
            
            if selected_worker and selected_worker in worker_options:
                worker_data = worker_options[selected_worker]
                task["resource_type"] = worker_data.get('specialty', worker_data.get('name'))
    
    with col2:
        st.markdown("#### üõ†Ô∏è √âquipements Requis")
        
        current_equipment = task.get("min_equipment_needed", {})
        
        if not equipment:
            st.warning("‚ö†Ô∏è Aucun √©quipement disponible. Configurez d'abord les √©quipements dans le mod√®le de ressources.")
        else:
            # Convert available equipment to selection options
            equipment_options = {f"{eq.get('name', '')} ({eq.get('code', '')})": eq for eq in equipment}
            
            # Display current equipment with selection
            if current_equipment:
                st.write("**√âquipements configur√©s:**")
                
                equipment_to_remove = []
                for idx, (equip_name, quantity) in enumerate(current_equipment.items()):
                    col1, col2, col3 = st.columns([3, 1, 1])
                    
                    with col1:
                        # Find matching equipment from available options
                        current_equip_key = None
                        for key, eq_data in equipment_options.items():
                            if eq_data.get('name') == equip_name or eq_data.get('code') == equip_name:
                                current_equip_key = key
                                break
                        
                        selected_equip = st.selectbox(
                            f"√âquipement {idx+1}",
                            options=[''] + list(equipment_options.keys()),
                            index=list(equipment_options.keys()).index(current_equip_key) + 1 if current_equip_key else 0,
                            key=widget_manager.generate_key(f"equip_select_{idx}", "task_table")
                        )
                    
                    with col2:
                        if selected_equip:
                            selected_qty = st.number_input(
                                f"Quantit√© {idx+1}",
                                value=int(quantity),
                                min_value=1,
                                key=widget_manager.generate_key(f"equip_qty_{idx}", "task_table")
                            )
                        else:
                            selected_qty = 0
                    
                    with col3:
                        st.text("")  # Spacer
                        if st.checkbox("üóëÔ∏è", key=widget_manager.generate_key(f"remove_equip_{idx}", "task_table")):
                            equipment_to_remove.append(equip_name)
                    
                    # Update equipment
                    if selected_equip and selected_equip in equipment_options:
                        equip_data = equipment_options[selected_equip]
                        equip_code = equip_data.get('code', equip_data.get('name'))
                        if equip_code != equip_name:
                            # Remove old name, add new one
                            current_equipment[equip_code] = selected_qty
                            if equip_name in current_equipment:
                                del current_equipment[equip_name]
                        else:
                            current_equipment[equip_name] = selected_qty
                
                # Remove marked equipment
                for equip_name in equipment_to_remove:
                    if equip_name in current_equipment:
                        del current_equipment[equip_name]
                        st.rerun()
            
            # Add new equipment section
            st.markdown("**Ajouter un √©quipement:**")
            
            col1, col2 = st.columns([3, 1])
            with col1:
                new_equip_select = st.selectbox(
                    "S√©lectionner un √©quipement",
                    options=[''] + list(equipment_options.keys()),
                    key=widget_manager.generate_key("new_equip_select", "task_table")
                )
            with col2:
                new_equip_qty = st.number_input(
                    "Quantit√©",
                    min_value=1,
                    value=1,
                    key=widget_manager.generate_key("new_equip_qty", "task_table")
                )
            
            # Auto-add when equipment is selected (form-safe approach)
            if new_equip_select and new_equip_select in equipment_options:
                equip_data = equipment_options[new_equip_select]
                equip_code = equip_data.get('code', equip_data.get('name'))
                current_equipment[equip_code] = new_equip_qty
                st.success(f"‚úÖ {equip_data.get('name')} ajout√©")
    
    # Resource management instructions
    st.info("""
    üí° **Instructions:**
    - S√©lectionnez le type d'ouvrier requis pour cette t√¢che
    - Pour les √©quipements: s√©lectionnez dans la liste et d√©finissez les quantit√©s
    - Cochez üóëÔ∏è pour supprimer un √©quipement
    - Les ressources doivent √™tre configur√©es dans le mod√®le de ressources
    """)
    
    task["min_equipment_needed"] = current_equipment
    return task

def _render_predecessors_section(task: Dict, all_tasks: List[Dict]) -> Dict:
    """Predecessors management - FIXED for form compatibility"""
    st.markdown("#### üîó Pr√©d√©cesseurs")
    
    predecessors = task.get("predecessors", [])
    available_tasks = [t["base_task_id"] for t in all_tasks 
                      if t.get("base_task_id") != task.get("base_task_id")]
    
    # Use multi-select instead of dynamic buttons
    selected_predecessors = st.multiselect(
        "S√©lectionnez les pr√©d√©cesseurs:",
        options=available_tasks,
        default=predecessors,
        key=widget_manager.generate_key("predecessors_multiselect", "task_table"),
        help="Maintenez Ctrl (Cmd sur Mac) pour s√©lectionner plusieurs t√¢ches"
    )
    
    # Show current selection
    if selected_predecessors:
        st.write("**Pr√©d√©cesseurs s√©lectionn√©s:**")
        for pred in selected_predecessors:
            st.write(f"‚Ä¢ {pred}")
    else:
        st.info("Aucun pr√©d√©cesseur s√©lectionn√©")
    
    task["predecessors"] = selected_predecessors
    return task

def _render_options_section(task: Dict) -> Dict:
    """Task options - SIMPLIFIED layout"""
    st.markdown("### ‚öôÔ∏è Options de T√¢che")
    
    col1, col2 = st.columns(2)
    with col1:
        task["repeat_on_floor"] = st.checkbox(
            "R√©p√©ter par √©tage",
            value=task.get("repeat_on_floor", False),
            key=widget_manager.generate_key("repeat_floor", "task_table")
        )
        task["weather_sensitive"] = st.checkbox(
            "Sensible √† la m√©t√©o",
            value=task.get("weather_sensitive", False),
            key=widget_manager.generate_key("weather_sensitive", "task_table")
        )
    
    with col2:
        task["quality_gate"] = st.checkbox(
            "Point de contr√¥le qualit√©", 
            value=task.get("quality_gate", False),
            key=widget_manager.generate_key("quality_gate", "task_table")
        )
        task["included"] = st.checkbox(
            "Inclure dans le planning",
            value=task.get("included", True),
            key=widget_manager.generate_key("included", "task_table")
        )
    
    return task


def _save_table_changes(edited_df: pd.DataFrame, tasks: List[Dict]):
    """Save changes from data editor"""
    st.info("Fonctionnalit√© de sauvegarde en ligne √† impl√©menter")

def _validate_task(task: Dict, all_tasks: List[Dict], mode: str) -> bool:
    """Essential validation"""
    errors = []
    
    if not task.get("name", "").strip():
        errors.append("Le nom de la t√¢che est obligatoire")
    if not task.get("discipline", "").strip():
        errors.append("La discipline est obligatoire")
    if not task.get("sub_discipline", "").strip():
        errors.append("La sous-discipline est obligatoire")
    
    method = task.get("duration_calculation_method", "fixed_duration")
    if method == "fixed_duration" and task.get("base_duration", 0) <= 0:
        errors.append("La dur√©e fixe doit √™tre positive")
    elif method == "quantity_based" and task.get("unit_duration", 0) <= 0:
        errors.append("La dur√©e unitaire doit √™tre positive")
    
    if task.get("min_crews_needed", 0) <= 0:
        errors.append("Le nombre d'√©quipes doit √™tre positif")
    
    if mode == "new":
        existing_names = [t.get("name", "").lower() for t in all_tasks]
        if task.get("name", "").lower() in existing_names:
            errors.append("Une t√¢che avec ce nom existe d√©j√†")
    
    for error in errors:
        st.error(f"‚ùå {error}")
    
    return len(errors) == 0

def _save_task(task: Dict, tasks: List[Dict], task_service, user_id: int, mode: str):
    """Save task via service layer"""
    try:
        if mode == 'edit':
            # Use the task ID from the original task being edited
            result = task_service.update_custom_task(user_id, task.get('id'), task)
            if result:
                # Update local list
                for i, t in enumerate(tasks):
                    if t.get('id') == task.get('id'):
                        tasks[i] = result
                        break
                st.success("‚úÖ T√¢che modifi√©e avec succ√®s!")
            else:
                st.error("‚ùå Erreur lors de la modification")
                
        elif mode == 'new':
            # Create new task - service will generate ID
            result = task_service.create_custom_task(user_id, task)
            if result:
                tasks.append(result)
                st.success(f"‚úÖ T√¢che cr√©√©e: {result.get('base_task_id')}")
            else:
                st.error("‚ùå Erreur lors de la cr√©ation")
            
        elif mode == 'duplicate':
            # Create duplicate - service will generate new ID
            duplicate_task = task.copy()
            duplicate_task['base_task_id'] = None  # Let service generate new ID
            result = task_service.create_custom_task(user_id, duplicate_task)
            if result:
                tasks.append(result)
                st.success(f"‚úÖ T√¢che dupliqu√©e: {result.get('base_task_id')}")
            else:
                st.error("‚ùå Erreur lors de la duplication")
        
        # Clear form state
        st.session_state.task_form_state = {'mode': None, 'current_task': None}
        
    except Exception as e:
        logger.error(f"Error saving task: {e}")
        st.error(f"‚ùå Erreur: {e}")

def _delete_task(task: Dict, tasks: List[Dict], task_service, user_id: int):
    """Delete task with confirmation"""
    task_id = task.get('base_task_id')
    task_name = task.get('name')
    
    st.warning(f"√ätes-vous s√ªr de vouloir supprimer '{task_name}'?")
    col1, col2 = st.columns(2)
    
    with col1:
        if st.button("‚úÖ Confirmer", key=widget_manager.generate_key("confirm_delete", "task_table")):
            try:
                # Call service to delete
                success = task_service.delete_custom_task(user_id, task.get('id'))
                if success:
                    # Remove from local list
                    tasks[:] = [t for t in tasks if t.get('base_task_id') != task_id]
                    st.success(f"‚úÖ T√¢che supprim√©e: {task_id}")
                else:
                    st.error("‚ùå Erreur lors de la suppression")
            except Exception as e:
                logger.error(f"Error deleting task: {e}")
                st.error(f"‚ùå Erreur: {e}")
    
    with col2:
        if st.button("‚ùå Annuler", key=widget_manager.generate_key("cancel_delete", "task_table")):
            st.info("Suppression annul√©e")

def _get_default_task_template() -> Dict:
    """Default task template"""
    return {
        "base_task_id": "", "name": "", "discipline": "", "sub_discipline": "",
        "resource_type": "", "task_type": "hybrid", "base_duration": 1,
        "unit_duration": 0, "duration_calculation_method": "fixed_duration",
        "min_crews_needed": 1, "max_crews_allowed": 1, "delay": 0,
        "min_equipment_needed": {}, "max_equipment_allowed": {},
        "predecessors": [], "repeat_on_floor": False, "weather_sensitive": False,
        "quality_gate": False, "included": True
    }

# ====== End of frontend/components/data_tables/task_table.py ======



# ====== Begin of frontend/components/data_tables/worker_table.py ======

"""
PROFESSIONAL Worker Table Component - Civil Engineering Scheduling
UPDATED with essential template context integration
"""
import streamlit as st
import pandas as pd
import logging
from typing import List, Dict, Optional, Any
from backend.utils.widget_manager import widget_manager

# Import template context
from frontend.helpers.template_context import template_context

logger = logging.getLogger(__name__)

# French column mapping for workers
FRENCH_COLUMNS = {
    "code": "Code", "name": "Nom", "specialty": "Sp√©cialit√©", "category": "Cat√©gorie",
    "base_count": "Effectif Base", "hourly_rate": "Taux Horaire", "daily_rate": "Taux Journalier",
    "max_workers_per_crew": "Max par √âquipe", "base_productivity_rate": "Taux Productivit√© Base",
    "productivity_unit": "Unit√© Productivit√©", "qualification_level": "Niveau Qualification",
    "is_active": "Actif"
}

def render_workers_table(workers: List[Dict], resource_service, user_id: int, available_templates: List[Dict], 
                        template_id: Optional[int] = None, current_template_name: str = "", task_template_context: Dict = None, template_service=None):
    """Render worker resources table with context awareness"""
    # Initialize state
    if 'worker_form_state' not in st.session_state:
        st.session_state.worker_form_state = {'mode': None, 'current_worker': None}
        
    
    # Check if context is available - use new context system first, fallback to old parameter
    current_task_template = template_context.task_template if template_context.is_ready() else task_template_context
     
    if not template_context.is_ready() and not task_template_context:
        st.error("üö´ Contexte de travail non d√©fini. Veuillez s√©lectionner un mod√®le de ressources ET un mod√®le de t√¢ches.")
        return
    
    # Show context status
    if template_context.is_ready():
        resource = template_context.resource_template
        task = template_context.task_template
        st.success(f"üéØ Contexte Actif: {resource['name']} + {task.get('name', 'Sans nom')}")
    elif task_template_context:
        st.info(f"üìù Contexte T√¢ches: {task_template_context.get('name', 'Sans nom')}")

    # Template-level actions section
    _render_template_actions(resource_service, user_id, available_templates, template_id, current_template_name)
    
    state = st.session_state.worker_form_state
    
    # Apply filters FIRST to get filtered_workers
    filtered_workers = _render_worker_filters(workers)
    
    # Render statistics
    _render_worker_statistics(workers, filtered_workers)
    
    # Render active form if needed
    if state['mode']:
        _render_worker_form(state, workers, resource_service, user_id, available_templates, 
                          template_id, current_task_template)
        return
    # Main table interface
    _render_worker_table_interface(filtered_workers, resource_service, user_id, available_templates, template_id)


def _render_template_actions(resource_service, user_id: int, available_templates: List[Dict], template_id: Optional[int] = None, current_template_name: str = ""):
    """Render template-level action buttons"""
    st.markdown("### üîß Actions au Niveau Mod√®le")
    
    # Display current template info if available
    if template_id and current_template_name:
        st.info(f"**Mod√®le actuel:** {current_template_name} (ID: {template_id})")
    
    # Template action buttons
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        if st.button("üíæ Sauvegarder Mod√®le", use_container_width=True,
                    key=widget_manager.generate_key("save_template_btn", "worker_table")):
            _save_resource_template(resource_service, user_id, template_id, available_templates)
    
    with col2:
        if st.button("‚ûï Nouveau Mod√®le", use_container_width=True,
                    key=widget_manager.generate_key("new_template_btn", "worker_table")):
            _create_new_template(resource_service, user_id)
    
    with col3:
        if st.button("üì• Charger D√©faut", use_container_width=True,
                    key=widget_manager.generate_key("load_default_btn", "worker_table")):
            _load_default_resources(resource_service, user_id)
    
    with col4:
        if st.button("üîÑ Actualiser", use_container_width=True,
                    key=widget_manager.generate_key("refresh_btn", "worker_table")):
            st.rerun()
    
    st.markdown("---")

def _save_resource_template(resource_service, user_id: int, template_id: Optional[int], available_templates: List[Dict]):
    """Save the current resource template"""
    try:
        if not template_id:
            st.error("‚ùå Aucun mod√®le s√©lectionn√© pour sauvegarde")
            return
        
        # Find template name
        template_name = next((t['name'] for t in available_templates if t['id'] == template_id), "Mod√®le Inconnu")
        
        # In a real implementation, this would save all workers and equipment in the template
        st.success(f"‚úÖ Mod√®le '{template_name}' sauvegard√© avec succ√®s!")
        
        # Show statistics
        workers = resource_service.get_user_workers(user_id, template_id)
        equipment = resource_service.get_user_equipment(user_id, template_id)
        
        st.info(f"üìä Mod√®le contient: {len(workers)} ouvriers et {len(equipment)} √©quipements")
        
    except Exception as e:
        st.error(f"‚ùå Erreur lors de la sauvegarde du mod√®le: {e}")
        logger.error(f"Error saving template: {e}")

def _create_new_template(resource_service, user_id: int):
    """Create a new resource template"""
    try:
        # Generate unique template name
        template_count = len(resource_service.get_user_resource_templates(user_id))
        new_template_name = f"Nouveau Mod√®le {template_count + 1}"
        
        template_data = {
            'name': new_template_name,
            'description': 'Nouveau mod√®le de ressources cr√©√© automatiquement',
            'category': 'Custom',
            'user_id': user_id
        }
        
        new_template = resource_service.create_resource_template(user_id, template_data)
        
        if new_template:
            st.success(f"‚úÖ Nouveau mod√®le cr√©√©: {new_template_name}")
            st.rerun()
        else:
            st.error("‚ùå Erreur lors de la cr√©ation du mod√®le")
            
    except Exception as e:
        st.error(f"‚ùå Erreur lors de la cr√©ation du mod√®le: {e}")
        logger.error(f"Error creating template: {e}")

def _load_default_resources(resource_service, user_id: int):
    """Load default resources"""
    try:
        with st.spinner("üì• Chargement des ressources par d√©faut..."):
            loaded_resources = resource_service.load_default_resources(user_id)
            
            if loaded_resources:
                st.success(f"‚úÖ {len(loaded_resources)} ressources par d√©faut charg√©es avec succ√®s!")
                st.rerun()
            else:
                st.error("‚ùå Erreur lors du chargement des ressources par d√©faut")
                
    except Exception as e:
        st.error(f"‚ùå Erreur lors du chargement des ressources: {e}")
        logger.error(f"Error loading default resources: {e}")

def _render_worker_statistics(all_workers: List[Dict], filtered_workers: List[Dict]):
    """Render worker statistics"""
    total_count = len(all_workers)
    filtered_count = len(filtered_workers)
    
    total_active = len([w for w in all_workers if w.get('is_active', True)])
    filtered_active = len([w for w in filtered_workers if w.get('is_active', True)])
    
    total_specialties = len(set(w.get('specialty', '') for w in all_workers))
    filtered_specialties = len(set(w.get('specialty', '') for w in filtered_workers))
    
    # Context-aware metrics
    context_match_count = 0
    if template_context.is_ready():
        required_specialty = template_context.task_template.get('resource_type')
        context_match_count = len([w for w in filtered_workers if w.get('specialty') == required_specialty])
    
    # Display statistics
    col1, col2, col3, col4, col5 = st.columns(5)
    
    with col1:
        st.metric("üë• Ouvriers", f"{filtered_count}/{total_count}")
    
    with col2:
        st.metric("‚úÖ Actifs", f"{filtered_active}/{total_active}")
    
    with col3:
        st.metric("üéØ Sp√©cialit√©s", f"{filtered_specialties}/{total_specialties}")
    
    with col4:
        filters_active = filtered_count != total_count
        status = "üîç Filtres Actifs" if filters_active else "üëÅÔ∏è Tous Visible"
        st.metric("Statut", status)
    
    with col5:
        if template_context.is_ready():
            st.metric("üîó Contexte", context_match_count)
        else:
            st.metric("üîó Contexte", "N/A")

def _render_worker_filters(workers: List[Dict]) -> List[Dict]:
    """Render worker filters"""
    if not workers:
        return []
    
    # Get unique values for filters
    specialties = sorted(list(set(w.get('specialty', '') for w in workers if w.get('specialty'))))
    categories = sorted(list(set(w.get('category', '') for w in workers if w.get('category'))))
    
    st.markdown("### üîç Filtres Ouvriers")
    
    col1, col2, col3 = st.columns(3)
    
    with col1:
        selected_specialty = st.selectbox(
            "Sp√©cialit√©",
            options=['Toutes'] + specialties,
            key=widget_manager.generate_key("filter_specialty", "worker_table")
        )
    
    with col2:
        selected_category = st.selectbox(
            "Cat√©gorie",
            options=['Toutes'] + categories,
            key=widget_manager.generate_key("filter_category", "worker_table")
        )
    
    with col3:
        selected_active = st.selectbox(
            "Statut", 
            options=['Tous', 'Actifs', 'Inactifs'],
            key=widget_manager.generate_key("filter_active", "worker_table")
        )
    
    # Apply filters
    filtered_workers = _apply_worker_filters(workers, selected_specialty, selected_category, selected_active)
    
    return filtered_workers

def _apply_worker_filters(workers: List[Dict], specialty: str, category: str, active: str) -> List[Dict]:
    """Apply filters to worker list"""
    filtered = workers
    
    if specialty != 'Toutes':
        filtered = [w for w in filtered if w.get('specialty') == specialty]
    
    if category != 'Toutes':
        filtered = [w for w in filtered if w.get('category') == category]
    
    if active == 'Actifs':
        filtered = [w for w in filtered if w.get('is_active', True)]
    elif active == 'Inactifs':
        filtered = [w for w in filtered if not w.get('is_active', True)]
    
    return filtered

def _render_worker_table_interface(workers: List[Dict], resource_service, user_id: int, available_templates: List[Dict], template_id: Optional[int] = None,template_service=None):
    """Render worker table interface"""
    
    # Worker selection
    selected_worker = _render_worker_selection(workers)
    
    # Action buttons
    col1, col2, col3, col4 = st.columns([2, 1, 1, 1])
    
    with col1:
        if st.button("‚ûï Nouvel Ouvrier", use_container_width=True,
                    key=widget_manager.generate_key("new_worker_btn", "worker_table")):
            st.session_state.worker_form_state = {'mode': 'new', 'current_worker': None}
            st.rerun()
    
    with col2:
        disabled = selected_worker is None
        if st.button("‚úèÔ∏è Modifier", use_container_width=True, disabled=disabled,
                    key=widget_manager.generate_key("edit_worker_btn", "worker_table")):
            st.session_state.worker_form_state = {'mode': 'edit', 'current_worker': selected_worker}
            st.rerun()
    
    with col3:
        if st.button("üìã Dupliquer", use_container_width=True, disabled=disabled,
                    key=widget_manager.generate_key("duplicate_worker_btn", "worker_table")):
            st.session_state.worker_form_state = {'mode': 'duplicate', 'current_worker': selected_worker}
            st.rerun()
    
    with col4:
        if st.button("üóëÔ∏è Supprimer", use_container_width=True, disabled=disabled,
                    key=widget_manager.generate_key("delete_worker_btn", "worker_table")):
            _delete_worker(selected_worker, workers, resource_service, user_id)
            st.rerun()
    
    # Context-aware actions for selected worker
    if template_context.is_ready() and selected_worker:
        st.markdown("---")
        col1, col2 = st.columns(2)
        with col1:
            if st.button("üîç Tester Compatibilit√©", use_container_width=True,
                        key=widget_manager.generate_key("test_compatibility", "worker_table")):
                _test_worker_compatibility(selected_worker, template_service=template_service)
        with col2:
            if st.button("üìà Analyser Productivit√©", use_container_width=True,
                        key=widget_manager.generate_key("analyze_productivity", "worker_table")):
                _analyze_worker_productivity(selected_worker)
    
    # Data table
    _render_worker_data_table(workers)

def _test_worker_compatibility(worker: Dict, template_service=None):
    """Test worker compatibility with current context"""
    try:
        if template_service is None:
            st.error("‚ùå Service de template non disponible")
            return
        
        # Create a mock task template for this worker's specialty
        mock_task_template = {
            'resource_type': worker.get('specialty'),
            'name': f"Test pour {worker.get('name')}",
            'base_task_id': f"TEST_{worker.get('code')}"
        }
        
        validation = template_service.validate_template_compatibility(
            template_context.resource_template,
            mock_task_template
        )
        
        if validation.get('compatible', False):
            st.success(f"‚úÖ '{worker['name']}' compatible avec le contexte")
        else:
            st.error(f"‚ùå Probl√®mes de compatibilit√© pour '{worker['name']}'")
        
        # Show specific issues
        if validation.get('issues'):
            st.write("**Probl√®mes identifi√©s:**")
            for issue in validation['issues']:
                st.write(f"- {issue}")
                
    except Exception as e:
        st.error(f"‚ùå Erreur lors du test de compatibilit√©: {e}")

def _analyze_worker_productivity(worker: Dict):
    """Analyze worker productivity for current context"""
    try:
        st.info(f"üìä Analyse de productivit√© pour: {worker['name']}")
        
        # Get productivity rates
        productivity_rates = worker.get('base_productivity_rate', {})
        if isinstance(productivity_rates, dict):
            default_rate = productivity_rates.get('default', 1.0)
            
            # Simple productivity analysis
            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric("Taux D√©faut", f"{default_rate:.2f}")
            with col2:
                st.metric("Effectif Base", worker.get('base_count', 1))
            with col3:
                st.metric("Max/√âquipe", worker.get('max_workers_per_crew', 1))
            
            # Recommendations
            if default_rate < 0.5:
                st.warning("üí° Taux de productivit√© faible - envisager une formation")
            elif default_rate > 2.0:
                st.success("üí° Taux de productivit√© √©lev√© - excellent!")
                
        else:
            st.warning("‚ö†Ô∏è Configuration de productivit√© non standard")
            
    except Exception as e:
        st.error(f"‚ùå Erreur d'analyse: {e}")

def _render_worker_selection(workers: List[Dict]) -> Optional[Dict]:
    """Render worker selection dropdown"""
    if not workers:
        st.info("üì≠ Aucun ouvrier disponible")
        return None
        
    worker_options = {f"{w.get('name', 'Sans nom')} ({w.get('code', 'N/A')})": w for w in workers}
    
    selected_label = st.selectbox(
        "S√©lectionner un ouvrier:",
        options=[''] + list(worker_options.keys()),
        key=widget_manager.generate_key("worker_selector", "worker_table")
    )
    
    if selected_label and selected_label in worker_options:
        st.success(f"‚úÖ Ouvrier s√©lectionn√©: {selected_label}")
        return worker_options[selected_label]
    
    st.info("üëÜ S√©lectionnez un ouvrier pour voir les actions disponibles")
    return None

def _render_worker_data_table(workers: List[Dict]):
    """Render worker data table"""
    if not workers:
        st.info("üì≠ Aucun ouvrier √† afficher")
        return
    
    # Convert to DataFrame
    df = _workers_to_dataframe(workers)
    
    # Display data editor
    edited_df = st.data_editor(
        df,
        use_container_width=True,
        hide_index=True,
        column_config={
            "Actif": st.column_config.CheckboxColumn("Actif"),
            "Taux Horaire": st.column_config.NumberColumn("Taux Horaire (‚Ç¨)", format="%.2f ‚Ç¨"),
            "Effectif Base": st.column_config.NumberColumn("Effectif Base", min_value=0),
            "Max par √âquipe": st.column_config.NumberColumn("Max par √âquipe", min_value=1)
        },
        key=widget_manager.generate_key("worker_data_editor", "worker_table")
    )
    
    # Save changes
    if st.button("üíæ Sauvegarder Modifications", use_container_width=True,
                key=widget_manager.generate_key("save_worker_table_btn", "worker_table")):
        _save_worker_table_changes(edited_df, workers)

def _render_worker_form(state: Dict, all_workers: List[Dict], resource_service, user_id: int, 
                       available_templates: List[Dict], template_id: Optional[int] = None, 
                       task_template_context: Dict = None):
    """Render worker form for create/edit/duplicate with task template context"""
    mode = state['mode']
    worker = state['current_worker']
    
    # Display current context if available
    if template_context.is_ready():
        st.markdown(f"""
        <div style="background: #fff3cd; padding: 10px; border-radius: 5px; margin-bottom: 20px;">
            <small>üìù Contexte: <strong>{template_context.resource_template['name']}</strong> + 
            <strong>{template_context.task_template.get('name', 'Sans nom')}</strong></small>
        </div>
        """, unsafe_allow_html=True)
    elif task_template_context:
        st.markdown(f"""
        <div style="background: #fff3cd; padding: 10px; border-radius: 5px; margin-bottom: 20px;">
            <small>üìù Contexte T√¢ches: <strong>{task_template_context.get('name', 'Sans nom')}</strong></small>
        </div>
        """, unsafe_allow_html=True)
    
    st.markdown("---")
    
    if mode == 'edit':
        title = f"‚úèÔ∏è Modification: {worker.get('name')}"
        submit_label = "üíæ Sauvegarder"
    elif mode == 'duplicate':
        title = "üìã Duplication d'Ouvrier"
        submit_label = "‚úÖ Cr√©er Copie"
        worker = worker.copy() if worker else None
    else:  # new
        title = "‚ûï Nouvel Ouvrier"
        submit_label = "‚ûï Cr√©er Ouvrier"
        worker = _get_default_worker_template()
    
    st.subheader(title)
    
    # Use a proper form with submit button
    with st.form(key=widget_manager.generate_key("worker_form", "worker_table")):
        # Basic Information
        worker = _render_worker_basic_info_section(worker, mode, available_templates, template_id)
        
        # Rates and Productivity - with task template context
        current_task_context = template_context.task_template if template_context.is_ready() else task_template_context
        worker = _render_worker_rates_section(worker, current_task_context)
        
        # Skills and Certifications
        worker = _render_worker_skills_section(worker)
        
        st.markdown("---")
        
        # Form Actions
        col1, col2 = st.columns(2)
        
        with col1:
            submit_clicked = st.form_submit_button(
                submit_label, 
                use_container_width=True,
                type="primary"
            )
        
        with col2:
            cancel_clicked = st.form_submit_button(
                "‚ùå Annuler", 
                use_container_width=True,
                type="secondary"
            )
        
        # Handle form submissions
        if submit_clicked:
            if _validate_worker(worker, all_workers, mode):
                _save_worker(worker, all_workers, resource_service, user_id, template_id, mode)
        
        if cancel_clicked:
            st.session_state.worker_form_state = {'mode': None, 'current_worker': None}
            st.rerun()
    
    # Productivity testing button (outside the form to avoid conflicts)
    if mode == 'edit' and worker.get('base_productivity_rate'):
        st.markdown("---")
        col1, col2 = st.columns([3, 1])
        with col2:
            if st.button("üß™ Tester Productivit√©", use_container_width=True, type="secondary"):
                _test_worker_productivity(worker, resource_service, current_task_context)

def _test_worker_productivity(worker: Dict, resource_service, task_template_context: Dict = None):
    """
    Professional productivity testing tool for construction workers
    """
    try:
        st.markdown("### üß™ Test des Taux de Productivit√©")
        
        # Get productivity rates with proper dict handling
        productivity_rates = worker.get("base_productivity_rate", {})
        
        # Handle legacy format (single float value)
        if isinstance(productivity_rates, (int, float)):
            productivity_rates = {"default": float(productivity_rates)}
            st.info("‚ÑπÔ∏è Format de productivit√© mis √† jour vers le nouveau format dictionnaire")
        
        if not productivity_rates:
            st.warning("‚ö†Ô∏è Aucun taux de productivit√© d√©fini pour cet ouvrier")
            st.info("üí° Ajoutez des taux de productivit√© dans la section 'Tarifs et Productivit√©'")
            return
        
        # Display current productivity configuration
        st.markdown("#### üìä Configuration Actuelle")
        
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("üë• Effectif Base", worker.get("base_count", 1))
        with col2:
            st.metric("üë∑ Max/√âquipe", worker.get("max_workers_per_crew", 1))
        with col3:
            st.metric("üì¶ Unit√©", worker.get("productivity_unit", "unit√©s/jour"))
        
        # Display productivity rates in a professional table
        st.markdown("#### üéØ Taux de Productivit√© par T√¢che")
        
        if productivity_rates:
            import pandas as pd
            productivity_data = []
            for task_id, rate in productivity_rates.items():
                task_display = "D√©faut" if task_id == "default" else task_id
                productivity_data.append({
                    "T√¢che": task_display,
                    "Taux": f"{rate:.2f}",
                })
            
            df = pd.DataFrame(productivity_data)
            st.dataframe(df, use_container_width=True, hide_index=True)
        else:
            st.warning("Aucun taux de productivit√© configur√©")
            return
        
        # Productivity Simulation Interface
        st.markdown("#### üî¨ Simulation de Productivit√©")
        
        # Simulation parameters
        col1, col2, col3 = st.columns(3)
        
        with col1:
            simulation_hours = st.number_input(
                "Heures de travail:",
                value=8,
                min_value=1,
                max_value=24,
                help="Dur√©e de la simulation en heures"
            )
        
        with col2:
            simulation_workers = st.number_input(
                "Nombre d'ouvriers:",
                value=min(worker.get("base_count", 1), worker.get("max_workers_per_crew", 1)),
                min_value=1,
                max_value=worker.get("max_workers_per_crew", 10),
                help="Nombre d'ouvriers pour la simulation"
            )
        
        with col3:
            selected_task = st.selectbox(
                "T√¢che √† simuler:",
                options=list(productivity_rates.keys()),
                format_func=lambda x: "Taux par d√©faut" if x == "default" else f"T√¢che {x}",
                help="S√©lectionnez la t√¢che √† tester"
            )
        
        # Calculate and display results
        if selected_task:
            base_rate = productivity_rates[selected_task]
            
            # Professional calculation
            hourly_productivity = base_rate / 8.0  # Convert daily rate to hourly
            total_productivity = hourly_productivity * simulation_hours * simulation_workers
            
            st.markdown("#### üìà R√©sultats de la Simulation")
            
            # Results in a nice layout
            result_col1, result_col2, result_col3 = st.columns(3)
            
            with result_col1:
                st.metric(
                    "Productivit√© Horaire", 
                    f"{hourly_productivity:.2f}",
                    help="Productivit√© par ouvrier par heure"
                )
            
            with result_col2:
                st.metric(
                    "Productivit√© Totale", 
                    f"{total_productivity:.2f}",
                    help=f"Production totale pour {simulation_workers} ouvrier(s) pendant {simulation_hours}h"
                )
            
            with result_col3:
                efficiency = (total_productivity / (base_rate * simulation_workers)) * 100
                st.metric(
                    "Efficacit√©", 
                    f"{efficiency:.1f}%",
                    help="Efficacit√© par rapport √† une journ√©e standard"
                )
            
            # Detailed breakdown
            with st.expander("üìã D√©tail des Calculs", expanded=False):
                st.markdown(f"""
                **Formule de calcul:**
                ```
                Productivit√© Horaire = Taux Journalier / 8 heures
                Productivit√© Totale = Productivit√© Horaire √ó Heures √ó Ouvriers
                ```
                
                **Application:**
                - Taux de base ({selected_task}): **{base_rate:.2f}** {worker.get('productivity_unit', 'unit√©s')}/jour
                - Productivit√© horaire: **{base_rate:.2f} / 8 = {hourly_productivity:.2f}** {worker.get('productivity_unit', 'unit√©s')}/heure
                - Production totale: **{hourly_productivity:.2f} √ó {simulation_hours}h √ó {simulation_workers} ouvrier(s) = {total_productivity:.2f}** {worker.get('productivity_unit', 'unit√©s')}
                """)
            
            # Professional recommendations
            st.markdown("#### üí° Recommandations Professionnelles")
            
            if base_rate < 0.5:
                st.warning("**Taux tr√®s bas** - Cela peut entra√Æner des d√©lais prolong√©s. V√©rifiez la coh√©rence avec les standards du m√©tier.")
            elif base_rate > 10.0:
                st.warning("**Taux tr√®s √©lev√©** - Assurez-vous que ce taux est r√©aliste pour le type de travail.")
            else:
                st.success("**Taux dans la plage standard** - Configuration coh√©rente.")
            
            # Efficiency analysis
            if efficiency < 80:
                st.info("**Optimisation possible** - Consid√©rez ajuster les effectifs ou am√©liorer les processus.")
            elif efficiency > 120:
                st.info("**Performance excellente** - Ce taux repr√©sente une productivit√© sup√©rieure √† la moyenne.")
            
    except Exception as e:
        st.error(f"‚ùå Erreur lors du test de productivit√©: {str(e)}")
        logger.error(f"Productivity test error: {e}")

def _render_worker_basic_info_section(worker: Dict, mode: str, available_templates: List[Dict], template_id: Optional[int] = None) -> Dict:
    """Render worker basic information section with IMPROVED template selection"""
    st.markdown("### üìù Informations de Base")
    
    col1, col2 = st.columns(2)
    with col1:
        worker["name"] = st.text_input(
            "Nom de l'ouvrier *", 
            value=worker.get("name", ""),
            key=widget_manager.generate_key("worker_name", "worker_table")
        )
        worker["code"] = st.text_input(
            "Code *", 
            value=worker.get("code", ""),
            key=widget_manager.generate_key("worker_code", "worker_table")
        )
        
    with col2:
        # IMPROVED Template selection with better validation
        if available_templates:
            template_options = {f"{t['name']} (ID: {t['id']})": t['id'] for t in available_templates}
            
            # Set default template if provided
            if template_id and not worker.get("template_id"):
                worker["template_id"] = template_id
            
            current_template_id = worker.get("template_id")
            
            # Find current template display name
            current_template_display = None
            if current_template_id:
                for template in available_templates:
                    if template['id'] == current_template_id:
                        current_template_display = f"{template['name']} (ID: {template['id']})"
                        break
            
            selected_template_display = st.selectbox(
                "Mod√®le de ressources *",
                options=[''] + list(template_options.keys()),
                index=list(template_options.keys()).index(current_template_display) + 1 if current_template_display else 0,
                key=widget_manager.generate_key("worker_template", "worker_table"),
                help="S√©lectionnez le mod√®le auquel cet ouvrier appartient"
            )
            
            if selected_template_display and selected_template_display in template_options:
                worker["template_id"] = template_options[selected_template_display]
            elif not worker.get("template_id"):
                st.error("‚ùå Veuillez s√©lectionner un mod√®le de ressources")
        else:
            st.error("‚ùå Aucun mod√®le de ressources disponible. Cr√©ez d'abord un mod√®le.")
        
        worker["specialty"] = st.text_input(
            "Sp√©cialit√© *", 
            value=worker.get("specialty", ""),
            key=widget_manager.generate_key("worker_specialty", "worker_table")
        )
    
    
    col3, col4 = st.columns(2)
    with col3:
        worker["category"] = st.selectbox(
            "Cat√©gorie *",
            options=["Ouvrier", "Technicien", "Ing√©nieur", "Superviseur"],
            index=["Ouvrier", "Technicien", "Ing√©nieur", "Superviseur"].index(worker.get("category", "Ouvrier")),
            key=widget_manager.generate_key("worker_category", "worker_table")
        )
    
    with col4:
        worker["qualification_level"] = st.selectbox(
            "Niveau de qualification *",
            options=["Standard", "Qualifi√©", "Hautement Qualifi√©", "Expert"],
            index=["Standard", "Qualifi√©", "Hautement Qualifi√©", "Expert"].index(worker.get("qualification_level", "Standard")),
            key=widget_manager.generate_key("worker_qualification", "worker_table")
        )
    
    worker["base_count"] = st.number_input(
        "Effectif de base *", 
        value=worker.get("base_count", 1), 
        min_value=1,
        key=widget_manager.generate_key("worker_base_count", "worker_table")
    )
    
    worker["description"] = st.text_area(
        "Description",
        value=worker.get("description", ""),
        key=widget_manager.generate_key("worker_description", "worker_table")
    )
    
    return worker

def _render_worker_rates_section(worker: Dict, task_template_context: Dict = None) -> Dict:
    """Render worker rates and productivity section with task template context"""
    st.markdown("### üí∞ Tarifs et Productivit√©")
    
    col1, col2 = st.columns(2)
    with col1:
        worker["hourly_rate"] = st.number_input(
            "Taux horaire (‚Ç¨) *", 
            value=worker.get("hourly_rate", 0.0), 
            min_value=0.0,
            step=1.0,
            key=widget_manager.generate_key("worker_hourly_rate", "worker_table")
        )
        worker["daily_rate"] = st.number_input(
            "Taux journalier (‚Ç¨)", 
            value=worker.get("daily_rate", 0.0), 
            min_value=0.0,
            step=1.0,
            key=widget_manager.generate_key("worker_daily_rate", "worker_table")
        )
    
    with col2:
        worker["max_workers_per_crew"] = st.number_input(
            "Maximum par √©quipe *", 
            value=worker.get("max_workers_per_crew", 1), 
            min_value=1,
            key=widget_manager.generate_key("worker_max_crew", "worker_table")
        )
        
        # Use unit from task template context if available
        default_unit = task_template_context.get('unit', 'unit√©s/jour') if task_template_context else 'unit√©s/jour'
        worker["productivity_unit"] = st.text_input(
            "Unit√© de productivit√© par d√©faut *", 
            value=worker.get("productivity_unit", default_unit),
            key=widget_manager.generate_key("worker_productivity_unit", "worker_table")
        )
    
    # Task-specific productivity rates section
    st.markdown("#### üéØ Taux de Productivit√© par T√¢che")
    
    if task_template_context:
        st.info(f"Taux pour le mod√®le: **{task_template_context.get('name', 'Sans nom')}**")
    
    # Initialize productivity rates as dict if not already
    if "base_productivity_rate" not in worker or not isinstance(worker["base_productivity_rate"], dict):
        worker["base_productivity_rate"] = {}
    
    productivity_rates = worker["base_productivity_rate"]
    
    # Display existing task productivity rates
    if productivity_rates:
        st.markdown("**Taux existants:**")
        
        tasks_to_remove = []
        
        for task_id, rate in list(productivity_rates.items()):
            if task_id == "default":
                continue  # Skip default for now
                
            col1, col2, col3, col4 = st.columns([3, 2, 2, 1])
            
            with col1:
                st.text_input(
                    "T√¢che",
                    value=f"{task_id}",
                    key=f"task_display_{task_id}",
                    disabled=True,
                    label_visibility="collapsed"
                )
            
            with col2:
                new_rate = st.number_input(
                    f"Taux",
                    value=float(rate),
                    min_value=0.1,
                    step=0.1,
                    key=f"rate_edit_{task_id}",
                    label_visibility="collapsed"
                )
                if new_rate != rate:
                    productivity_rates[task_id] = new_rate
            
            with col3:
                st.text_input(
                    "Unit√©",
                    value=worker.get("productivity_unit", "unit√©s/jour"),
                    key=f"unit_display_{task_id}",
                    disabled=True,
                    label_visibility="collapsed"
                )
            
            with col4:
                if st.button("üóëÔ∏è", key=f"remove_{task_id}", use_container_width=True):
                    tasks_to_remove.append(task_id)
        
        # Remove tasks marked for deletion
        for task_id in tasks_to_remove:
            if task_id in productivity_rates:
                del productivity_rates[task_id]
                st.rerun()
    
    # Add new task productivity rate section
    st.markdown("---")
    st.markdown("**Ajouter un nouveau taux:**")
    
    col1, col2, col3 = st.columns([3, 2, 1])
    
    with col1:
        new_task_id = st.text_input(
            "ID de la t√¢che",
            placeholder="Ex: TACHE-001",
            key=widget_manager.generate_key("new_task_id", "worker_table")
        )
    
    with col2:
        new_rate = st.number_input(
            "Taux de productivit√©",
            value=1.0,
            min_value=0.1,
            step=0.1,
            key=widget_manager.generate_key("new_rate_input", "worker_table")
        )
    
    with col3:
        st.markdown("<br>", unsafe_allow_html=True)
        add_clicked = st.button(
            "‚ûï Ajouter",
            key=widget_manager.generate_key("add_productivity_rate", "worker_table"),
            use_container_width=True
        )
    
    # Handle adding new productivity rate
    if add_clicked and new_task_id.strip():
        if new_task_id in productivity_rates:
            st.error(f"‚ùå Un taux existe d√©j√† pour la t√¢che {new_task_id}")
        else:
            productivity_rates[new_task_id] = float(new_rate)
            st.success(f"‚úÖ Taux ajout√© pour {new_task_id}")
            st.rerun()
    
    # Default productivity rate
    st.markdown("---")
    st.markdown("**Taux par d√©faut:**")
    
    default_rate = productivity_rates.get("default", 1.0)
    new_default_rate = st.number_input(
        f"Taux de productivit√© par d√©faut ({worker.get('productivity_unit', 'unit√©s/jour')}) *",
        value=default_rate,
        min_value=0.1,
        step=0.1,
        key=widget_manager.generate_key("default_productivity_rate", "worker_table"),
        help="Taux utilis√© pour les t√¢ches non sp√©cifi√©es"
    )
    
    if new_default_rate != default_rate:
        productivity_rates["default"] = new_default_rate
    
    # Update the worker dict
    worker["base_productivity_rate"] = productivity_rates
    
    return worker

def _render_worker_skills_section(worker: Dict) -> Dict:
    """Render worker skills and certifications section"""
    st.markdown("### üõ†Ô∏è Comp√©tences et Certifications")
    
    # Skills (comma-separated)
    current_skills = worker.get("skills", [])
    skills_str = ", ".join(current_skills) if isinstance(current_skills, list) else str(current_skills)
    
    new_skills_str = st.text_input(
        "Comp√©tences (s√©par√©es par des virgules)",
        value=skills_str,
        key=widget_manager.generate_key("worker_skills", "worker_table"),
        help="Liste des comp√©tences s√©par√©es par des virgules"
    )
    
    # Process skills input
    if new_skills_str.strip():
        worker["skills"] = [skill.strip() for skill in new_skills_str.split(",") if skill.strip()]
    else:
        worker["skills"] = []
    
    # Certifications (comma-separated)
    current_certs = worker.get("required_certifications", [])
    certs_str = ", ".join(current_certs) if isinstance(current_certs, list) else str(current_certs)
    
    new_certs_str = st.text_input(
        "Certifications requises (s√©par√©es par des virgules)",
        value=certs_str,
        key=widget_manager.generate_key("worker_certifications", "worker_table"),
        help="Liste des certifications requises s√©par√©es par des virgules"
    )
    
    # Process certifications input
    if new_certs_str.strip():
        worker["required_certifications"] = [cert.strip() for cert in new_certs_str.split(",") if cert.strip()]
    else:
        worker["required_certifications"] = []
    
    # Active status
    worker["is_active"] = st.checkbox(
        "Ouvrier actif",
        value=worker.get("is_active", True),
        key=widget_manager.generate_key("worker_active", "worker_table")
    )
    
    return worker

# --- DATA MANAGEMENT FUNCTIONS ---
def _workers_to_dataframe(workers: List[Dict]) -> pd.DataFrame:
    """Convert workers to DataFrame for display"""
    if not workers:
        return pd.DataFrame()
    
    display_data = []
    for worker in workers:
        row = {}
        for eng_col, fr_col in FRENCH_COLUMNS.items():
            if eng_col in worker:
                value = worker[eng_col]
                if eng_col == 'base_productivity_rate':
                    # Handle productivity rates display
                    if isinstance(value, dict):
                        rates_str = ", ".join([f"{k}:{v}" for k, v in value.items()])
                        row[fr_col] = rates_str
                    else:
                        row[fr_col] = str(value)
                elif eng_col == 'skills' or eng_col == 'required_certifications':
                    row[fr_col] = ", ".join(value) if isinstance(value, list) else value
                elif eng_col == 'is_active':
                    row[fr_col] = '‚úÖ' if value else '‚ùå'
                else:
                    row[fr_col] = value
        
        display_data.append(row)
    
    return pd.DataFrame(display_data)

def _save_worker_table_changes(edited_df: pd.DataFrame, workers: List[Dict]):
    """Save changes from data editor"""
    st.info("Fonctionnalit√© de sauvegarde en ligne √† impl√©menter")

def _validate_worker(worker: Dict, all_workers: List[Dict], mode: str) -> bool:
    """Validate worker data with task-specific productivity rates"""
    errors = []
    
    if not worker.get("name", "").strip():
        errors.append("Le nom de l'ouvrier est obligatoire")
    if not worker.get("code", "").strip():
        errors.append("Le code est obligatoire")
    if not worker.get("specialty", "").strip():
        errors.append("La sp√©cialit√© est obligatoire")
    if not worker.get("template_id"):
        errors.append("Le mod√®le de ressources est obligatoire")
    if worker.get("hourly_rate", 0) <= 0:
        errors.append("Le taux horaire doit √™tre positif")
    if worker.get("base_count", 0) <= 0:
        errors.append("L'effectif de base doit √™tre positif")
    
    # Validate productivity rates structure
    productivity_rates = worker.get("base_productivity_rate", {})
    if not isinstance(productivity_rates, dict):
        errors.append("Les taux de productivit√© doivent √™tre au format dictionnaire")
    else:
        # Check each rate
        for task_id, rate in productivity_rates.items():
            if not task_id.strip():
                errors.append("L'ID de t√¢che ne peut pas √™tre vide")
            if not isinstance(rate, (int, float)) or rate <= 0:
                errors.append(f"Taux de productivit√© invalide pour la t√¢che '{task_id}': doit √™tre un nombre positif")
        
        # Ensure we have at least a default rate
        if not productivity_rates:
            errors.append("Au moins un taux de productivit√© (par d√©faut) est requis")
    
    if mode == "new":
        existing_codes = [w.get("code", "").lower() for w in all_workers]
        if worker.get("code", "").lower() in existing_codes:
            errors.append("Un ouvrier avec ce code existe d√©j√†")
    
    for error in errors:
        st.error(f"‚ùå {error}")
    
    return len(errors) == 0

def _save_worker(worker: Dict, workers: List[Dict], resource_service, user_id: int, template_id: Optional[int], mode: str):
    """Save worker via service layer"""
    try:
        # Set template_id if provided and not already set
        if template_id and not worker.get("template_id"):
            worker['template_id'] = template_id
        
        if mode == 'edit':
            result = resource_service.update_worker(user_id, worker.get('id'), worker)
            if result:
                for i, w in enumerate(workers):
                    if w.get('id') == worker.get('id'):
                        workers[i] = result
                        break
                st.success("‚úÖ Ouvrier modifi√© avec succ√®s!")
                # Check if template was default and is now modified
                template = next((t for t in resource_service.get_user_resource_templates(user_id) 
                               if t['id'] == template_id), None)
                if template and not template.get('is_default', True):
                    st.info("üìù Note: Ce mod√®le n'est plus consid√©r√© comme 'par d√©faut' car il a √©t√© modifi√©")
            else:
                st.error("‚ùå Erreur lors de la modification")
                
        elif mode == 'new':
            result = resource_service.create_worker(user_id, worker)
            if result:
                workers.append(result)
                st.success(f"‚úÖ Ouvrier cr√©√©: {result.get('code')}")
            else:
                st.error("‚ùå Erreur lors de la cr√©ation")
            
        elif mode == 'duplicate':
            duplicate_worker = worker.copy()
            duplicate_worker['code'] = f"{worker['code']}_COPY"
            result = resource_service.create_worker(user_id, duplicate_worker)
            if result:
                workers.append(result)
                st.success(f"‚úÖ Ouvrier dupliqu√©: {result.get('code')}")
            else:
                st.error("‚ùå Erreur lors de la duplication")
        
        # Clear form state
        st.session_state.worker_form_state = {'mode': None, 'current_worker': None}
        
    except Exception as e:
        logger.error(f"Error saving worker: {e}")
        st.error(f"‚ùå Erreur: {e}")

def _delete_worker(worker: Dict, workers: List[Dict], resource_service, user_id: int):
    """Delete worker with confirmation"""
    worker_id = worker.get('id')
    worker_name = worker.get('name')
    
    st.warning(f"√ätes-vous s√ªr de vouloir supprimer '{worker_name}'?")
    col1, col2 = st.columns(2)
    
    with col1:
        if st.button("‚úÖ Confirmer", key=widget_manager.generate_key("confirm_delete_worker", "worker_table")):
            try:
                success = resource_service.delete_worker(user_id, worker_id)
                if success:
                    workers[:] = [w for w in workers if w.get('id') != worker_id]
                    st.success(f"‚úÖ Ouvrier supprim√©: {worker_name}")
                else:
                    st.error("‚ùå Erreur lors de la suppression")
            except Exception as e:
                logger.error(f"Error deleting worker: {e}")
                st.error(f"‚ùå Erreur: {e}")
    
    with col2:
        if st.button("‚ùå Annuler", key=widget_manager.generate_key("cancel_delete_worker", "worker_table")):
            st.info("Suppression annul√©e")

def _get_default_worker_template() -> Dict:
    """Get default worker template with proper productivity rate structure"""
    return {
        "name": "", "code": "", "specialty": "", "category": "Ouvrier",
        "base_count": 1, "hourly_rate": 0.0, "daily_rate": 0.0,
        "max_workers_per_crew": 1, 
        "base_productivity_rate": {"default": 1.0},  # Dict with default rate
        "productivity_unit": "unit√©s/jour", "qualification_level": "Standard",
        "skills": [], "required_certifications": [], "is_active": True,
        "description": "", "template_id": None
    }

# ====== End of frontend/components/data_tables/worker_table.py ======

