

# ====== Begin of app.py ======

"""
PROFESSIONAL Construction Project Planner - FIXED VERSION
Unified Session Management & Transaction Safety
"""

import streamlit as st
import logging
import sys
import os
from sqlalchemy.orm import Session
from typing import Optional, Callable,Dict,  Any
from contextlib import contextmanager

# Add backend to path
sys.path.append(os.path.join(os.path.dirname(__file__), 'backend'))

# Configure professional logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class ConstructionApp:
    """
    FIXED Professional main application with unified session management
    """

    def __init__(self):
        self._setup_page_config()
        self._initialize_session_state()
        self._initialize_database()

    # ------------------- Initialization -------------------

    def _setup_page_config(self):
        """Setup professional page configuration"""
        st.set_page_config(
            page_title="Construction Project Planner",
            page_icon="üèóÔ∏è",
            layout="wide",
            initial_sidebar_state="expanded",
            menu_items={
                'Get Help': 'https://github.com/your-repo/construction-planner',
                'Report a bug': "https://github.com/your-repo/construction-planner/issues",
                'About': "### üèóÔ∏è Construction Project Planner\nProfessional construction scheduling and resource management system"
            }
        )

    def _initialize_session_state(self):
        """Initialize unified session state"""
        # 1. Authentication Session Manager (User identity & permissions)
        if 'auth_session_manager' not in st.session_state:
            from backend.auth.session_manager import SessionManager
            st.session_state.auth_session_manager = SessionManager()
            logger.info("‚úÖ Authentication session manager initialized")

        # 2. Application state defaults
        defaults = {
            'app_initialized': True,
            'current_page': 'login',
            'current_project_id': None,
            'current_project_name': None,
            'navigation_section': 'scheduling',
            '_previous_page': None,
            'widget_debug': False,
            'project_config': {
                'basic_info': {
                    'project_name': 'My Construction Project',
                    'project_manager': '',
                    'start_date': None,
                    'description': '',
                    'project_type': 'Commercial',
                    'client_name': '',
                    'location': ''
                },
                'zones': {},
                'advanced_settings': {
                    'work_hours_per_day': 8,
                    'acceleration_factor': 1.0,
                    'risk_allowance': 0.1
                }
            },
            'project_zones': {}
        }

        for key, value in defaults.items():
            if key not in st.session_state:
                st.session_state[key] = value

    def _initialize_database(self):
        """Initialize database connection professionally"""
        try:
            from backend.db.session import init_database
            init_database()
            logger.info("‚úÖ Database initialized successfully")
        except Exception as e:
            logger.error(f"‚ùå Database initialization failed: {e}")
            st.warning("‚ö†Ô∏è Database connection unavailable - using session storage")

    # ------------------- Session Management -------------------

    def _is_authenticated(self) -> bool:
        """Check if user is authenticated via auth session manager"""
        auth_manager = st.session_state.auth_session_manager
        return hasattr(auth_manager, 'is_authenticated') and auth_manager.is_authenticated()

    def _get_current_user_id(self) -> Optional[int]:
        """Get current user ID safely via auth session manager"""
        if self._is_authenticated():
            return st.session_state.auth_session_manager.get_user_id()
        return None

    def _initialize_services(self, db_session: Session, user_id: int) -> Dict[str, Any]:
        """
        Initialize all services with the current database session
        These services are request-scoped and not stored in session state
        """
        try:
            from backend.services.project_service import ProjectService
            from backend.services.user_task_service import UserTaskService
            from backend.services.resource_service import ResourceService
            from backend.services.template_service import TemplateService
            from backend.services.zone_sequence_service import ZoneSequenceService
            from backend.services.scheduling_service import SchedulingService
            from backend.services.reporting_service import ReportingService
            from backend.services.monitoring_service import MonitoringService
            
            services = {
                'project_service': ProjectService(db_session),
                'task_service': UserTaskService(db_session),
                'resource_service': ResourceService(db_session),
                'template_service': TemplateService(db_session),
                'zone_sequence_service': ZoneSequenceService(db_session),
                'scheduling_service': SchedulingService(db_session),
                'reporting_service': ReportingService(db_session),
                'monitoring_service': MonitoringService(db_session),
            }
            
            logger.info("‚úÖ Services initialized with request-scoped session")
            return services
            
        except Exception as e:
            logger.error(f"‚ùå Error initializing services: {e}")
            return {}
    


    @contextmanager
    def _database_session_scope(self):
        """
        Professional database transaction scope for entire page lifecycle
        Auto-commit on success, auto-rollback on exception
        """
        from backend.db.session import get_db_session, safe_commit, safe_rollback
        
        session = get_db_session()
        try:
            logger.debug("üéØ Starting page transaction scope")
            yield session
            # Commit on successful completion
            safe_commit(session, "Page transaction")
            logger.debug("‚úÖ Page transaction completed successfully")
            
        except Exception as e:
            # Rollback on any exception
            safe_rollback(session, f"Page transaction failed: {str(e)}")
            logger.error(f"‚ùå Transaction rolled back due to error: {e}")
            raise
            
        finally:
            # Always close session
            try:
                session.close()
                logger.debug("üîí Database session closed")
            except Exception as e:
                logger.error(f"‚ùå Error closing session: {e}")

    # ------------------- Page Routing -------------------

    def _route_to_page(self, db_session, services: Dict, user_id: int):
        """Route to current page with provided database session"""
        page = st.session_state.get('current_page', 'login')

        # Import all page modules
        from pages import login, project_setup, register
        from frontend.pages import (
            zone_sequence, templates_manager, 
            generate_schedule, progress_monitoring, 
            performance_dashboard, reports_analytics
        )

        # Map pages to their show functions with session
        page_mapping = {
            # Authentication Pages
            'login': lambda: login.show(),
            'register': lambda: register.show(),

            # Scheduling Section
            'project_setup': lambda: project_setup.show(db_session, services, user_id),
            'zone_sequence': lambda: zone_sequence.show(db_session, services, user_id),
            'templates_manager': lambda: templates_manager.show(db_session, services, user_id),
            'generate_schedule': lambda: generate_schedule.show(db_session, services, user_id),

            # Monitoring Section
            'progress_monitoring': lambda: progress_monitoring.show(db_session, services, user_id),
            'performance_dashboard': lambda: performance_dashboard.show(db_session, services, user_id),
            'reports_analytics': lambda: reports_analytics.show(db_session, services, user_id),
        }

        # Execute page function
        page_function = page_mapping.get(page, self._render_error_page)
        page_function()

    def _render_error_page(self):
        """Render error page for unknown routes"""
        st.error(f"‚ùå Page not found: {st.session_state.get('current_page')}")
        if st.button("üè† Return to Home"):
            st.session_state.current_page = "project_setup"
            st.rerun()

    # ------------------- Interface Rendering -------------------

    def _render_authenticated_interface(self):
        """
        FIXED: Professional authenticated interface with unified session management
        """
        try:
            # Single database transaction for entire page lifecycle
            with self._database_session_scope() as db_session:
                # Get user context from auth session manager
                auth_manager = st.session_state.auth_session_manager
                user_id = auth_manager.get_user_id()
                username = auth_manager.get_username()
                user_role = auth_manager.get_user_role()

                logger.info(f"üë§ Rendering interface for: {username} (ID: {user_id}, Role: {user_role})")

                # ‚úÖ FIXED: Initialize services with current session (not stored)
                services = self._initialize_services(db_session, user_id)

                # Widget management
                if 'widget_manager' not in st.session_state:
                    from backend.utils.widget_manager import widget_manager
                    st.session_state.widget_manager = widget_manager
                
                widget_manager = st.session_state.widget_manager
                current_page = st.session_state.get('current_page', 'unknown')
                
                # Clean up previous page keys
                previous_page = st.session_state.get('_previous_page')
                if previous_page and previous_page != current_page:
                    widget_manager.cleanup_page_keys(previous_page)
                    logger.info(f"üîÑ Cleaned up widget keys for previous page: {previous_page}")
                
                st.session_state._previous_page = current_page
                
                # Render interface components
                self._render_interface_components(db_session,  services, user_id, username, user_role)

        except Exception as e:
            logger.error(f"‚ùå Error in authenticated interface: {e}")
            self._show_error_page(e)

    def _render_interface_components(self, db_session, services: Dict, user_id: int, username: str, user_role: str):
        """Render all UI components with proper session context"""
        from frontend.components.navigation.sidebar import render_main_sidebar
        from frontend.components.navigation.header import render_page_header

        # -------------------
        # Render Sidebar with user context
        # -------------------
        render_main_sidebar(db_session, user_id, st.session_state.navigation_section)

        # -------------------
        # Render Main Content Header
        # -------------------
        current_page_name = st.session_state.get('current_page', 'Dashboard')
        render_page_header(
            title=current_page_name.replace('_', ' ').title(),
            description=f"User: {username} | Role: {user_role}",
            icon="üìä",
            show_breadcrumbs=True,
            breadcrumbs=[current_page_name.replace('_', ' ').title()]
        )

        # -------------------
        # Render Page Content with database session
        # -------------------
        self._route_to_page(db_session, services,user_id)

    def _render_login_interface(self):
        """Render login page (no database session needed)"""
        try:
            from pages.login import show as show_login_page
            show_login_page()
        except Exception as e:
            logger.error(f"‚ùå Login page error: {e}")
            self._show_error_page(e)

    # ------------------- Error Handling -------------------

    def _show_error_page(self, error: Exception):
        """Professional error page with technical details"""
        st.error("""
        ‚ùå Application Error
        We encountered an unexpected error. Please:
        1. Refresh the page
        2. Check your internet connection
        3. Contact support if the issue persists
        """)
        with st.expander("Technical Details (For Support)"):
            st.code(f"Error Type: {type(error).__name__}\nError Message: {str(error)}")

        if st.button("üîÑ Restart Application"):
            # Clear critical session state and rerun
            keys_to_keep = ['auth_session_manager', 'widget_manager']
            for key in list(st.session_state.keys()):
                if key not in keys_to_keep:
                    del st.session_state[key]
            st.rerun()

    # ------------------- Utilities -------------------

    def _show_widget_debug_info(self):
        """Show widget debugging information (optional)"""
        if st.session_state.get('widget_debug'):
            with st.sidebar.expander("üîß Widget Debug Info", expanded=False):
                if 'widget_manager' in st.session_state:
                    stats = st.session_state.widget_manager.get_registry_stats()
                    st.write(f"**Total Widget Keys:** {stats['total_keys']}")
                    st.write(f"**Active Pages:** {stats['pages']}")
                    st.write(f"**Users in Registry:** {stats['users']}")
                
                if st.button("Clear Widget Registry"):
                    if 'widget_key_registry' in st.session_state:
                        st.session_state.widget_key_registry = set()
                    if 'widget_key_context' in st.session_state:
                        st.session_state.widget_key_context = {}
                    st.rerun()

    # ------------------- Main Run Method -------------------

    def run(self):
        """Run the professional application with enhanced session management"""
        try:

            
            # Route based on authentication
            if self._is_authenticated():
                self._render_authenticated_interface()
            else:
                self._render_login_interface()
                
            # Optional debug information
            self._show_widget_debug_info()
                
        except Exception as e:
            logger.error(f"‚ùå Fatal application error: {e}")
            self._show_error_page(e)

# ------------------- Entry Point -------------------

if __name__ == "__main__":
    app = ConstructionApp()
    app.run()


    

# ====== End of app.py ======



# ====== Begin of pages/login.py ======

"""
PROFESSIONAL Login Page
Clean, secure authentication with proper session management
"""
import streamlit as st
import logging
from typing import Optional, Tuple
from sqlalchemy.orm import Session

from frontend.components.forms.login_form import login_form_component

logger = logging.getLogger(__name__)

def show(db_session: Session = None, user_id: int = None):
    """
    Professional login page with dependency injection compatibility
    
    Args:
        db_session: Database session (optional for compatibility)
        user_id: User ID (optional for compatibility)
    """
    # Professional page configuration
    st.set_page_config(
        page_title="Login - Construction Planner",
        page_icon="üîê",
        layout="centered",
        initial_sidebar_state="collapsed"
    )
    
    # Remove sidebar for clean login experience
    st.markdown("""
    <style>
        .css-1d391kg {display: none}
    </style>
    """, unsafe_allow_html=True)
    
    # Professional login interface
    _render_login_header()
    
    # Use the professional login form component
    # Pass db_session if available, otherwise the component will handle it
    if db_session:
        login_form_component(db_session)
    else:
        login_form_component()
    

 
def _render_login_header():
    """Render professional login page header"""
    # Professional branding
    col1, col2, col3 = st.columns([1, 2, 1])
    
    with col2:
        st.markdown(
            """
            <div style='text-align: center; padding: 2rem 0;'>
                <h1 style='color: #1f77b4; margin-bottom: 0.5rem;'>üèóÔ∏è</h1>
                <h2 style='color: #333; margin-bottom: 0.5rem;'>Construction Project Planner</h2>
                <p style='color: #666; font-size: 1.1rem;'>Professional Construction Management System</p>
            </div>
            """,
            unsafe_allow_html=True
        )
        
        st.markdown("---")

def _handle_successful_login():
    """Handle professional post-login workflow"""
    # Professional success feedback
    st.success("‚úÖ Authentication successful!")
    
    # Professional redirect with user feedback
    st.toast("üéâ Welcome! Redirecting to your dashboard...")
    
    # Smooth transition to main application
    st.markdown(
        """
        <div style='text-align: center; padding: 2rem;'>
            <p>Redirecting to application...</p>
        </div>
        """,
        unsafe_allow_html=True
    )
    
    # Professional navigation
    st.switch_page("pages/project_setup.py")

def _render_legacy_login_form():
    """
    Legacy login form for backward compatibility
    This can be removed once all components are updated
    """
    st.warning("‚ö†Ô∏è Using legacy authentication method")
    
    with st.form("legacy_login_form"):
        st.subheader("Legacy Login")
        
        username = st.text_input("Username")
        password = st.text_input("Password", type="password")
        
        if st.form_submit_button("Login"):
            if username and password:
                # Simple validation for demo purposes
                if len(username) >= 3 and len(password) >= 6:
                    st.session_state.authenticated = True
                    st.session_state.user = {"username": username, "role": "user"}
                    st.rerun()
                else:
                    st.error("Invalid credentials")
            else:
                st.error("Please enter username and password")

def main():
    """
    Main function for direct script execution
    Provides backward compatibility
    """
    try:
        # Initialize database session if needed
        from backend.db.session import get_db_session
        
        with get_db_session() as db_session:
            show(db_session)
            
    except Exception as e:
        logger.error(f"Login page error: {e}")
        
        # Fallback to legacy mode
        st.error("System initialization error - using legacy mode")
        _render_legacy_login_form()

# Backward compatibility
if __name__ == "__main__":
    main()

# ====== End of pages/login.py ======



# ====== Begin of pages/register.py ======

"""
User Registration Page
"""
import streamlit as st
from frontend.components.auth.registration_form import registration_form_component

st.set_page_config(
    page_title="Register - Construction Planner",
    page_icon="üë§",
    layout="centered"
)

def main():
    st.title("üë§ Create Account")
    st.markdown("Join the Construction Project Planner platform")
    
    if registration_form_component():
        st.balloons()
        st.success("Account created successfully! You can now log in.")
        if st.button("Go to Login"):
            st.switch_page("pages/0_üîê_Login.py")

if __name__ == "__main__":
    main()

# ====== End of pages/register.py ======



# ====== Begin of backend/auth/auth_manager.py ======

"""
FIXED AuthManager with proper session injection
"""
import logging
from typing import Optional, Dict, Any
from datetime import datetime, timedelta
import jwt
from sqlalchemy.orm import Session

from backend.utils.security.password_utils import hash_password, verify_password
from ..models.db_models import UserDB
from backend.services.user_service import UserService  # ‚úÖ Fixed import

logger = logging.getLogger(__name__)

class AuthManager:
    """
    FIXED authentication manager with proper session usage
    """
    
    def __init__(self, db_session: Session, secret_key: str = "construction_planner_secret_2024"):

        self.db_session = db_session  # ‚úÖ Use injected session
        self.secret_key = secret_key
        self.user_service = UserService(db_session)  # ‚úÖ Pass session to service
        self.token_expiry_hours = 24
    
    def authenticate_user(self, username: str, password: str) -> Optional[Dict[str, Any]]:
        """
        Authenticate user and return SessionManager-compatible user info
        """
        try:
            logger.info(f"Authentication attempt for user: {username}")
            
            # Get user from database using injected session
            user = self.user_service.authenticate_user(username, password)
            
            if user and user.is_active:
                # Generate JWT token
                token = self._generate_token(user)
                
                # SessionManager-compatible user info
                user_info = {
                    'user_id': user.id,
                    'username': user.username,
                    'email': user.email,
                    'role': user.role,
                    'full_name': user.full_name or user.username,
                    'token': token,
                    'last_login': user.last_login.isoformat() if user.last_login else None
                }
                
                # Update last login
                self.user_service.update_user_last_login(user.id)
                
                logger.info(f"User {username} authenticated successfully")
                return user_info
            
            logger.warning(f"Authentication failed for user: {username}")
            return None
            
        except Exception as e:
            logger.error(f"Error during authentication for {username}: {e}")
            return None
    
    def register_user(self, username: str, email: str, password: str, 
                     full_name: str = "", role: str = "user") -> Optional[Dict[str, Any]]:
        """
        Register a new user with SessionManager-compatible response
        
        Args:
            username: Unique username
            email: User email
            password: Plain text password
            full_name: User's full name
            role: User role (user, manager, admin)
            
        Returns:
            Dict with user info compatible with SessionManager
        """
        try:
            logger.info(f"Registration attempt for user: {username}")
            
            # Create new user
            user = self.user_service.create_user(
                username=username,
                email=email,
                password=password,
                full_name=full_name,
                role=role
            )
            
            if user:
                # Generate token for immediate login
                token = self._generate_token(user)
                
                # ‚úÖ SessionManager-compatible response
                user_info = {
                    'user_id': user.id,
                    'username': user.username,
                    'email': user.email,
                    'role': user.role,
                    'full_name': user.full_name or user.username,
                    'token': token,
                    'created_at': user.created_at.isoformat()
                }
                
                logger.info(f"User {username} registered successfully")
                return user_info
            
            return None
            
        except Exception as e:
            logger.error(f"Error during registration for {username}: {e}")
            return None
    
    def validate_token(self, token: str) -> Optional[Dict[str, Any]]:
        """
        Validate JWT token and return SessionManager-compatible user info
        
        Args:
            token: JWT token to validate
            
        Returns:
            Dict with user info if valid, None otherwise
        """
        try:
            if not token:
                return None
            
            # Decode token
            payload = jwt.decode(token, self.secret_key, algorithms=["HS256"])
            
            # Check expiration
            if datetime.fromtimestamp(payload['exp']) < datetime.now():
                logger.warning("Token has expired")
                return None
            
            # Get user from database
            user_id = payload['user_id']
            user = self.user_service.get_user_by_id(user_id)
            
            if user and user.is_active:
                # ‚úÖ SessionManager-compatible format
                user_info = {
                    'user_id': user.id,
                    'username': user.username,
                    'email': user.email,
                    'role': user.role,
                    'full_name': user.full_name or user.username
                }
                return user_info
            
            return None
            
        except jwt.ExpiredSignatureError:
            logger.warning("Token signature has expired")
            return None
        except jwt.InvalidTokenError:
            logger.warning("Invalid token provided")
            return None
        except Exception as e:
            logger.error(f"Error validating token: {e}")
            return None
    
    def _generate_token(self, user: UserDB) -> str:
        """
        Generate JWT token for user
        
        Args:
            user: User database object
            
        Returns:
            JWT token string
        """
        payload = {
            'user_id': user.id,
            'username': user.username,
            'role': user.role,
            'exp': datetime.now() + timedelta(hours=self.token_expiry_hours),
            'iat': datetime.now()
        }
        
        token = jwt.encode(payload, self.secret_key, algorithm="HS256")
        return token
    
    # Other methods remain the same but ensure SessionManager compatibility
    def change_password(self, user_id: int, current_password: str, new_password: str) -> bool:
        """Change user password with verification"""
        try:
            user = self.user_service.get_user_by_id(user_id)
            if not user:
                return False
            
            # Verify current password
            if not verify_password(current_password, user.password_hash):
                logger.warning(f"Current password verification failed for user {user_id}")
                return False
            
            # Change password
            success = self.user_service.change_password(user_id, current_password, new_password)
            
            if success:
                logger.info(f"Password changed successfully for user {user_id}")
            else:
                logger.warning(f"Password change failed for user {user_id}")
            
            return success
            
        except Exception as e:
            logger.error(f"Error changing password for user {user_id}: {e}")
            return False
    
    def validate_password_strength(self, password: str) -> Dict[str, Any]:
        """
        Validate password strength against security requirements
        
        Args:
            password: Password to validate
            
        Returns:
            Dict with validation results
        """
        from auth_config import validate_password_strength
        return validate_password_strength(password)



    def refresh_token(self, old_token: str) -> Optional[str]:
        """
        Refresh an expired token
        
        Args:
            old_token: Expired token to refresh
            
        Returns:
            New token if successful, None otherwise
        """
        try:
            # Validate old token (even if expired)
            payload = jwt.decode(old_token, self.secret_key, algorithms=["HS256"], options={"verify_exp": False})
            
            user_id = payload['user_id']
            user = self.user_service.get_user_by_id(user_id)
            
            if user and user.is_active:
                new_token = self._generate_token(user)
                logger.info(f"Token refreshed for user {user.username}")
                return new_token
            
            return None
            
        except Exception as e:
            logger.error(f"Error refreshing token: {e}")
            return None
    def logout_user(self, user_id: int, token: str = None) -> bool:
        """
        Logout user and invalidate token (placeholder for future implementation)
        
        Args:
            user_id: User ID
            token: Specific token to invalidate (optional)
            
        Returns:
            bool: True if logout successful
        """
        # In a production system, you would:
        # 1. Add token to blacklist
        # 2. Remove from active sessions
        # 3. Log the logout event
        
        logger.info(f"User {user_id} logged out")
        return True


    def update_user_last_login(self, user_id: int) -> bool:
        """
        Update user's last login timestamp
        Args:
        user_id: User ID to update
        Returns:
        bool: True if updated successfully
        """
        try:
            success = self.user_service.update_user_last_login(user_id)
            if success:
                logger.info(f"Updated last login for user {user_id}")
            else:
                logger.warning(f"Failed to update last login for user {user_id}")
            return success
        except Exception as e:
            logger.error(f"Error updating last login for user {user_id}: {e}")

    def deactivate_user(self, user_id: int, admin_user_id: int) -> bool:
        """
        Deactivate a user account (admin only)
        
        Args:
            user_id: User ID to deactivate
            admin_user_id: Admin user ID performing the action
            
        Returns:
            bool: True if deactivated successfully
        """
        try:
            # Verify admin privileges
            admin_user = self.user_service.get_user_by_id(admin_user_id)
            if not admin_user or admin_user.role != 'admin':
                logger.warning(f"User {admin_user_id} attempted to deactivate user without admin privileges")
                return False
            
            success = self.user_service.deactivate_user(user_id)
            
            if success:
                logger.info(f"User {user_id} deactivated by admin {admin_user_id}")
            else:
                logger.warning(f"Failed to deactivate user {user_id}")
            
            return success
            
        except Exception as e:
            logger.error(f"Error deactivating user {user_id}: {e}")
            return False
    

# ====== End of backend/auth/auth_manager.py ======



# ====== Begin of frontend/components/auth/registration_form.py ======

"""
Enhanced User registration form compatible with SessionManager
"""
import streamlit as st
from backend.auth.auth_manager import AuthManager

def registration_form_component() -> bool:
    """Enhanced registration form with proper session management"""
    with st.form("registration_form"):
        st.subheader("üë§ Create New Account")
        
        col1, col2 = st.columns(2)
        with col1:
            full_name = st.text_input("Full Name", placeholder="Enter your full name")
            username = st.text_input("Username", placeholder="Choose a username")
        with col2:
            email = st.text_input("Email", placeholder="your.email@company.com")
            role = st.selectbox("Role", ["Ing√©nieur", "Directeur", "Admin"], 
                              help="Ing√©nieur: Basic user, Directeur: Manager access, Admin: Full system access")
        
        password = st.text_input("Password", type="password", 
                               placeholder="Create a strong password")
        confirm_password = st.text_input("Confirm Password", type="password", 
                                       placeholder="Confirm your password")
        
        agree_terms = st.checkbox("I agree to the terms and conditions")
        
        register_clicked = st.form_submit_button("Create Account", type="primary")
    
    if register_clicked:
        # Validate inputs
        if not all([full_name, username, email, password, confirm_password]):
            st.error("Please fill in all required fields")
            return False
        
        if password != confirm_password:
            st.error("Passwords do not match")
            return False
        
        # ‚úÖ Use enhanced password validation from SecurityConfig
        from backend.auth_config import validate_password_strength
        password_validation = validate_password_strength(password)
        if not password_validation['is_valid']:
            st.error("Password does not meet security requirements:")
            for issue in password_validation['issues']:
                st.error(f"‚Ä¢ {issue}")
            return False
        
        if not agree_terms:
            st.error("Please agree to the terms and conditions")
            return False
        
        # ‚úÖ Enhanced registration with proper error handling
        try:
            from backend.db.session import get_db_session
            with get_db_session() as db_session:
                auth_manager = AuthManager(db_session)
                
                result = auth_manager.register_user(
                    username=username,
                    email=email,
                    password=password,
                    full_name=full_name,
                    role=role.lower()  # ‚úÖ Normalize role case
                )
                
                if result:
                    st.success("‚úÖ Account created successfully! You can now log in.")
                    
                    # ‚úÖ Optional: Auto-login after registration
                    if st.button("üîê Login Now"):
                        st.switch_page("pages/login.py")
                    
                    return True
                else:
                    st.error("‚ùå Username or email already exists")
                    return False
                    
        except Exception as e:
            st.error(f"‚ùå Registration failed: {str(e)}")
            return False
    
    return False

# ====== End of frontend/components/auth/registration_form.py ======

