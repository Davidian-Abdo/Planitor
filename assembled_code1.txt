

# ====== Begin of app.py ======

"""
PROFESSIONAL Construction Project Planner - FIXED VERSION
Unified Session Management & Transaction Safety
"""

import streamlit as st
import logging
import sys
import os
from sqlalchemy.orm import Session
from typing import Optional, Callable,Dict,  Any
from contextlib import contextmanager

# Add backend to path
sys.path.append(os.path.join(os.path.dirname(__file__), 'backend'))

# Configure professional logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class ConstructionApp:
    """
    FIXED Professional main application with unified session management
    """

    def __init__(self):
        self._setup_page_config()
        self._initialize_session_state()
        self._initialize_database()

    # ------------------- Initialization -------------------

    def _setup_page_config(self):
        """Setup professional page configuration"""
        st.set_page_config(
            page_title="Construction Project Planner",
            page_icon="üèóÔ∏è",
            layout="wide",
            initial_sidebar_state="expanded",
            menu_items={
                'Get Help': 'https://github.com/your-repo/construction-planner',
                'Report a bug': "https://github.com/your-repo/construction-planner/issues",
                'About': "### üèóÔ∏è Construction Project Planner\nProfessional construction scheduling and resource management system"
            }
        )

    def _initialize_session_state(self):
        """Initialize unified session state"""
        # 1. Authentication Session Manager (User identity & permissions)
        if 'auth_session_manager' not in st.session_state:
            from backend.auth.session_manager import SessionManager
            st.session_state.auth_session_manager = SessionManager()
            logger.info("‚úÖ Authentication session manager initialized")

        # 2. Application state defaults
        defaults = {
            'app_initialized': True,
            'current_page': 'login',
            'current_project_id': None,
            'current_project_name': None,
            'navigation_section': 'scheduling',
            '_previous_page': None,
            'widget_debug': False,
            'project_config': {
                'basic_info': {
                    'project_name': 'My Construction Project',
                    'project_manager': '',
                    'start_date': None,
                    'description': '',
                    'project_type': 'Commercial',
                    'client_name': '',
                    'location': ''
                },
                'zones': {},
                'advanced_settings': {
                    'work_hours_per_day': 8,
                    'acceleration_factor': 1.0,
                    'risk_allowance': 0.1
                }
            },
            'project_zones': {}
        }

        for key, value in defaults.items():
            if key not in st.session_state:
                st.session_state[key] = value

    def _initialize_database(self):
        """Initialize database connection professionally"""
        try:
            from backend.db.session import init_database
            init_database()
            logger.info("‚úÖ Database initialized successfully")
        except Exception as e:
            logger.error(f"‚ùå Database initialization failed: {e}")
            st.warning("‚ö†Ô∏è Database connection unavailable - using session storage")

    # ------------------- Session Management -------------------

    def _is_authenticated(self) -> bool:
        """Check if user is authenticated via auth session manager"""
        auth_manager = st.session_state.auth_session_manager
        return hasattr(auth_manager, 'is_authenticated') and auth_manager.is_authenticated()

    def _get_current_user_id(self) -> Optional[int]:
        """Get current user ID safely via auth session manager"""
        if self._is_authenticated():
            return st.session_state.auth_session_manager.get_user_id()
        return None

    def _initialize_services(self, db_session: Session, user_id: int) -> Dict[str, Any]:
        """
        Initialize all services with the current database session
        These services are request-scoped and not stored in session state
        """
        try:
            from backend.services.user_service import UserService
            from backend.services.project_service import ProjectService
            from backend.services.user_task_service import UserTaskService
            from backend.services.resource_service import ResourceService
            from backend.services.template_service import TemplateService
            from backend.services.zone_sequence_service import ZoneSequenceService
            from backend.services.scheduling_service import SchedulingService
            from backend.services.reporting_service import ReportingService
            from backend.services.monitoring_service import MonitoringService
            
            services = {
                'user_service': UserService(db_session),  
                'project_service': ProjectService(db_session),
                'task_service': UserTaskService(db_session),
                'resource_service': ResourceService(db_session),
                'template_service': TemplateService(db_session),
                'zone_sequence_service': ZoneSequenceService(db_session),
                'scheduling_service': SchedulingService(db_session),
                'reporting_service': ReportingService(db_session),
                'monitoring_service': MonitoringService(db_session),
            }
            
            logger.info("‚úÖ Services initialized with request-scoped session")
            return services
            
        except Exception as e:
            logger.error(f"‚ùå Error initializing services: {e}")
            return {}
    


    @contextmanager
    def _database_session_scope(self):
        """
        Professional database transaction scope for entire page lifecycle
        Auto-commit on success, auto-rollback on exception
        """
        from backend.db.session import get_db_session, safe_commit, safe_rollback
        
        session = get_db_session()
        try:
            logger.debug("üéØ Starting page transaction scope")
            yield session
            # Commit on successful completion
            safe_commit(session, "Page transaction")
            logger.debug("‚úÖ Page transaction completed successfully")
            
        except Exception as e:
            # Rollback on any exception
            safe_rollback(session, f"Page transaction failed: {str(e)}")
            logger.error(f"‚ùå Transaction rolled back due to error: {e}")
            raise
            
        finally:
            # Always close session
            try:
                session.close()
                logger.debug("üîí Database session closed")
            except Exception as e:
                logger.error(f"‚ùå Error closing session: {e}")

    # ------------------- Page Routing -------------------

    def _route_to_page(self, db_session, services: Dict, user_id: int):
        """Route to current page with provided database session"""
        page = st.session_state.get('current_page', 'login')

        # Import all page modules
        from pages import login, project_setup, register
        from frontend.pages import (
            zone_sequence, templates_manager, 
            generate_schedule, progress_monitoring, 
            performance_dashboard, reports_analytics
        )

        # Map pages to their show functions with session
        page_mapping = {
            # Authentication Pages
            'login': lambda: login.show(),
            'register': lambda: register.show(),

            # Scheduling Section
            'project_setup': lambda: project_setup.show(db_session, services, user_id),
            'zone_sequence': lambda: zone_sequence.show(db_session, services, user_id),
            'templates_manager': lambda: templates_manager.show(db_session, services, user_id),
            'generate_schedule': lambda: generate_schedule.show(db_session, services, user_id),

            # Monitoring Section
            'progress_monitoring': lambda: progress_monitoring.show(db_session, services, user_id),
            'performance_dashboard': lambda: performance_dashboard.show(db_session, services, user_id),
            'reports_analytics': lambda: reports_analytics.show(db_session, services, user_id),
        }

        # Execute page function
        page_function = page_mapping.get(page, self._render_error_page)
        page_function()

    def _render_error_page(self):
        """Render error page for unknown routes"""
        st.error(f"‚ùå Page not found: {st.session_state.get('current_page')}")
        if st.button("üè† Return to Home"):
            st.session_state.current_page = "project_setup"
            st.rerun()

    # ------------------- Interface Rendering -------------------

    def _render_authenticated_interface(self):
        """
        FIXED: Professional authenticated interface with unified session management
        """
        try:
            # Single database transaction for entire page lifecycle
            with self._database_session_scope() as db_session:
                # Get user context from auth session manager
                auth_manager = st.session_state.auth_session_manager
                user_id = auth_manager.get_user_id()
                username = auth_manager.get_username()
                user_role = auth_manager.get_user_role()

                logger.info(f"üë§ Rendering interface for: {username} (ID: {user_id}, Role: {user_role})")

                # ‚úÖ FIXED: Initialize services with current session (not stored)
                services = self._initialize_services(db_session, user_id)

                # Widget management
                if 'widget_manager' not in st.session_state:
                    from backend.utils.widget_manager import widget_manager
                    st.session_state.widget_manager = widget_manager
                
                widget_manager = st.session_state.widget_manager
                current_page = st.session_state.get('current_page', 'unknown')
                
                # Clean up previous page keys
                previous_page = st.session_state.get('_previous_page')
                if previous_page and previous_page != current_page:
                    widget_manager.cleanup_page_keys(previous_page)
                    logger.info(f"üîÑ Cleaned up widget keys for previous page: {previous_page}")
                
                st.session_state._previous_page = current_page
                
                # Render interface components
                self._render_interface_components(db_session,  services, user_id, username, user_role)

        except Exception as e:
            logger.error(f"‚ùå Error in authenticated interface: {e}")
            self._show_error_page(e)

    def _render_interface_components(self, db_session, services: Dict, user_id: int, username: str, user_role: str):
        """Render all UI components with proper session context"""
        from frontend.components.navigation.sidebar import render_main_sidebar
        from frontend.components.navigation.header import render_page_header

        # -------------------
        # Render Sidebar with user context
        # -------------------
        render_main_sidebar(db_session, user_id, st.session_state.navigation_section)

        # -------------------
        # Render Main Content Header
        # -------------------
        current_page_name = st.session_state.get('current_page', 'Dashboard')
        render_page_header(
            title=current_page_name.replace('_', ' ').title(),
            description=f"User: {username} | Role: {user_role}",
            icon="üìä",
            show_breadcrumbs=True,
            breadcrumbs=[current_page_name.replace('_', ' ').title()]
        )

        # -------------------
        # Render Page Content with database session
        # -------------------
        self._route_to_page(db_session, services,user_id)

    def _render_login_interface(self):
        """Render login page (no database session needed)"""
        try:
            from pages.login import show as show_login_page
            show_login_page()
        except Exception as e:
            logger.error(f"‚ùå Login page error: {e}")
            self._show_error_page(e)


    def _render_register_interface(self):
        """Render register page for unauthenticated users"""
        try:
            from pages.register import show as show_register_page
            show_register_page()
        except Exception as e:
            logger.error(f"‚ùå Register page error: {e}")
            self._show_error_page(e)
    # ------------------- Error Handling -------------------

    def _show_error_page(self, error: Exception):
        """Professional error page with technical details"""
        st.error("""
        ‚ùå Application Error
        We encountered an unexpected error. Please:
        1. Refresh the page
        2. Check your internet connection
        3. Contact support if the issue persists
        """)
        with st.expander("Technical Details (For Support)"):
            st.code(f"Error Type: {type(error).__name__}\nError Message: {str(error)}")

        if st.button("üîÑ Restart Application"):
            # Clear critical session state and rerun
            keys_to_keep = ['auth_session_manager', 'widget_manager']
            for key in list(st.session_state.keys()):
                if key not in keys_to_keep:
                    del st.session_state[key]
            st.rerun()

    # ------------------- Utilities -------------------

    def _show_widget_debug_info(self):
        """Show widget debugging information (optional)"""
        if st.session_state.get('widget_debug'):
            with st.sidebar.expander("üîß Widget Debug Info", expanded=False):
                if 'widget_manager' in st.session_state:
                    stats = st.session_state.widget_manager.get_registry_stats()
                    st.write(f"**Total Widget Keys:** {stats['total_keys']}")
                    st.write(f"**Active Pages:** {stats['pages']}")
                    st.write(f"**Users in Registry:** {stats['users']}")
                
                if st.button("Clear Widget Registry"):
                    if 'widget_key_registry' in st.session_state:
                        st.session_state.widget_key_registry = set()
                    if 'widget_key_context' in st.session_state:
                        st.session_state.widget_key_context = {}
                    st.rerun()

    # ------------------- Main Run Method -------------------

    def run(self):
        """Run the professional application with enhanced session management"""
        try:

            
            # Route based on authentication
            if self._is_authenticated():
                self._render_authenticated_interface()
            else:
                

                current_page = st.session_state.get('current_page', 'login')
            
                if current_page == 'register':
                    self._render_register_interface()  # You need to create this
                else:
                    self._render_login_interface()

            # Optional debug information
            self._show_widget_debug_info()
                
        except Exception as e:
            logger.error(f"‚ùå Fatal application error: {e}")
            self._show_error_page(e)

# ------------------- Entry Point -------------------

if __name__ == "__main__":
    app = ConstructionApp()
    app.run()


    

# ====== End of app.py ======



# ====== Begin of pages/login.py ======

"""
PROFESSIONAL Login Page
Clean, secure authentication with proper session management
"""
import streamlit as st
import logging
from typing import Optional, Tuple
from sqlalchemy.orm import Session

from frontend.components.forms.login_form import login_form_component

logger = logging.getLogger(__name__)

def show(db_session: Session = None, user_id: int = None):
    """
    Professional login page with dependency injection compatibility
    
    Args:
        db_session: Database session (optional for compatibility)
        user_id: User ID (optional for compatibility)
    """
    # Professional page configuration
    st.set_page_config(
        page_title="Login - Construction Planner",
        page_icon="üîê",
        layout="centered",
        initial_sidebar_state="collapsed"
    )
    
    # Remove sidebar for clean login experience
    st.markdown("""
    <style>
        .css-1d391kg {display: none}
    </style>
    """, unsafe_allow_html=True)
    
    # Professional login interface
    _render_login_header()
    
    # Use the professional login form component
    # Pass db_session if available, otherwise the component will handle it
    if db_session:
        login_form_component(db_session)
    else:
        login_form_component()
    

 
def _render_login_header():
    """Render professional login page header"""
    # Professional branding
    col1, col2, col3 = st.columns([1, 2, 1])
    
    with col2:
        st.markdown(
            """
            <div style='text-align: center; padding: 2rem 0;'>
                <h1 style='color: #1f77b4; margin-bottom: 0.5rem;'>üèóÔ∏è</h1>
                <h2 style='color: #333; margin-bottom: 0.5rem;'>Construction Project Planner</h2>
                <p style='color: #666; font-size: 1.1rem;'>Professional Construction Management System</p>
            </div>
            """,
            unsafe_allow_html=True
        )
        
        st.markdown("---")

# ====== End of pages/login.py ======



# ====== Begin of pages/register.py ======

"""
User Registration Page
"""
import streamlit as st
from frontend.components.auth.registration_form import registration_form_component

st.set_page_config(
    page_title="Register ---- Planitor - plan and monitor your constructions",
    page_icon="üë§",
    layout="centered"
)

def show(): 
    st.title("üë§ Create Account")
    st.markdown("Join the Construction Project Planner platform")
    
    if registration_form_component():
        st.balloons()
        st.success("Account created successfully! You can now log in.")
        if st.button("Go to Login"): 
            st.switch_page('pages/login.py')
            st.session_state['current_page'] = 'login'
        


# ====== End of pages/register.py ======



# ====== Begin of frontend/components/forms/login_form.py ======

"""
frontend/components/forms/login_form.py
Professional Login Form Component with Register
"""

import streamlit as st
import logging


logger = logging.getLogger(__name__)

from backend.db.session import get_db_session
from backend.auth.auth_manager import AuthManager

# Professional login form
def login_form_component():
    db_session = get_db_session()  # get database session
    auth_manager = AuthManager(db_session)  # pass session

    st.title("üèóÔ∏è Professional Construction Planner Login")

    with st.form(key="login_form"):
        username = st.text_input("Username")
        password = st.text_input("Password", type="password")
        remember_me = st.checkbox("Remember me", value=False)
        
        col1, col2 = st.columns(2)
        with col1:
            login_submit = st.form_submit_button("Login")
        with col2:
            register_submit = st.form_submit_button("Register")
    
    
    # Handle register
    if register_submit:
        st.session_state['current_page'] = 'register'
        st.rerun()  
        
    # Handle login
    if login_submit:
        user_data = auth_manager.authenticate_user(username, password)
        if user_data:
            if 'session_manager' not in st.session_state:
                from backend.auth.session_manager import SessionManager
                st.session_state.session_manager = SessionManager()

            st.session_state.session_manager.create_session(user_data)
            st.session_state['current_page'] = 'project_setup'
            st.rerun()
        else:
            st.error("‚ùå Invalid username or password")


# ====== End of frontend/components/forms/login_form.py ======



# ====== Begin of frontend/components/auth/registration_form.py ======

"""
Enhanced User registration form compatible with SessionManager
"""
import streamlit as st
from backend.auth.auth_manager import AuthManager

def registration_form_component() -> bool:
    """CORRECTED registration form with proper session management"""
    with st.form("registration_form"):
        st.subheader("üë§ Create New Account")
        
        col1, col2 = st.columns(2)
        with col1:
            full_name = st.text_input("Full Name", placeholder="Enter your full name")
            username = st.text_input("Username", placeholder="Choose a username")
        with col2:
            email = st.text_input("Email", placeholder="your.email@company.com")
            role = st.selectbox("Role", ["Admin", "Directeur", "Ing√©nieur"], 
                              help="Ing√©nieur: Basic user, Directeurr: Manager access, Admin: Full system access")
        
        password = st.text_input("Password", type="password", 
                               placeholder="Create a strong password")
        confirm_password = st.text_input("Confirm Password", type="password", 
                                       placeholder="Confirm your password")
        
        agree_terms = st.checkbox("I agree to the terms and conditions")
        
        register_clicked = st.form_submit_button("Create Account", type="primary")
    
    if register_clicked:
        # Validate inputs
        if not all([full_name, username, email, password, confirm_password]):
            st.error("Please fill in all required fields")
            return False
        
        if password != confirm_password:
            st.error("Passwords do not match")
            return False
        
        # ‚úÖ Use enhanced password validation
        from backend.utils.validators import Validator
        is_valid, errors = Validator.validate_user_data({
            'username': username,
            'email': email,
            'password': password
        })
        
        if not is_valid:
            for error in errors:
                st.error(f"‚ùå {error}")
            return False
        
        if not agree_terms:
            st.error("Please agree to the terms and conditions")
            return False
        
        # ‚úÖ CORRECTED: Use single database session
        try:
            from backend.db.session import get_db_session
            db_session = get_db_session()
            
            # Create AuthManager with the session
            from backend.auth.auth_manager import AuthManager
            auth_manager = AuthManager(db_session)
            
            # Attempt registration
            result = auth_manager.register_user(
                username=username,
                email=email,
                password=password,
                full_name=full_name,
                role=role  # ‚úÖ Use exact role values
            )
            
            if result:
                # ‚úÖ Commit the transaction
                from backend.db.session import safe_commit
                if safe_commit(db_session, "User registration"):
                    st.success("‚úÖ Account created successfully! You can now log in.")
                    
                    # ‚úÖ Correct page redirection
                    st.session_state['current_page'] = "login"
                    return True
                else:
                    st.error("‚ùå Failed to save user to database")
                    return False
            else:
                st.error("‚ùå Username or email already exists")
                return False
                
        except Exception as e:
            st.error(f"‚ùå Registration failed: {str(e)}")
            # ‚úÖ Ensure session is properly closed
            try:
                db_session.rollback()
                db_session.close()
            except:
                pass
            return False
        finally:
            try:
                db_session.close()
            except:
                pass
    
    return False

# ====== End of frontend/components/auth/registration_form.py ======



# ====== Begin of backend/db/session.py ======

"""
backend/db/session.py
Production-ready SQLAlchemy session manager for Planitor (Supabase-friendly).

Behavior:
 - Read DB url from (in order): os.environ["SUPABASE_URL"], streamlit secrets ("SUPABASE_URL"), .env via python-dotenv if present.
 - Create engine lazily (so tools like alembic can import without crashing in some contexts).
 - Provide `engine` (may be None until created), `get_engine()` to ensure creation, `SessionLocal`, and helpers.
 - Use sqlalchemy.text(...) when executing raw SQL checks.
"""

from __future__ import annotations
import os
import logging
from typing import Optional
from sqlalchemy import create_engine, text as sa_text
from sqlalchemy.engine import Engine
from sqlalchemy.exc import SQLAlchemyError, OperationalError
from sqlalchemy.orm import sessionmaker, Session as SessionType
import streamlit as st

logger = logging.getLogger(__name__)

# ---------- Configuration & URL resolution ----------
try:
    DATABASE_URL = "postgresql://postgres.vigyqbzjtpqjzlpuyzvf:ABDOABDOABDO@aws-1-eu-west-1.pooler.supabase.com:5432/postgres"
    #DATABASE_URL = os.environ.get("SUPABASE_URL")
    if DATABASE_URL :
        logger.debug("Using SUPABASE_URL from environment")

except Exception:
        logger.debug("could not get SUPABASE_URL")
    

# module-level "engine" is created lazily by get_engine()
_engine: Optional[Engine] = None

def get_engine() -> Engine:
    """
    Ensure and return a SQLAlchemy Engine.
    This will create the engine on first call and raise a clear error if DB URL is missing.
    """
    global _engine
    if _engine is not None:
        return _engine

    if not DATABASE_URL:
        raise RuntimeError(
            "Database URL is not configured. "
            "Set SUPABASE_URL environment variable or Streamlit secrets (SUPABASE_URL)."
        )

    # Recommended: explicit connect timeout and minimal pool tuning for serverless hosts
    connect_args = {}
    # If pg driver supports it, set a short connect timeout to fail faster
    # (psycopg2 uses connect_timeout param in dsn)
    try:
        # SQLAlchemy will pass connect_args to DBAPI connect; this is harmless if unsupported.
        connect_args = {"connect_timeout": 10}
    except Exception:
        connect_args = {}

    try:
        _engine = create_engine(
            DATABASE_URL,
            echo=False,
            pool_pre_ping=True,
            pool_size=5,        # conservative defaults for hosted environments
            max_overflow=10,
            connect_args=connect_args,
            future=True
        )
        # quick smoke test: don't execute heavy queries, just a connection check
        with _engine.connect() as conn:
            conn.execute(sa_text("SELECT 1"))
        logger.info("‚úÖ Database engine created and connection checked")
        return _engine

    except OperationalError as e:
        logger.error("‚ùå OperationalError while creating engine: %s", e)
        # keep _engine as None so callers can decide what to do
        raise
    except SQLAlchemyError as e:
        logger.error("‚ùå SQLAlchemyError while creating engine: %s", e)
        raise

# Provide module-level alias for callers that expect `engine` at import time.
# We attempt to create it immediately (useful for production), but do not hide errors.
try:
    # Try to create engine immediately if URL is present (common on deployed hosts).
    if _engine is None:
        _engine = get_engine()
except Exception as exc:
    # Log the failure but do not crash import time with obscure stack traces.
    # Higher-level code (app init or alembic) should catch and handle.
    logger.warning("Engine not created at import: %s", exc)
    _engine = None

# ---------------- Session factory ----------------
# SessionLocal is bound if engine exists; if engine is None, callers should call get_engine() first.
SessionLocal = sessionmaker(autocommit=False, autoflush=False, future=True, bind=_engine)  # type: ignore[arg-type]

def get_db_session() -> SessionType:
    """
    Return a new SQLAlchemy Session. Ensures engine exists first.
    Usage:  session = get_db_session()
    """
    try:
        if _engine is None:
            # attempt to create engine now (will raise a clear error if missing)
            get_engine()
            # rebind SessionLocal to the engine we just created
            global SessionLocal
            SessionLocal.configure(bind=_engine)  # type: ignore[attr-defined]
        return SessionLocal()
    except Exception as e:
        logger.error("‚ùå Error creating database session: %s", e)
        raise

# ---------- Transaction helpers ----------
def safe_commit(session: SessionType, context: str = "Operation") -> bool:
    try:
        session.commit()
        logger.debug("‚úÖ Commit succeeded (%s)", context)
        return True
    except Exception as e:
        logger.error("‚ùå Commit failed (%s): %s", context, e)
        try:
            session.rollback()
            logger.debug("üîÑ Rollback executed after failed commit (%s)", context)
        except Exception as rollback_err:
            logger.error("‚ùå Rollback failed (%s): %s", context, rollback_err)
        return False

def safe_rollback(session: SessionType, context: str = "Operation") -> bool:
    try:
        session.rollback()
        logger.debug("üîÑ Rollback succeeded (%s)", context)
        return True
    except Exception as e:
        logger.error("‚ùå Rollback failed (%s): %s", context, e)
        return False

# ---------- Optional helpers ----------
def init_database() -> bool:
    """
    Optional initialization ‚Äî checks the DB connectivity and optionally ensures tables exist.
    Returns True if connection is verified.
    """
    try:
        # Create a session (ensures engine exists)
        with get_db_session() as s:
            s.execute(sa_text("SELECT 1"))   # explicit sqlalchemy.text()
        logger.info("‚úÖ Database connection successful")
        return True
    except Exception as e:
        logger.error("‚ùå Database initialization failed: %s", e)
        raise




# ====== End of backend/db/session.py ======

