

# ====== Begin of app.py ======

"""
PROFESSIONAL Construction Project Planner - FIXED VERSION
Unified Session Management & Transaction Safety
"""

import streamlit as st
import logging
import sys
import os
from sqlalchemy.orm import Session
from typing import Optional, Callable,Dict,  Any
from contextlib import contextmanager

# Add backend to path
sys.path.append(os.path.join(os.path.dirname(__file__), 'backend'))

# Configure professional logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class ConstructionApp:
    """
    FIXED Professional main application with unified session management
    """

    def __init__(self):
        self._setup_page_config()
        self._initialize_session_state()
        self._initialize_database()

    # ------------------- Initialization -------------------

    def _setup_page_config(self):
        """Setup professional page configuration"""
        st.set_page_config(
            page_title="Construction Project Planner",
            page_icon="ðŸ—ï¸",
            layout="wide",
            initial_sidebar_state="expanded",
            menu_items={
                'Get Help': 'https://github.com/your-repo/construction-planner',
                'Report a bug': "https://github.com/your-repo/construction-planner/issues",
                'About': "### ðŸ—ï¸ Construction Project Planner\nProfessional construction scheduling and resource management system"
            }
        )

    def _initialize_session_state(self):
        """Initialize unified session state"""
        # 1. Authentication Session Manager (User identity & permissions)
        if 'auth_session_manager' not in st.session_state:
            from backend.auth.session_manager import SessionManager
            st.session_state.auth_session_manager = SessionManager()
            logger.info("âœ… Authentication session manager initialized")

        # 2. Application state defaults
        defaults = {
            'app_initialized': True,
            'current_page': 'login',
            'current_project_id': None,
            'current_project_name': None,
            'navigation_section': 'scheduling',
            '_previous_page': None,
            'widget_debug': False,
            'project_config': {
                'basic_info': {
                    'project_name': 'My Construction Project',
                    'project_manager': '',
                    'start_date': None,
                    'description': '',
                    'project_type': 'Commercial',
                    'client_name': '',
                    'location': ''
                },
                'zones': {},
                'advanced_settings': {
                    'work_hours_per_day': 8,
                    'acceleration_factor': 1.0,
                    'risk_allowance': 0.1
                }
            },
            'project_zones': {}
        }

        for key, value in defaults.items():
            if key not in st.session_state:
                st.session_state[key] = value

    def _initialize_database(self):
        """Initialize database connection professionally"""
        try:
            from backend.db.session import init_database
            init_database()
            logger.info("âœ… Database initialized successfully")
        except Exception as e:
            logger.error(f"âŒ Database initialization failed: {e}")
            st.warning("âš ï¸ Database connection unavailable - using session storage")

    # ------------------- Session Management -------------------

    def _is_authenticated(self) -> bool:
        """Check if user is authenticated via auth session manager"""
        auth_manager = st.session_state.auth_session_manager
        return hasattr(auth_manager, 'is_authenticated') and auth_manager.is_authenticated()

    def _get_current_user_id(self) -> Optional[int]:
        """Get current user ID safely via auth session manager"""
        if self._is_authenticated():
            return st.session_state.auth_session_manager.get_user_id()
        return None

    def _initialize_services(self, db_session: Session, user_id: int) -> Dict[str, Any]:
        """
        Initialize all services with the current database session
        These services are request-scoped and not stored in session state
        """
        try:
            from backend.services.project_service import ProjectService
            from backend.services.user_task_service import UserTaskService
            from backend.services.resource_service import ResourceService
            from backend.services.template_service import TemplateService
            from backend.services.zone_sequence_service import ZoneSequenceService
            from backend.services.scheduling_service import SchedulingService
            from backend.services.reporting_service import ReportingService
            from backend.services.monitoring_service import MonitoringService
            
            services = {
                'project_service': ProjectService(db_session),
                'task_service': UserTaskService(db_session),
                'resource_service': ResourceService(db_session),
                'template_service': TemplateService(db_session),
                'zone_sequence_service': ZoneSequenceService(db_session),
                'Scheduling_service': SchedulingService(db_session),
                'reporting_service': ReportingService(db_session),
                'monitoring_service': MonitoringService(db_session),
            }
            
            logger.info("âœ… Services initialized with request-scoped session")
            return services
            
        except Exception as e:
            logger.error(f"âŒ Error initializing services: {e}")
            return {}
    


    @contextmanager
    def _database_session_scope(self):
        """
        Professional database transaction scope for entire page lifecycle
        Auto-commit on success, auto-rollback on exception
        """
        from backend.db.session import get_db_session, safe_commit, safe_rollback
        
        session = get_db_session()
        try:
            logger.debug("ðŸŽ¯ Starting page transaction scope")
            yield session
            # Commit on successful completion
            safe_commit(session, "Page transaction")
            logger.debug("âœ… Page transaction completed successfully")
            
        except Exception as e:
            # Rollback on any exception
            safe_rollback(session, f"Page transaction failed: {str(e)}")
            logger.error(f"âŒ Transaction rolled back due to error: {e}")
            raise
            
        finally:
            # Always close session
            try:
                session.close()
                logger.debug("ðŸ”’ Database session closed")
            except Exception as e:
                logger.error(f"âŒ Error closing session: {e}")

    # ------------------- Page Routing -------------------

    def _route_to_page(self, db_session, services: Dict, user_id: int):
        """Route to current page with provided database session"""
        page = st.session_state.get('current_page', 'login')

        # Import all page modules
        from pages import login, project_setup, register
        from frontend.pages import (
            zone_sequence, templates_manager, 
            generate_schedule, progress_monitoring, 
            performance_dashboard, reports_analytics
        )

        # Map pages to their show functions with session
        page_mapping = {
            # Authentication Pages
            'login': lambda: login.show(),
            'register': lambda: register.show(),

            # Scheduling Section
            'project_setup': lambda: project_setup.show(db_session, services, user_id),
            'zone_sequence': lambda: zone_sequence.show(db_session, services, user_id),
            'templates_manager': lambda: templates_manager.show(db_session, services, user_id),
            'generate_schedule': lambda: generate_schedule.show(db_session, services, user_id),

            # Monitoring Section
            'progress_monitoring': lambda: progress_monitoring.show(db_session, services, user_id),
            'performance_dashboard': lambda: performance_dashboard.show(db_session, services, user_id),
            'reports_analytics': lambda: reports_analytics.show(db_session, services, user_id),
        }

        # Execute page function
        page_function = page_mapping.get(page, self._render_error_page)
        page_function()

    def _render_error_page(self):
        """Render error page for unknown routes"""
        st.error(f"âŒ Page not found: {st.session_state.get('current_page')}")
        if st.button("ðŸ  Return to Home"):
            st.session_state.current_page = "project_setup"
            st.rerun()

    # ------------------- Interface Rendering -------------------

    def _render_authenticated_interface(self):
        """
        FIXED: Professional authenticated interface with unified session management
        """
        try:
            # Single database transaction for entire page lifecycle
            with self._database_session_scope() as db_session:
                # Get user context from auth session manager
                auth_manager = st.session_state.auth_session_manager
                user_id = auth_manager.get_user_id()
                username = auth_manager.get_username()
                user_role = auth_manager.get_user_role()

                logger.info(f"ðŸ‘¤ Rendering interface for: {username} (ID: {user_id}, Role: {user_role})")

                # âœ… FIXED: Initialize services with current session (not stored)
                services = self._initialize_services(db_session, user_id)

                # Widget management
                if 'widget_manager' not in st.session_state:
                    from backend.utils.widget_manager import widget_manager
                    st.session_state.widget_manager = widget_manager
                
                widget_manager = st.session_state.widget_manager
                current_page = st.session_state.get('current_page', 'unknown')
                
                # Clean up previous page keys
                previous_page = st.session_state.get('_previous_page')
                if previous_page and previous_page != current_page:
                    widget_manager.cleanup_page_keys(previous_page)
                    logger.info(f"ðŸ”„ Cleaned up widget keys for previous page: {previous_page}")
                
                st.session_state._previous_page = current_page
                
                # Render interface components
                self._render_interface_components(db_session,  services, user_id, username, user_role)

        except Exception as e:
            logger.error(f"âŒ Error in authenticated interface: {e}")
            self._show_error_page(e)

    def _render_interface_components(self, db_session, services: Dict, user_id: int, username: str, user_role: str):
        """Render all UI components with proper session context"""
        from frontend.components.navigation.sidebar import render_main_sidebar
        from frontend.components.navigation.header import render_page_header

        # -------------------
        # Render Sidebar with user context
        # -------------------
        render_main_sidebar(db_session, user_id, st.session_state.navigation_section)

        # -------------------
        # Render Main Content Header
        # -------------------
        current_page_name = st.session_state.get('current_page', 'Dashboard')
        render_page_header(
            title=current_page_name.replace('_', ' ').title(),
            description=f"User: {username} | Role: {user_role}",
            icon="ðŸ“Š",
            show_breadcrumbs=True,
            breadcrumbs=[current_page_name.replace('_', ' ').title()]
        )

        # -------------------
        # Render Page Content with database session
        # -------------------
        self._route_to_page(db_session, services,user_id)

    def _render_login_interface(self):
        """Render login page (no database session needed)"""
        try:
            from pages.login import show as show_login_page
            show_login_page()
        except Exception as e:
            logger.error(f"âŒ Login page error: {e}")
            self._show_error_page(e)

    # ------------------- Error Handling -------------------

    def _show_error_page(self, error: Exception):
        """Professional error page with technical details"""
        st.error("""
        âŒ Application Error
        We encountered an unexpected error. Please:
        1. Refresh the page
        2. Check your internet connection
        3. Contact support if the issue persists
        """)
        with st.expander("Technical Details (For Support)"):
            st.code(f"Error Type: {type(error).__name__}\nError Message: {str(error)}")

        if st.button("ðŸ”„ Restart Application"):
            # Clear critical session state and rerun
            keys_to_keep = ['auth_session_manager', 'widget_manager']
            for key in list(st.session_state.keys()):
                if key not in keys_to_keep:
                    del st.session_state[key]
            st.rerun()

    # ------------------- Utilities -------------------

    def _show_widget_debug_info(self):
        """Show widget debugging information (optional)"""
        if st.session_state.get('widget_debug'):
            with st.sidebar.expander("ðŸ”§ Widget Debug Info", expanded=False):
                if 'widget_manager' in st.session_state:
                    stats = st.session_state.widget_manager.get_registry_stats()
                    st.write(f"**Total Widget Keys:** {stats['total_keys']}")
                    st.write(f"**Active Pages:** {stats['pages']}")
                    st.write(f"**Users in Registry:** {stats['users']}")
                
                if st.button("Clear Widget Registry"):
                    if 'widget_key_registry' in st.session_state:
                        st.session_state.widget_key_registry = set()
                    if 'widget_key_context' in st.session_state:
                        st.session_state.widget_key_context = {}
                    st.rerun()

    # ------------------- Main Run Method -------------------

    def run(self):
        """Run the professional application with enhanced session management"""
        try:

            
            # Route based on authentication
            if self._is_authenticated():
                self._render_authenticated_interface()
            else:
                self._render_login_interface()
                
            # Optional debug information
            self._show_widget_debug_info()
                
        except Exception as e:
            logger.error(f"âŒ Fatal application error: {e}")
            self._show_error_page(e)

# ------------------- Entry Point -------------------

if __name__ == "__main__":
    app = ConstructionApp()
    app.run()


    

# ====== End of app.py ======



# ====== Begin of backend/db/session.py ======

"""
PROFESSIONAL Database Session Management
Enhanced with transaction control for Streamlit architecture
"""
import os
import logging
from sqlalchemy import create_engine, text
from sqlalchemy.orm import sessionmaker
from sqlalchemy.pool import QueuePool
from dotenv import load_dotenv

load_dotenv()

logger = logging.getLogger(__name__)

class DatabaseConfig:
    """Database configuration for production"""
    
    DB_HOST = os.getenv('DB_HOST', 'localhost')
    DB_PORT = os.getenv('DB_PORT', '5432')
    DB_NAME = os.getenv('DB_NAME', 'Planitor_db')
    DB_USER = os.getenv('DB_USER', 'postgres')
    DB_PASSWORD = os.getenv('DB_PASSWORD', 'ABDOABDO')
    
    @property
    def DATABASE_URL(self):
        """Production database URL"""
        return f"postgresql+psycopg2://{self.DB_USER}:{self.DB_PASSWORD}@{self.DB_HOST}:{self.DB_PORT}/{self.DB_NAME}"

def create_engine_production():
    """Create production-ready database engine"""
    config = DatabaseConfig()
    
    logger.info(f"ðŸ”— Connecting to PostgreSQL: {config.DB_HOST}:{config.DB_PORT}/{config.DB_NAME}")
    
    engine = create_engine(
        config.DATABASE_URL,
        poolclass=QueuePool,
        echo=False,
        pool_pre_ping=True,
        max_overflow=10,
        pool_size=5,
    )
    
    # Test connection
    try:
        with engine.connect() as conn:
            conn.execute(text("SELECT 1"))
        logger.info("âœ… Production database engine created successfully")
    except Exception as e:
        logger.error(f"âŒ Database connection failed: {e}")
        raise
    
    return engine

# Create engine and session factory
engine = create_engine_production()
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

def get_db():
    """
    FastAPI-style database dependency
    Use with: db = next(get_db())
    """
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

def get_db_session():
    """
    Traditional session getter for backward compatibility
    Returns SQLAlchemy session for manual transaction management
    """
    return SessionLocal()

def safe_commit(db_session, operation_name="Operation"):
    """
    Professional safe commit with comprehensive error handling
    Args:
        db_session: SQLAlchemy session instance
        operation_name: Name of operation for logging
    Returns:
        bool: True if commit successful, False otherwise
    """
    try:
        db_session.commit()
        logger.info(f"âœ… {operation_name} committed successfully")
        return True
    except Exception as e:
        logger.error(f"âŒ {operation_name} commit failed: {e}")
        try:
            db_session.rollback()
            logger.info(f"ðŸ”„ Rollback executed after failed commit for {operation_name}")
        except Exception as rollback_error:
            logger.error(f"âŒ Rollback also failed: {rollback_error}")
        return False

def safe_rollback(db_session, operation_name="Operation"):
    """
    Professional safe rollback with comprehensive error handling
    Args:
        db_session: SQLAlchemy session instance
        operation_name: Name of operation for logging
    Returns:
        bool: True if rollback successful, False otherwise
    """
    try:
        db_session.rollback()
        logger.info(f"ðŸ”„ {operation_name} rolled back successfully")
        return True
    except Exception as e:
        logger.error(f"âŒ {operation_name} rollback failed: {e}")
        return False

def init_database():
    """
    Smart database initialization - only creates tables if they don't exist
    Returns:
        bool: True if initialization successful
    """
    try:
        from backend.models.db_models import UserDB
        with engine.connect() as conn:
            try:
                # Try to query users table - if it works, tables exist
                conn.execute(text("SELECT 1 FROM users LIMIT 1"))
                logger.info("âœ… Database tables already exist - skipping creation")
                return True
            except:
                # Tables don't exist, create them
                logger.info("ðŸ”„ Creating database tables...")
                from backend.db.base import Base
                import backend.models.db_models  # This registers all models
                Base.metadata.create_all(bind=engine)
                logger.info("âœ… Database tables created successfully")
                return True
                
    except Exception as e:
        logger.error(f"âŒ Database initialization failed: {e}")
        raise

def close_database():
    """Cleanup database connections"""
    engine.dispose()
    logger.info("âœ… Database connections closed")

def get_database_stats():
    """Get database health metrics"""
    try:
        with engine.connect() as conn:
            result = conn.execute(text("SELECT version()"))
            version = result.scalar()
            
            result = conn.execute(text("SELECT current_database()"))
            db_name = result.scalar()
            
            result = conn.execute(text("SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public'"))
            table_count = result.scalar()
            
            return {
                'status': 'connected',
                'version': version.split(',')[0],
                'database': db_name,
                'table_count': table_count
            }
    except Exception as e:
        return {'status': 'error', 'error': str(e)}

# Repository factory functions
def get_user_repository(db_session):
    """Get user repository instance"""
    from backend.db.repositories.user_repo import UserRepository
    return UserRepository(db_session)

def get_project_repository(db_session):
    """Get project repository instance"""
    from backend.db.repositories.project_repo import ProjectRepository
    return ProjectRepository(db_session)

def get_schedule_repository(db_session):
    """Get schedule repository instance"""
    from backend.db.repositories.schedule_repo import ScheduleRepository
    return ScheduleRepository(db_session)

def get_task_repository(db_session):
    """Get task repository instance"""
    from backend.db.repositories.task_repo import TaskRepository
    return TaskRepository(db_session)

def get_progress_repository(db_session):
    """Get progress repository instance"""
    from backend.db.repositories.progress_repo import ProgressRepository
    return ProgressRepository(db_session)

def get_resource_repository(db_session):
    """Get resource repository instance"""
    from backend.db.repositories.resource_repo import ResourceRepository
    return ResourceRepository(db_session)

def get_report_repository(db_session):
    """Get report repository instance"""
    from backend.db.repositories.report_repo import ReportRepository
    return ReportRepository(db_session)

# ====== End of backend/db/session.py ======



# ====== Begin of backend/auth/session_manager.py ======

"""
FIXED SessionManager - Authentication state ONLY (no database transactions)
"""
import streamlit as st
import logging
from typing import Optional, Dict, Any
from datetime import datetime, timedelta 

logger = logging.getLogger(__name__)

class SessionManager:
    """
    FIXED: Manages USER AUTHENTICATION state only
    No database transaction control here
    """
    
    def __init__(self, session_timeout_minutes: int = 120):
        self.session_timeout_minutes = session_timeout_minutes
        self._initialize_session_state()
    
    def _initialize_session_state(self):
        """Initialize authentication session state only"""
        # Authentication state
        if 'user_id' not in st.session_state:
            st.session_state.user_id = None
        if 'username' not in st.session_state:
            st.session_state.username = None
        if 'role' not in st.session_state:
            st.session_state.role = None
        if 'authenticated' not in st.session_state:
            st.session_state.authenticated = False
        if 'login_time' not in st.session_state:
            st.session_state.login_time = None
        if 'last_activity' not in st.session_state:
            st.session_state.last_activity = None
        if 'token' not in st.session_state:
            st.session_state.token = None
        
        # Backward compatibility
        if 'user' not in st.session_state:
            st.session_state.user = None
    
    def create_session(self, user_info: Dict[str, Any]) -> bool:
        """
        Create user session - AUTHENTICATION ONLY
        """
        try:
            # Authentication state
            st.session_state.user_id = user_info.get('user_id')
            st.session_state.username = user_info.get('username')
            st.session_state.role = user_info.get('role')
            st.session_state.authenticated = True
            st.session_state.login_time = datetime.now()
            st.session_state.last_activity = datetime.now()
            st.session_state.token = user_info.get('token')
            
            # Backward compatibility
            st.session_state.user = {
                'id': user_info.get('user_id'),
                'username': user_info.get('username'),
                'role': user_info.get('role'),
                'full_name': user_info.get('full_name', user_info.get('username')),
                'email': user_info.get('email', '')
            }
            
            logger.info(f"Authentication session created for user: {user_info.get('username')}")
            return True
            
        except Exception as e:
            logger.error(f"Error creating authentication session: {e}")
            return False
    
    def is_authenticated(self) -> bool:
        """Check authentication state only"""
        if not st.session_state.get('authenticated', False):
            return False
        
        # Check session timeout
        if self._is_session_expired():
            logger.info(f"Authentication session expired for user: {st.session_state.username}")
            self.logout()
            return False
        
        # Update last activity
        st.session_state.last_activity = datetime.now()
        return True
    
    def _is_session_expired(self) -> bool:
        """Check if authentication session expired"""
        last_activity = st.session_state.get('last_activity')
        if not last_activity:
            return True
        
        timeout_delta = timedelta(minutes=self.session_timeout_minutes)
        return datetime.now() - last_activity > timeout_delta
    
    def logout(self):
        """
        Enhanced logout with comprehensive session cleanup
        """
        user_id = self.get_user_id()
        username = self.get_username()
        
        # Use centralized session cleaner
        from backend.utils.session_cleaner import SessionCleaner
        cleaned_count = SessionCleaner.clean_user_session(user_id)
        
        logger.info(f"User {username} (ID: {user_id}) logged out - {cleaned_count} session items cleaned")
    
    def get_user_id(self) -> Optional[int]:
        """Get current user ID"""
        return st.session_state.get('user_id')
    
    def get_username(self) -> Optional[str]:
        """Get current username"""
        return st.session_state.get('username')
    
    def get_user_role(self) -> Optional[str]:
        """Get current user role"""
        return st.session_state.get('role')
    
    def get_session_info(self) -> Dict[str, Any]:
        """Get complete session information"""
        return {
            'user_id': st.session_state.get('user_id'),
            'username': st.session_state.get('username'),
            'role': st.session_state.get('role'),
            'authenticated': st.session_state.get('authenticated', False),
            'login_time': st.session_state.get('login_time'),
            'last_activity': st.session_state.get('last_activity'),
            'current_project': st.session_state.get('current_project'),
            'session_duration': self._get_session_duration(),
            'time_remaining': self._get_time_remaining()
        }
    
    def _get_session_duration(self) -> Optional[float]:
        """Get session duration in minutes"""
        login_time = st.session_state.get('login_time')
        if not login_time:
            return None
        
        return (datetime.now() - login_time).total_seconds() / 60
    
    def _get_time_remaining(self) -> Optional[float]:
        """Get time remaining until session timeout in minutes"""
        last_activity = st.session_state.get('last_activity')
        if not last_activity:
            return None
        
        elapsed = (datetime.now() - last_activity).total_seconds() / 60
        return max(0, self.session_timeout_minutes - elapsed)
    
    def update_activity(self):
        """Update last activity timestamp"""
        st.session_state.last_activity = datetime.now()
    
    def set_current_project(self, project_name: str):
        """Set current active project"""
        st.session_state.current_project = project_name
        self.update_activity()
    
    def get_current_project(self) -> Optional[str]:
        """Get current active project"""
        return st.session_state.get('current_project')
    
    def set_current_page(self, page_name: str):
        """Set current page for navigation highlighting"""
        st.session_state.current_page = page_name
        self.update_activity()
    
    def get_current_page(self) -> Optional[str]:
        """Get current page"""
        return st.session_state.get('current_page')
    
    def has_permission(self, permission: str) -> bool:
        """
        Check if current user has specific permission
        
        Args:
            permission: Permission to check
            
        Returns:
            bool: True if user has permission
        """
        from .permissions import check_permission
        return check_permission(st.session_state.get('role'), permission)
    
    def is_admin(self) -> bool:
        """Check if current user is admin"""
        return st.session_state.get('role') == 'Admin'
    
    def is_manager(self) -> bool:
        """Check if current user is manager or admin"""
        role = st.session_state.get('role')
        return role in ['Directeur', 'Admin']
    
    def get_session_timeout_warning(self) -> Optional[Dict[str, Any]]:
        """
        Get session timeout warning information
        
        Returns:
            Dict with warning info if session is about to expire, None otherwise
        """
        time_remaining = self._get_time_remaining()
        
        if time_remaining and time_remaining <= 5:  # 5 minutes remaining
            return {
                'minutes_remaining': round(time_remaining, 1),
                'message': f"Votre session expirera dans {round(time_remaining, 1)} minutes",
                'severity': 'warning' if time_remaining > 1 else 'error'
            }
        
        return None
    
    def get_user(self) -> Optional[Dict]:
        """Backward compatibility method for old code"""
        if not self.is_authenticated():
            return None
    
        return {
        'id': self.get_user_id(),
        'username': self.get_username(), 
        'role': self.get_user_role(),
        'full_name': st.session_state.get('user', {}).get('full_name', '')
        }

    @property
    def user(self) -> Optional[Dict]:
        """Property access for backward compatibility"""
        return self.get_user()

# ====== End of backend/auth/session_manager.py ======



# ====== Begin of backend/utils/widget_manager.py ======

"""
PROFESSIONAL Widget Key Management System
Enhanced with PROPER session state initialization
"""
import streamlit as st
import hashlib
import logging
from typing import Optional, Set, Dict, Any
from datetime import datetime

logger = logging.getLogger(__name__)

class StableWidgetKeyManager:
    """
    Professional widget key manager with PROPER session state initialization
    """
    
    def __init__(self):
        # âœ… PROPERLY initialize ALL session state components
        self._initialize_key_registry()
    
    def _initialize_key_registry(self):
        """
        CRITICAL: Initialize ALL session state components
        This must be called in __init__ to ensure everything exists
        """
        # Initialize each component individually with safe defaults
        if 'widget_key_registry' not in st.session_state:
            st.session_state.widget_key_registry = set()
        
        if 'widget_key_context' not in st.session_state:
            st.session_state.widget_key_context = {}
            
        # âœ… THIS WAS MISSING - Initialize the counters dictionary
        if 'widget_key_counters' not in st.session_state:
            st.session_state.widget_key_counters = {}
    
    def generate_key(self, base_key: str, page_context: str = None, user_id: str = None) -> str:
        """
        Generate STABLE widget key with SAFE session state access
        """
        # âœ… ENSURE session state is initialized before accessing
        self._initialize_key_registry()
        
        # Create deterministic key components
        key_components = [
            str(base_key),
            str(page_context) if page_context else "global",
            str(user_id) if user_id else "anonymous"
        ]
        
        # Create stable fingerprint
        key_fingerprint = self._create_stable_fingerprint(key_components)
        
        # âœ… SAFE ACCESS: Counter key should now exist
        counter_key = f"{key_fingerprint}_counter"
        
        # Initialize counter if it doesn't exist
        if counter_key not in st.session_state.widget_key_counters:
            st.session_state.widget_key_counters[counter_key] = 0
        
        # Final key with counter for uniqueness
        final_key = f"widget_{key_fingerprint}_{st.session_state.widget_key_counters[counter_key]}"
        
        # Register the key (only if new)
        if final_key not in st.session_state.widget_key_registry:
            st.session_state.widget_key_registry.add(final_key)
            st.session_state.widget_key_context[final_key] = {
                'base_key': base_key,
                'page_context': page_context,
                'user_id': user_id,
                'fingerprint': key_fingerprint,
                'created_at': datetime.now().isoformat()
            }
        
        return final_key
    
    def _create_stable_fingerprint(self, components: list) -> str:
        """
        Create STABLE fingerprint from key components
        """
        key_string = "::".join(components)
        return hashlib.md5(key_string.encode()).hexdigest()[:12]
    
    def cleanup_page_keys(self, page_context: str):
        """
        Clean up keys for a specific page context
        """
        if not page_context:
            return
        
        # âœ… ENSURE session state is initialized
        self._initialize_key_registry()
            
        keys_to_remove = [
            key for key in st.session_state.widget_key_registry.copy()
            if st.session_state.widget_key_context.get(key, {}).get('page_context') == page_context
        ]
        
        for key in keys_to_remove:
            st.session_state.widget_key_registry.discard(key)
            if key in st.session_state.widget_key_context:
                del st.session_state.widget_key_context[key]
    
        
    def cleanup_user_keys(self, user_id: str) -> int:
        """
        Clean up all widget keys for a specific user
        
        This method removes all widget keys associated with a user when they log out,
        preventing memory leaks and ensuring clean session state. 
       """
        self._initialize_key_registry()
        
        if not user_id:
            return 0
        
        user_id_str = str(user_id)
        keys_to_remove = []
        
        # Find all keys for this user
        for key in st.session_state.widget_key_registry.copy():
            key_context = st.session_state.widget_key_context.get(key, {})
            if key_context.get('user_id') == user_id_str:
                keys_to_remove.append(key)
        
        # Remove keys and clean up counters
        for key in keys_to_remove:
            self._remove_key_with_counter_cleanup(key)
        
        logger.info(f"Cleaned up {len(keys_to_remove)} widget keys for user {user_id_str}")
        return len(keys_to_remove)
    
    def _remove_key_with_counter_cleanup(self, key: str):
        """Remove key and clean up associated counter if unused"""
        if key in st.session_state.widget_key_context:
            fingerprint = st.session_state.widget_key_context[key].get('fingerprint')
            del st.session_state.widget_key_context[key]
        
        st.session_state.widget_key_registry.discard(key)
        
        # Clean up counter if no other keys use this fingerprint
        if fingerprint:
            counter_key = f"{fingerprint}_counter"
            other_keys_exist = any(
                ctx.get('fingerprint') == fingerprint 
                for ctx in st.session_state.widget_key_context.values()
            )
            if not other_keys_exist and counter_key in st.session_state.widget_key_counters:
                del st.session_state.widget_key_counters[counter_key]

    def get_registry_stats(self) -> Dict[str, Any]:
        """Get professional statistics about widget key usage"""
        # âœ… ENSURE session state is initialized
        self._initialize_key_registry()
        
        contexts = [
            ctx.get('page_context', 'global') 
            for ctx in st.session_state.widget_key_context.values()
        ]
        
        users = [
            ctx.get('user_id', 'anonymous') 
            for ctx in st.session_state.widget_key_context.values()
        ]
        
        return {
            'total_keys': len(st.session_state.widget_key_registry),
            'active_pages': list(set(contexts)),
            'active_users': list(set(users)),
            'key_distribution': {
                page: contexts.count(page) 
                for page in set(contexts)
            }
        }

# Global professional instance
widget_manager = StableWidgetKeyManager()

# ====== End of backend/utils/widget_manager.py ======



# ====== Begin of backend/utils/error_handler.py ======

# backend/core/error_handler.py
"""
Unified Error Handling System
"""
import logging
from typing import Any, Optional, Dict, Union
from functools import wraps
from sqlalchemy.exc import SQLAlchemyError

logger = logging.getLogger(__name__)

class AppError(Exception):
    """Base application error with consistent structure"""
    def __init__(self, message: str, code: str = "UNKNOWN_ERROR", details: Dict = None):
        self.message = message
        self.code = code
        self.details = details or {}
        super().__init__(self.message)

class ErrorHandler:
    """Professional error handling with consistent patterns"""
    
    # Standard error codes
    ERROR_CODES = {
        'VALIDATION_ERROR': 'Data validation failed',
        'AUTH_ERROR': 'Authentication failed',
        'NOT_FOUND': 'Resource not found',
        'PERMISSION_DENIED': 'Insufficient permissions',
        'DATABASE_ERROR': 'Database operation failed',
        'INTEGRITY_ERROR': 'Data integrity violation'
    }
    
    @classmethod
    def handle_error(cls, 
                   operation: str, 
                   error: Exception,
                   return_none: bool = False,
                   log_level: str = 'ERROR') -> Optional[Any]:
        """
        Unified error handling with consistent return patterns
        
        Args:
            operation: Description of the operation
            error: Exception that occurred
            return_none: Whether to return None on error
            log_level: Logging level
            
        Returns:
            None if return_none=True, otherwise raises AppError
        """
        # Log the error
        log_method = getattr(logger, log_level.lower(), logger.error)
        log_method(f"Error in {operation}: {error}", exc_info=True)
        
        # Convert to AppError if needed
        if not isinstance(error, AppError):
            error = cls._categorize_error(error, operation)
        
        if return_none:
            return None
        else:
            raise error
    
    @classmethod
    def _categorize_error(cls, error: Exception, operation: str) -> AppError:
        """Categorize generic exceptions into AppError types"""
        if isinstance(error, SQLAlchemyError):
            return AppError(
                message=f"Database error in {operation}",
                code="DATABASE_ERROR",
                details={'original_error': str(error)}
            )
        elif isinstance(error, ValueError):
            return AppError(
                message=f"Validation error in {operation}: {error}",
                code="VALIDATION_ERROR",
                details={'original_error': str(error)}
            )
        elif isinstance(error, PermissionError):
            return AppError(
                message=f"Permission denied for {operation}",
                code="PERMISSION_DENIED",
                details={'original_error': str(error)}
            )
        else:
            return AppError(
                message=f"Unexpected error in {operation}: {error}",
                code="UNKNOWN_ERROR",
                details={'original_error': str(error)}
            )

def error_decorator(return_none: bool = False, log_level: str = 'ERROR'):
    """Decorator for consistent error handling in functions"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            try:
                return func(*args, **kwargs)
            except Exception as e:
                return ErrorHandler.handle_error(
                    operation=f"{func.__module__}.{func.__name__}",
                    error=e,
                    return_none=return_none,
                    log_level=log_level
                )
        return wrapper
    return decorator

# ====== End of backend/utils/error_handler.py ======



# ====== Begin of backend/utils/session_cleaner.py ======

# backend/core/session_cleaner.py
"""
Centralized Session Cleaner for User Logout
"""
import streamlit as st
import logging
from typing import Set

logger = logging.getLogger(__name__)

class SessionCleaner:
    """Professional session state cleanup manager"""
    
    # Keys that should persist across users (app configuration)
    PERSISTENT_KEYS = {
        'app_initialized', 'widget_debug', 'widget_manager', 
        'auth_session_manager', '_pages'
    }
    
    # User-specific keys to clean on logout
    USER_SESSION_KEYS = {
        # Authentication
        'user_id', 'username', 'role', 'authenticated', 'login_time', 
        'last_activity', 'token', 'user',
        
        # Project data
        'current_project_id', 'current_project_name', 'current_project',
        'project_config', 'project_zones', 'project_sequences',
        
        # Schedule data
        'schedule_generated', 'schedule_results', 'selected_task_template',
        'selected_resource_template', 'input_method', 'reports_folder',
        
        # UI state
        'current_page', 'navigation_section', '_previous_page',
        
        # Uploads and caches
        'uploaded_files', 'file_cache', 'template_cache',
        
        # Form states
        'form_data', 'edit_mode', 'selected_items'
    }
    
    @classmethod
    def clean_user_session(cls, user_id: int = None) -> int:
        """
        Comprehensive user session cleanup
        Returns number of keys cleaned
        """
        cleaned_count = 0
        
        # Clean widget keys for user
        if user_id and 'widget_manager' in st.session_state:
            try:
                widget_manager = st.session_state.widget_manager
                if hasattr(widget_manager, 'cleanup_user_keys'):
                    keys_cleaned = widget_manager.cleanup_user_keys(str(user_id))
                    logger.info(f"Cleaned up {keys_cleaned} widget keys for user {user_id}")
            except Exception as e:
                logger.error(f"Error cleaning widget keys: {e}")
        
        # Clean user-specific session state
        for key in list(st.session_state.keys()):
            if key not in cls.PERSISTENT_KEYS and key in cls.USER_SESSION_KEYS:
                del st.session_state[key]
                cleaned_count += 1
                logger.debug(f"Cleaned session key: {key}")
        
        # Reset navigation to login
        st.session_state.current_page = 'login'
        st.session_state.navigation_section = 'scheduling'
        
        logger.info(f"Session cleanup completed: {cleaned_count} keys removed")
        return cleaned_count

# ====== End of backend/utils/session_cleaner.py ======



# ====== Begin of backend/utils/validators.py ======

# backend/core/validator.py
"""
Centralized Input Validation System
"""
import re
from typing import Any, Dict, List, Optional, Tuple
from datetime import datetime, date
from email_validator import validate_email, EmailNotValidError

class Validator:
    """Professional input validation with consistent patterns"""
    
    @staticmethod
    def validate_project_data(project_data: Dict) -> Tuple[bool, List[str]]:
        """Validate project creation/update data"""
        errors = []
        
        # Required fields
        required_fields = ['name', 'start_date']
        for field in required_fields:
            if not project_data.get(field):
                errors.append(f"Missing required field: {field}")
        
        # Name validation
        name = project_data.get('name', '')
        if name and (len(name) < 2 or len(name) > 200):
            errors.append("Project name must be between 2 and 200 characters")
        
        # Date validation
        start_date = project_data.get('start_date')
        if start_date:
            if isinstance(start_date, str):
                try:
                    datetime.fromisoformat(start_date.replace('Z', '+00:00'))
                except ValueError:
                    errors.append("Invalid start date format")
            elif isinstance(start_date, (datetime, date)):
                if start_date < date.today():
                    errors.append("Start date cannot be in the past")
        
        # Zones validation
        zones = project_data.get('zones', {})
        if not isinstance(zones, dict):
            errors.append("Zones must be a dictionary")
        else:
            for zone_name, zone_config in zones.items():
                zone_errors = Validator._validate_zone_config(zone_name, zone_config)
                errors.extend(zone_errors)
        
        return len(errors) == 0, errors
    
    @staticmethod
    def _validate_zone_config(zone_name: str, zone_config: Dict) -> List[str]:
        """Validate individual zone configuration"""
        errors = []
        
        if not isinstance(zone_name, str) or not zone_name.strip():
            errors.append("Zone name must be a non-empty string")
        
        if not isinstance(zone_config, dict):
            errors.append(f"Zone {zone_name} configuration must be a dictionary")
            return errors
        
        # Validate max_floors
        max_floors = zone_config.get('max_floors')
        if not isinstance(max_floors, int) or max_floors < 1:
            errors.append(f"Zone {zone_name}: max_floors must be positive integer")
        
        # Validate sequence
        sequence = zone_config.get('sequence', 1)
        if not isinstance(sequence, int) or sequence < 1:
            errors.append(f"Zone {zone_name}: sequence must be positive integer")
        
        return errors
    
    @staticmethod
    def validate_user_data(user_data: Dict, is_update: bool = False) -> Tuple[bool, List[str]]:
        """Validate user registration/update data"""
        errors = []
        
        if not is_update:
            # Registration validation
            required_fields = ['username', 'email', 'password']
            for field in required_fields:
                if not user_data.get(field):
                    errors.append(f"Missing required field: {field}")
        
        # Username validation
        username = user_data.get('username')
        if username:
            if len(username) < 3 or len(username) > 50:
                errors.append("Username must be between 3 and 50 characters")
            if not re.match(r'^[a-zA-Z0-9_]+$', username):
                errors.append("Username can only contain letters, numbers, and underscores")
        
        # Email validation
        email = user_data.get('email')
        if email:
            try:
                validate_email(email)
            except EmailNotValidError as e:
                errors.append(str(e))
        
        # Password validation (only for new users or password changes)
        password = user_data.get('password')
        if password and not is_update:
            password_errors = Validator._validate_password(password)
            errors.extend(password_errors)
        
        return len(errors) == 0, errors
    
    @staticmethod
    def _validate_password(password: str) -> List[str]:
        """Validate password strength"""
        errors = []
        
        if len(password) < 8:
            errors.append("Password must be at least 8 characters long")
        if not re.search(r'[A-Z]', password):
            errors.append("Password must contain at least one uppercase letter")
        if not re.search(r'[a-z]', password):
            errors.append("Password must contain at least one lowercase letter")
        if not re.search(r'\d', password):
            errors.append("Password must contain at least one digit")
        if not re.search(r'[!@#$%^&*(),.?":{}|<>]', password):
            errors.append("Password must contain at least one special character")
        
        return errors

# ====== End of backend/utils/validators.py ======



# ====== Begin of backend/services/user_service.py ======

"""
Enhanced User service - Fully compatible with new architecture
"""
import logging
from typing import List, Optional, Dict, Any
from sqlalchemy.orm import Session

from backend.db.repositories.user_repo import UserRepository
from backend.models.db_models import UserDB
from backend.utils.security.password_utils import hash_password, verify_password

logger = logging.getLogger(__name__)

class UserService:
    """
    Enhanced User service with proper dependency injection
    """
    
    def __init__(self, db_session: Session):
        # âœ… Accept and use injected db_session
        self.db_session = db_session
        self.user_repo = UserRepository(db_session)
        self.logger = logging.getLogger(__name__)
    
    def get_user_by_id(self, user_id: int) -> Optional[UserDB]:
        """Get user by ID"""
        try:
            return self.user_repo.get_user_by_id(user_id)
        except Exception as e:
            self.logger.error(f"Error getting user by ID {user_id}: {e}")
            return None
    
    def get_user_by_username(self, username: str) -> Optional[UserDB]:
        """Get user by username"""
        try:
            return self.user_repo.get_user_by_username(username)
        except Exception as e:
            self.logger.error(f"Error getting user by username {username}: {e}")
            return None
    
    def get_user_by_email(self, email: str) -> Optional[UserDB]:
        """Get user by email"""
        try:
            return self.user_repo.get_user_by_email(email)
        except Exception as e:
            self.logger.error(f"Error getting user by email {email}: {e}")
            return None
    
    def get_all_users(self) -> List[UserDB]:
        """Get all users (admin only)"""
        try:
            return self.user_repo.get_all_users()
        except Exception as e:
            self.logger.error(f"Error getting all users: {e}")
            return []
    
    def get_user_statistics(self, user_id: int) -> Dict[str, Any]:
        """Get user statistics for dashboard"""
        try:
            # This would typically aggregate user activity data
            return {
                'total_projects': 0,
                'active_projects': 0,
                'completed_projects': 0,
                'recent_activity': []
            }
        except Exception as e:
            self.logger.error(f"Error getting user statistics for {user_id}: {e}")
            return {}
    
    def update_user_profile(self, user_id: int, updates: Dict[str, Any]) -> bool:
        """Update user profile information"""
        try:
            user = self.user_repo.get_user_by_id(user_id)
            if not user:
                return False
            
            # Update allowed fields
            allowed_fields = ['full_name', 'email', 'company', 'phone']
            update_data = {k: v for k, v in updates.items() if k in allowed_fields and v is not None}
            
            if update_data:
                return self.user_repo.update_user(user_id, update_data)
            return True  # No changes needed
            
        except Exception as e:
            self.logger.error(f"Error updating user profile {user_id}: {e}")
            return False
    
    def change_password(self, user_id: int, current_password: str, new_password: str) -> bool:
        """Change user password with verification"""
        try:
            user = self.user_repo.get_user_by_id(user_id)
            if not user:
                return False
            
            # Verify current password
            if not verify_password(current_password, user.password_hash):
                return False
            
            # Hash new password
            new_password_hash = hash_password(new_password)
            
            # Update password
            return self.user_repo.update_user(user_id, {'password_hash': new_password_hash})
            
        except Exception as e:
            self.logger.error(f"Error changing password for user {user_id}: {e}")
            return False
    
    def deactivate_user(self, user_id: int) -> bool:
        """Deactivate user"""
        try:
            return self.user_repo.update_user(user_id, {'is_active': False})
        except Exception as e:
            self.logger.error(f"Error deactivating user {user_id}: {e}")
            return False
    
    def create_user(self, username: str, email: str, password: str,
                   full_name: str = "", role: str = "user") -> Optional[UserDB]:
        """Create new user"""
        try:
            # Check for existing username
            if self.user_repo.get_user_by_username(username):
                self.logger.warning(f"Username already exists: {username}")
                return None
        
            # Check for existing email
            if self.user_repo.get_user_by_email(email):
                self.logger.warning(f"Email already exists: {email}")
                return None

            # Hash password
            password_hash = hash_password(password)

            # Prepare user data
            user_data = {
                "username": username,
                "email": email,
                "password_hash": password_hash,
                "full_name": full_name,
                "role": role,
                "is_active": True
            }

            # Create user
            user = self.user_repo.create_user(user_data)
        
            if user:
                self.logger.info(f"User created successfully: {username}")
                return user
            else:
                self.logger.error(f"User creation failed for: {username}")
                return None

        except Exception as e:
            self.logger.error(f"Error creating user {username}: {e}")
            return None
    
    def authenticate_user(self, username: str, password: str) -> Optional[UserDB]:
        """Authenticate user with username and password"""
        try:
            # Get user by username
            user = self.user_repo.get_user_by_username(username)
        
            if not user or not user.is_active:
                self.logger.warning(f"Authentication failed - user not found or inactive: {username}")
                return None
        
            # Verify password
            if verify_password(password, user.password_hash):
                # Update last login timestamp
                self.user_repo.update_user_last_login(user.id)
                self.logger.info(f"User authenticated successfully: {username}")
                return user
            else:
                self.logger.warning(f"Authentication failed - invalid password for user: {username}")
                return None
        
        except Exception as e:
            self.logger.error(f"Error authenticating user {username}: {e}")
            return None
    
    def update_user_last_login(self, user_id: int) -> bool:
        """Update user's last login timestamp"""
        try:
            return self.user_repo.update_user_last_login(user_id)
        except Exception as e:
            self.logger.error(f"Error updating last login for user {user_id}: {e}")
            return False
    
    # Task template methods (compatible with repository pattern)
    def get_user_task_templates(self, user_id: int, discipline: str = None) -> List[Dict[str, Any]]:
        """Get user task templates"""
        try:
            templates = self.user_repo.get_user_task_templates(user_id, discipline)
            return [self._template_to_dict(template) for template in templates]
        except Exception as e:
            self.logger.error(f"Error getting user task templates: {e}")
            return []
    
    def create_user_task_template(self, user_id: int, template_data: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Create new user task template"""
        try:
            template_data['user_id'] = user_id
            template = self.user_repo.create_user_task_template(template_data)
            return self._template_to_dict(template) if template else None
        except Exception as e:
            self.logger.error(f"Error creating user task template: {e}")
            return None
    
    def _template_to_dict(self, template) -> Dict[str, Any]:
        """Convert template object to dictionary"""
        return {
            'id': getattr(template, 'id', None),
            'name': getattr(template, 'name', ''),
            'discipline': getattr(template, 'discipline', ''),
            'base_duration': getattr(template, 'base_duration', 0),
            'resource_type': getattr(template, 'resource_type', ''),
            'is_active': getattr(template, 'is_active', True)
        }

# ====== End of backend/services/user_service.py ======



# ====== Begin of frontend/components/navigation/__init__.py ======

"""
Professional navigation components for French Construction Project Planner
Compatible with new SessionManager architecture
"""

from .sidebar import (
    render_main_sidebar,
    render_scheduling_navigation,
    render_monitoring_navigation,
    render_user_profile,
    render_quick_stats,
    render_project_selector,
    render_system_footer
)
from .header import (
    render_page_header,
    render_breadcrumbs,
    render_header_actions,
    render_project_selector_header,
    render_quick_action_buttons,
    render_section_indicator,
    render_progress_indicator
)

__all__ = [
    'render_main_sidebar',
    'render_scheduling_navigation',
    'render_monitoring_navigation', 
    'render_user_profile',
    'render_quick_stats',
    'render_project_selector',
    'render_system_footer',
    'render_page_header',
    'render_breadcrumbs',
    'render_header_actions',
    'render_project_selector_header',
    'render_quick_action_buttons',
    'render_section_indicator',
    'render_progress_indicator'
]

# ====== End of frontend/components/navigation/__init__.py ======



# ====== Begin of frontend/components/navigation/sidebar.py ======

"""
Enhanced sidebar navigation - FIXED VERSION
Fully compatible with unified session management
"""
import streamlit as st
from typing import List, Dict, Any
import logging

logger = logging.getLogger(__name__)

def render_main_sidebar(db_session, user_id: int, current_section: str = "scheduling") -> None:
    """
    FIXED Enhanced main sidebar with proper page switching
    """
    with st.sidebar:
        # Application Branding
        st.markdown(
            """
            <div style='text-align: center; padding: 1rem 0;'>
                <h1 style='margin: 0; color: #1f77b4;'>ðŸ—ï¸</h1>
                <h3 style='margin: 0; color: #333;'>Construction Planner</h3>
                <p style='margin: 0; font-size: 0.8rem; color: #666;'>Version Professionnelle</p>
            </div>
            """, 
            unsafe_allow_html=True
        )
        st.markdown("---")

        # User Profile Section
        render_user_profile(db_session, user_id)

        # Project Context Selector
        render_project_selector(db_session, user_id)

        # Section Navigation
        st.markdown("## ðŸ§­ Navigation Principale")
        tab1, tab2 = st.tabs(["ðŸ“… Planification", "ðŸ“Š Suivi"])

        with tab1:
            render_scheduling_navigation(db_session, user_id, current_section == "scheduling")
        with tab2:
            render_monitoring_navigation(db_session, user_id, current_section == "monitoring")

        # Quick Stats & Actions
        st.markdown("---")
        render_quick_stats(db_session, user_id)

        # System Status & Footer
        render_system_footer()

def render_user_profile(db_session, user_id: int) -> None:
    """FIXED Enhanced user profile"""
    try:
        # âœ… Use CORRECT session manager
        if 'auth_session_manager' not in st.session_state:
            st.error("âŒ Authentication not initialized")
            return
            
        session_manager = st.session_state.auth_session_manager
        
        with st.container():
            col1, col2 = st.columns([1, 3])
            with col1:
                st.markdown("<div style='text-align: center; font-size: 2rem;'>ðŸ‘¤</div>", unsafe_allow_html=True)
            with col2:
                st.markdown(f"**{session_manager.get_username()}**")
                st.caption(f"@{session_manager.get_username()} â€¢ {session_manager.get_user_role().upper()}")
                st.markdown(f"`User ID: {user_id}`")

    except Exception as e:
        logger.error(f"Error rendering user profile: {e}")
        st.error("âŒ Erreur profil utilisateur")

def render_project_selector(db_session, user_id: int, page_title: str = "Navigation") -> None:
    """
    FIXED Professional Project Selector
    """
    try:
        from backend.services.project_service import ProjectService
        project_service = ProjectService(db_session)

        # Retrieve user projects
        projects = project_service.get_user_projects(user_id) or []

        if projects:
            # Prepare display names safely
            project_names = []
            for project in projects:
                name = getattr(project, 'name', project.get('name', 'Unnamed Project'))
                project_names.append(f"ðŸ—ï¸ {name}")

            selected_index = 0
            current_project_name = st.session_state.get('current_project_name')

            # Find index of currently selected project
            if current_project_name:
                for i, name in enumerate(project_names):
                    if current_project_name in name:
                        selected_index = i
                        break

            # Render the selectbox
            selected_project = st.selectbox(
                "ðŸ“‹ Projet Actif",
                options=project_names,
                index=selected_index,
                help="SÃ©lectionnez le projet sur lequel travailler"
            )

            if selected_project:
                project_name_clean = selected_project.replace("ðŸ—ï¸ ", "")
                st.session_state.current_project_name = project_name_clean

                # Find project ID safely
                for project in projects:
                    pid = getattr(project, 'id', project.get('id', None))
                    pname = getattr(project, 'name', project.get('name', None))
                    if pname == project_name_clean:
                        st.session_state.current_project_id = pid
                        break

        else:
            st.info("ðŸ“ Aucun projet crÃ©Ã©")
            if st.button("âž• CrÃ©er un Nouveau Projet", use_container_width=True):
                st.session_state.current_page = 'project_setup'
                st.rerun()

    except Exception as e:
        logger.error(f"Error in render_project_selector: {e}", exc_info=True)
        st.error(f"âŒ Erreur chargement projets: {e}")

def render_scheduling_navigation(db_session, user_id: int, is_active: bool = True) -> None:
    """FIXED Render scheduling navigation with proper page switching"""
    st.markdown("### ðŸ“… Planification")

    scheduling_pages: List[Dict[str, Any]] = [
        {"name": "ðŸ—ï¸ Configuration Projet", "page": "project_setup", "description": "Configuration initiale du projet et des zones", "icon": "ðŸ—ï¸"},
        {"name": "âš™ï¸ SÃ©quences de Travail", "page": "zone_sequence", "description": "DÃ©finition des sÃ©quences et dÃ©pendances", "icon": "âš™ï¸"},
        {"name": "ðŸ“Š Gestion Templates", "page": "templates_manager", "description": "Import et gestion des modÃ¨les Excel", "icon": "ðŸ“Š"},
        {"name": "ðŸ“… GÃ©nÃ©ration Planning", "page": "generate_schedule", "description": "GÃ©nÃ©ration et optimisation du planning", "icon": "ðŸ“…"},
    ]

    for page in scheduling_pages:
        with st.container():
            col1, col2 = st.columns([1, 4])
            with col1:
                st.markdown(f"<h3>{page['icon']}</h3>", unsafe_allow_html=True)
            with col2:
                button_key = f"nav_sched_{user_id}_{page['page']}"
                
                if st.button(
                    page["name"],
                    key=button_key,
                    use_container_width=True,
                    type="primary" if st.session_state.get('current_page') == page['page'] else "secondary"
                ):
                    # âœ… FIXED: Set page in session state and trigger rerun
                    st.session_state.current_page = page['page']
                    st.session_state.navigation_section = "scheduling"
                    st.rerun()
                    
                st.caption(page["description"])

def render_monitoring_navigation(db_session, user_id: int, is_active: bool = True) -> None:
    """FIXED Enhanced monitoring navigation with proper page switching"""
    st.markdown("### ðŸ“Š Suivi & Analyse")

    monitoring_pages: List[Dict[str, Any]] = [
        {"name": "ðŸ“ˆ Suivi Progression", "page": "progress_monitoring", "description": "Suivi temps rÃ©el de l'avancement", "icon": "ðŸ“ˆ"},
        {"name": "ðŸ“‹ Tableau de Bord", "page": "performance_dashboard", "description": "Indicateurs de performance et KPI", "icon": "ðŸ“‹"},
        {"name": "ðŸ“„ Rapports & Analytics", "page": "reports_analytics", "description": "Rapports dÃ©taillÃ©s et analyses", "icon": "ðŸ“„"},
    ]

    for page in monitoring_pages:
        with st.container():
            col1, col2 = st.columns([1, 4])
            with col1:
                st.markdown(f"<h3>{page['icon']}</h3>", unsafe_allow_html=True)
            with col2:
                button_key = f"nav_mon_{user_id}_{page['page']}"
                
                if st.button(
                    page["name"],
                    key=button_key,
                    use_container_width=True,
                    type="primary" if st.session_state.get('current_page') == page['page'] else "secondary"
                ):
                    # âœ… FIXED: Set page in session state and trigger rerun
                    st.session_state.current_page = page['page']
                    st.session_state.navigation_section = "monitoring"
                    st.rerun()
                    
                st.caption(page["description"])

def render_quick_stats(db_session, user_id: int) -> None:
    """FIXED Enhanced quick stats"""
    try:
        from backend.services.project_service import ProjectService
        project_service = ProjectService(db_session)
        projects = project_service.get_user_projects(user_id)

        # Project Statistics
        active_projects = len([p for p in projects if getattr(p, 'status', '') == 'active'])
        total_projects = len(projects)

        col1, col2 = st.columns(2)
        with col1:
            st.metric("Projets Actifs", active_projects)
        with col2:
            st.metric("Total Projets", total_projects)

    except Exception as e:
        logger.error(f"Error rendering quick stats: {e}")
        st.error(f"âŒ Erreur statistiques: {e}")

def render_system_footer() -> None:
    """FIXED Enhanced system footer"""
    st.markdown("---")
    if st.button("ðŸšª DÃ©connexion", use_container_width=True, type="secondary"):
        # âœ… Use CORRECT session manager
        if 'auth_session_manager' in st.session_state:
            st.session_state.auth_session_manager.logout()
            st.rerun()

    st.markdown(
        """
        <div style='text-align: center; padding: 1rem 0; color: #666; font-size: 0.8rem;'>
            <p>ðŸ—ï¸ <strong>Construction Planner Pro</strong></p>
            <p>Version 2.1.0 â€¢ Â© 2024</p>
        </div>
        """,
        unsafe_allow_html=True
    )

# ====== End of frontend/components/navigation/sidebar.py ======



# ====== Begin of frontend/components/navigation/header.py ======


"""
Enhanced header components - FIXED VERSION
Fully compatible with unified session management
"""
import streamlit as st
from typing import List, Optional
from datetime import datetime

# --------------------------
# PAGE HEADER
# --------------------------
def render_page_header(
    title: str,
    description: str = "",
    icon: str = "ðŸ—ï¸",
    show_breadcrumbs: bool = True,
    breadcrumbs: Optional[List[str]] = None
) -> None:
    """
    Render professional page header compatible with new architecture
    """
    col1, col2, col3 = st.columns([2, 3, 1])
    
    with col1:
        st.markdown(f"<h1 style='margin:0'>{icon} {title}</h1>", unsafe_allow_html=True)
        if description:
            st.markdown(f"<p style='margin:0;color:#666'>{description}</p>", unsafe_allow_html=True)
    
    with col2:
        if show_breadcrumbs:
            render_breadcrumbs(breadcrumbs or [title])
    
    with col3:
        render_header_actions()
    
    st.markdown("---")

# --------------------------
# BREADCRUMBS
# --------------------------
def render_breadcrumbs(items: List[str]) -> None:
    """Render breadcrumb navigation"""
    if not items:
        return
    breadcrumb_html = "<nav style='padding:0.5rem 0; font-size:0.9rem; color:#666;'>"
    for i, item in enumerate(items):
        if i == len(items) - 1:
            breadcrumb_html += f"<strong>{item}</strong>"
        else:
            breadcrumb_html += f"{item} &rsaquo; "
    breadcrumb_html += "</nav>"
    st.markdown(breadcrumb_html, unsafe_allow_html=True)

# --------------------------
# HEADER ACTIONS
# --------------------------
def render_header_actions() -> None:
    """Render quick actions in header"""
    col1, col2, col3 = st.columns(3)
    with col1:
        current_time = datetime.now().strftime("%d/%m/%Y %H:%M")
        st.caption(f"ðŸ•’ {current_time}")
    with col2:
        st.button("ðŸ””", help="Notifications", key="notif_btn")
    with col3:
        if st.button("â“", help="Aide", key="help_btn"):
            st.info("ðŸ”§ Centre d'aide - FonctionnalitÃ© Ã  venir")

# --------------------------
# PROJECT SELECTOR IN HEADER
# --------------------------
def render_project_selector_header(db_session, user_id: int) -> None:
    """Project selector for header, integrated with session state"""
    from backend.services.project_service import ProjectService

    try:
        project_service = ProjectService(db_session)
        projects = project_service.get_user_projects(user_id)

        if projects:
            current_project = st.session_state.get("current_project")
            project_options = [f"ðŸ—ï¸ {p.name}" for p in projects]
            selected_project = st.selectbox(
                "SÃ©lectionner un projet:",
                options=project_options,
                index=0 if not current_project else next(
                    (i for i, p in enumerate(projects) if p.name == current_project), 0
                ),
                label_visibility="collapsed"
            )
            if selected_project:
                project_name = selected_project.replace("ðŸ—ï¸ ", "")
                if project_name != current_project:
                    st.session_state.current_project = project_name
                    st.success(f"âœ… Projet **{project_name}** activÃ©")
                    st.rerun()
        else:
            st.warning("ðŸ“ Aucun projet disponible")
    except Exception:
        st.error("âŒ Erreur sÃ©lection projet")

# --------------------------
# QUICK ACTION BUTTONS
# --------------------------
def render_quick_action_buttons(db_session, user_id: int) -> None:
    """Render quick action buttons in header"""
    st.markdown("### ðŸš€ Actions Rapides")
    col1, col2, col3, col4 = st.columns(4)
    with col1:
        if st.button("ðŸ“¥ Nouveau Projet", use_container_width=True):
            st.session_state.current_page = 'project_setup'
            st.rerun()
    with col2:
        if st.button("ðŸ“Š GÃ©nÃ©rer Planning", use_container_width=True):
            st.session_state.current_page = 'generate_schedule'
            st.rerun()
    with col3:
        if st.button("ðŸ“ˆ Suivi Progression", use_container_width=True):
            st.session_state.current_page = 'progress_monitoring'
            st.rerun()
    with col4:
        if st.button("ðŸ“„ Exporter Rapport", use_container_width=True):
            st.info("ðŸ“‹ FonctionnalitÃ© d'export Ã  venir")

# --------------------------
# SECTION INDICATOR
# --------------------------
def render_section_indicator(current_section: str) -> None:
    """Render visual indicator for current section"""
    if current_section == "scheduling":
        st.markdown(
            "<div style='background:linear-gradient(90deg,#e3f2fd,#bbdefb); padding:0.5rem; border-radius:0.5rem; text-align:center;'>"
            "<strong>ðŸ“… MODE PLANIFICATION</strong></div>",
            unsafe_allow_html=True
        )
    else:
        st.markdown(
            "<div style='background:linear-gradient(90deg,#f3e5f5,#e1bee7); padding:0.5rem; border-radius:0.5rem; text-align:center;'>"
            "<strong>ðŸ“Š MODE SUIVI & ANALYSE</strong></div>",
            unsafe_allow_html=True
        )

# --------------------------
# PROGRESS INDICATOR
# --------------------------
def render_progress_indicator(progress: float, label: str = "Progression") -> None:
    """Render progress indicator in header"""
    st.markdown(
        f"<div style='margin:0.5rem 0;'>"
        f"<div style='display:flex; justify-content:space-between; margin-bottom:0.2rem;'>"
        f"<span><strong>{label}</strong></span><span><strong>{progress:.1f}%</strong></span></div>"
        f"<div style='background:#f0f0f0; border-radius:10px; height:8px;'>"
        f"<div style='background:linear-gradient(90deg,#4CAF50,#8BC34A); width:{progress}%; height:100%; border-radius:10px;'></div>"
        f"</div></div>",
        unsafe_allow_html=True
    )

# ====== End of frontend/components/navigation/header.py ======



# ====== Begin of pages/project_setup.py ======

import streamlit as st
import pandas as pd
import traceback
from datetime import datetime
import json 
import logging

# Import authentication system
from frontend.components.auth.auth_guard import require_auth

# Import professional components
from frontend.components.forms.project_forms import (
    ZoneConfigurationForm,
    ProjectBasicInfoForm
)

from frontend.components.navigation.sidebar import render_project_selector

logger = logging.getLogger(__name__)


@require_auth("write")
def show(db_session, user_id):
    """
    PROFESSIONAL Project Setup with PROPER session state initialization
    """
    
    # ==================== CRITICAL: INITIALIZE SESSION STATE FIRST ====================
    _initialize_session_state(user_id)
    
    # ==================== RERUN DIAGNOSTICS ====================
    st.sidebar.markdown("---")
    st.sidebar.subheader("ðŸ”§ RERUN DIAGNOSTICS")
    
    # Diagnostic 1: Rerun Counter
    if 'diagnostic_rerun_count' not in st.session_state:
        st.session_state.diagnostic_rerun_count = 0
    st.session_state.diagnostic_rerun_count += 1
    
    st.sidebar.metric("ðŸ”„ Rerun Count", st.session_state.diagnostic_rerun_count)
    st.sidebar.write(f"**project_config exists:** {'âœ…' if 'project_config' in st.session_state else 'âŒ'}")
    st.sidebar.write(f"**project_zones exists:** {'âœ…' if 'project_zones' in st.session_state else 'âŒ'}")

    logger.info(f"ðŸ§± Project Setup page loaded for user {user_id} - Rerun #{st.session_state.diagnostic_rerun_count}")

    try:
        # Get session manager from session state
        session_manager = st.session_state.auth_session_manager
        user_info = _get_user_info(session_manager)
        
        # Initialize widget manager for this page
        from backend.utils.widget_manager import widget_manager
        page_context = "project_setup"
        
        # Professional header
        st.markdown('<div class="main-header">ðŸ—ï¸ Project Setup & Configuration</div>', unsafe_allow_html=True)
        st.caption(f"User: {user_info['username']} | Role: {user_info['role']} | Rerun: #{st.session_state.diagnostic_rerun_count}")
        
        # Render project selector
        render_project_selector(db_session, user_id)
        
        # ==================== DEBUG: SHOW CURRENT STATE ====================
        with st.expander("ðŸ” DEBUG: Current Session State", expanded=False):
            col1, col2 = st.columns(2)
            with col1:
                st.write("**project_config:**")
                if 'project_config' in st.session_state:
                    st.json(st.session_state.project_config)
                else:
                    st.error("âŒ project_config NOT FOUND")
            
            with col2:
                st.write("**project_zones:**")
                if 'project_zones' in st.session_state:
                    st.json(st.session_state.project_zones)
                else:
                    st.error("âŒ project_zones NOT FOUND")
        
        # ==================== SIMPLIFIED FORM RENDERING ====================
        st.markdown("---")
        st.subheader("ðŸ“‹ Project Configuration")
        
        # Create form instances fresh each render
        try:
            basic_form = ProjectBasicInfoForm(
                user_id=user_id,
                page_context=page_context
            )
            
            zone_form = ZoneConfigurationForm(
                user_id=user_id, 
                page_context=page_context
            )
            
            # Professional tab interface
            tab1, tab2, tab3 = st.tabs([
                "ðŸ“‹ Basic Information", 
                "ðŸ¢ Zones & Floors", 
                "âš™ï¸ Advanced Configuration"
            ])
            
            with tab1:
                _render_basic_info_tab_simplified(basic_form, user_id, page_context)
            
            with tab2:
                _render_zones_config_tab_simplified(zone_form, user_id, page_context)
            
            with tab3:
                _render_advanced_config_tab(user_id, page_context)
            
            _render_save_section(db_session, user_id, page_context)
            
        except Exception as form_error:
            st.error(f"âŒ Form initialization error: {form_error}")
            logger.error(f"Form initialization failed: {form_error}")
            traceback.print_exc()
        
    except Exception as e:
        logger.error(f"âŒ FATAL Error in project setup: {e}")
        st.error(f"âŒ Fatal error loading project setup: {e}")
        st.code(traceback.format_exc())
        
def _initialize_session_state(user_id):
    """
    CRITICAL: Initialize ALL session state variables at the start
    This must be called BEFORE any other session state access
    """
    logger.debug(f"ðŸ”„ Initializing session state for user {user_id}")
    
    # Initialize project configuration - THIS WAS MISSING!
    if 'project_config' not in st.session_state:
        st.session_state.project_config = {
            'basic_info': {
                'project_name': 'My Construction Project',
                'project_manager': '',
                'start_date': datetime.now().date(),
                'description': '',
                'project_type': 'Commercial',
                'client_name': '',
                'location': ''
            },
            'zones': {},
            'advanced_settings': {
                'work_hours_per_day': 8,
                'acceleration_factor': 1.0,
                'risk_allowance': 0.1
            }
        }
        logger.debug("âœ… project_config initialized in session state")
    
    # Initialize zones state
    if 'project_zones' not in st.session_state:
        st.session_state.project_zones = {}
        logger.debug("âœ… project_zones initialized in session state")
    
    # Initialize widget manager
    if 'widget_manager' not in st.session_state:
        from backend.utils.widget_manager import widget_manager
        st.session_state.widget_manager = widget_manager
        logger.debug("âœ… widget_manager initialized in session state")


def _get_user_info(session_manager):
    """Get user information from SessionManager"""
    return {
        'id': session_manager.get_user_id(),
        'username': session_manager.get_username(),
        'role': session_manager.get_user_role(),
        'full_name': session_manager.get_username()
    }


def _render_basic_info_tab_simplified(form, user_id, page_context):
    """Simplified basic info tab"""
    st.subheader("ðŸ“‹ Project Basic Information")
    
    try:
        result = form.render()
        
        if result:
            # Update project_config with form results
            st.session_state.project_config['basic_info'].update(result)
            st.success("âœ… Basic project information updated!")
            logger.info(f"âœ… Basic info updated: {result.get('project_name')}")
        
    except Exception as e:
        st.error(f"âŒ Basic form render error: {e}")
        logger.error(f"âŒ Basic form render failed: {e}")


def _render_zones_config_tab_simplified(form, user_id, page_context):
    """Simplified zones config tab"""
    st.subheader("ðŸ¢ Building Zones Configuration")

    try:
        form.render()
        logger.debug("âœ… Zone form rendered successfully")
        
    except Exception as e:
        st.error(f"âŒ Zone form render error: {e}")
        logger.error(f"âŒ Zone form render failed: {e}")


def _render_advanced_config_tab(user_id, page_context):
    """Advanced configuration tab with SAFE session state access"""
    logger.debug("ðŸ”„ Rendering advanced config tab")
    
    st.subheader("âš™ï¸ Advanced Project Configuration")
    
    # âœ… SAFE: Check if project_config exists before accessing
    if 'project_config' not in st.session_state:
        st.error("âŒ Project configuration not initialized")
        return
    
    widget_manager = st.session_state.widget_manager
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.subheader("Work Configuration")
        
        work_hours = st.number_input(
            "Work Hours Per Day",
            min_value=1,
            max_value=24,
            value=st.session_state.project_config['advanced_settings']['work_hours_per_day'],
            help="Standard working hours per day",
            key=widget_manager.generate_key("work_hours_input", page_context, user_id)
        )
        
        acceleration = st.slider(
            "Acceleration Factor",
            min_value=0.5,
            max_value=3.0,
            value=st.session_state.project_config['advanced_settings']['acceleration_factor'],
            step=0.1,
            help="Factor to accelerate schedule (may require more resources)",
            key=widget_manager.generate_key("acceleration_slider", page_context, user_id)
        )
    
    with col2:
        st.subheader("Risk & Contingency")
        risk_allowance = st.slider(
            "Risk Allowance (%)",
            min_value=0.0,
            max_value=50.0,
            value=st.session_state.project_config['advanced_settings']['risk_allowance'] * 100,
            step=5.0,
            help="Additional time allowance for risks and uncertainties",
            key=widget_manager.generate_key("risk_allowance_slider", page_context, user_id)
        )
    
    # Update advanced settings
    st.session_state.project_config['advanced_settings'].update({
        'work_hours_per_day': work_hours,
        'acceleration_factor': acceleration,
        'risk_allowance': risk_allowance / 100.0
    })
    
    logger.debug("âœ… Advanced config updated")


def _render_save_section(db_session, user_id, page_context):
    """Save section with professional controls"""
    logger.debug("ðŸ”„ Rendering save section")
    
    st.markdown("---")
    st.subheader("ðŸ’¾ Save Configuration")
    
    # âœ… SAFE: Check if required session state exists
    if 'project_zones' not in st.session_state:
        st.error("âŒ Zones configuration not initialized")
        return
    
    if 'project_config' not in st.session_state:
        st.error("âŒ Project configuration not initialized")
        return
    
    widget_manager = st.session_state.widget_manager
    
    col1, col2, col3 = st.columns([2, 1, 1])
    
    with col1:
        save_button_key = widget_manager.generate_key("save_config_btn", page_context, user_id)
        
        if st.button("ðŸ’¾ Save Project Configuration", 
                    type="primary", 
                    use_container_width=True,
                    key=save_button_key):
            logger.info("ðŸ’¾ Save project configuration button clicked")
            _save_project_configuration_professional(db_session, user_id)
    
    with col2:
        export_button_key = widget_manager.generate_key("export_json_btn", page_context, user_id)
        config_json = json.dumps(st.session_state.project_config, indent=2, default=str)
        st.download_button(
            "ðŸ“¥ Export JSON",
            data=config_json,
            file_name=f"project_config_{datetime.now().strftime('%Y%m%d_%H%M')}.json",
            mime="application/json",
            use_container_width=True,
            key=export_button_key
        )
    
    with col3:
        upload_key = widget_manager.generate_key("config_upload", page_context, user_id)
        uploaded_config = st.file_uploader(
            "Import Config",
            type=['json'],
            key=upload_key
        )
        
        if uploaded_config:
            try:
                imported_config = json.load(uploaded_config)
                st.session_state.project_config = imported_config
                st.success("âœ… Configuration imported successfully!")
                st.rerun()
            except Exception as e:
                st.error(f"âŒ Error importing configuration: {e}")


def _save_project_configuration_professional(db_session, user_id):
    """Save project configuration to database with professional error handling"""
    logger.info(f"ðŸ’¾ Saving project configuration for user {user_id}")
    
    # Enhanced validation with safe session state access
    if 'project_zones' not in st.session_state or not st.session_state.project_zones:
        st.error("âŒ Please configure at least one zone")
        logger.warning("âŒ Save attempted without zones configured")
        return
    
    if 'project_config' not in st.session_state:
        st.error("âŒ Project configuration not initialized")
        return
    
    project_name = st.session_state.project_config['basic_info'].get('project_name')
    project_manager = st.session_state.project_config['basic_info'].get('project_manager')
    
    if not project_name or not project_manager:
        st.error("âŒ Please complete basic project information")
        logger.warning("âŒ Save attempted with incomplete basic info")
        return
    
    try:
        from backend.services.project_service import ProjectService
        project_service = ProjectService(db_session)
        
        # Get zones data in correct format
        zones_data = st.session_state.project_zones.copy()
        
        # Prepare complete project data
        project_data = {
            'name': project_name,
            'description': st.session_state.project_config['basic_info'].get('description', ''),
            'start_date': st.session_state.project_config['basic_info'].get('start_date'),
            'project_type': st.session_state.project_config['basic_info'].get('project_type', 'Commercial'),
            'owner': st.session_state.project_config['basic_info'].get('owner', ''),
            'location': st.session_state.project_config['basic_info'].get('location', ''),
            'zones': zones_data,
            'advanced_settings': st.session_state.project_config.get('advanced_settings', {})
        }
        
        logger.info(f"ðŸ“Š Project data prepared for saving: {project_data['name']} with {len(zones_data)} zones")
        
        # Validate configuration
        validation_result = project_service.validate_project_configuration(project_data)
        
        if not validation_result['is_valid']:
            for error in validation_result['errors']:
                st.error(f"âŒ {error}")
            logger.warning(f"âŒ Project validation failed: {validation_result['errors']}")
            return
        
        # Show warnings
        for warning in validation_result['warnings']:
            st.warning(f"âš ï¸ {warning}")
        
        # Save project
        with st.spinner("ðŸ’¾ Saving project configuration..."):
            if st.session_state.get('current_project_id'):
                # Update existing project
                success = project_service.update_project(user_id, st.session_state.current_project_id, project_data)
                if success:
                    st.success("âœ… Project updated successfully!")
                    logger.info(f"âœ… Project updated: {project_data['name']} (ID: {st.session_state.current_project_id})")
                    st.rerun()
                else:
                    st.error("âŒ Failed to update project")
                    logger.error(f"âŒ Project update failed: {project_data['name']}")
            else:
                # Create new project
                project_result = project_service.create_project(user_id, project_data)
                if project_result:
                    st.session_state.current_project_id = project_result['id']
                    st.session_state.current_project_name = project_result['name']
                    st.success("âœ… Project created successfully!")
                    logger.info(f"âœ… Project created: {project_result['name']} (ID: {project_result['id']})")
                    st.rerun()
                else:
                    st.error("âŒ Failed to create project")
                    logger.error(f"âŒ Project creation failed: {project_data['name']}")
                    
    except Exception as e:
        logger.error(f"âŒ Error saving project configuration: {e}")
        st.error(f"âŒ Error saving project configuration: {str(e)}")

# ====== End of pages/project_setup.py ======



# ====== Begin of backend/services/project_service.py ======

"""
PROFESSIONAL Project Service - PRODUCTION READY
Enhanced with proper zones format handling and transaction awareness
"""
import logging
from typing import List, Dict, Optional, Any
from datetime import datetime
from sqlalchemy.orm import Session
from backend.utils.error_handler import error_decorator, AppError
from backend.utils.validators import Validator

logger = logging.getLogger(__name__)

class ProjectService:
    """
    Production-ready project management service
    Handles data flow between frontend, domain models, and database
    Enhanced with proper zones format: {zone_name: {max_floors: int, sequence: int, description: str}}
    """
    
    def __init__(self, db_session: Session):
        self.db_session = db_session
        self.logger = logging.getLogger(__name__)
        self._initialize_repositories()
    
    def _initialize_repositories(self):
        """Initialize repositories with proper error handling"""
        try:
            from backend.db.repositories.project_repo import ProjectRepository
            self.project_repo = ProjectRepository(self.db_session)
            self.logger.info("âœ… ProjectRepository initialized successfully")
        except Exception as e:
            self.logger.error(f"âŒ Failed to initialize ProjectRepository: {e}")
            raise
    

    @error_decorator(return_none=False)
    def create_project(self, user_id: int, project_data: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """
        Create project with proper zones format handling and enforcing single project per name
        """
        #try:
        
        is_valid, errors = Validator.validate_project_data(project_data)
        if not is_valid:
            raise AppError(
                message="Project validation failed",
                code="VALIDATION_ERROR",
                details={'errors': errors}
            )
        self.logger.info(f"Creating project for user {user_id}: {project_data.get('name')}")

        # Validate required data
        if not project_data.get('name'):
            raise ValueError("Project name is required")
        
        # Validate zones format
        zones = project_data.get('zones', {})
        self._validate_zones_format(zones)

        # Prepare database payload
        db_payload = {
            'name': project_data['name'],
            'description': project_data.get('description', ''),
            'start_date': project_data.get('start_date'),
            'project_type': project_data.get('project_type', 'Commercial'),
            'owner': project_data.get('owner', ''),
            'location': project_data.get('location', ''),
            'zones': zones,
            'status': 'active',
            'created_at': datetime.now(),
            'updated_at': datetime.now() 
        }

        # Advanced settings
        advanced_settings = project_data.get('advanced_settings', {})
        if advanced_settings:
            db_payload['constraints'] = advanced_settings

        # âœ… Use get_or_create_project to avoid duplicates
        project_db = self.project_repo.get_or_create_project(user_id, db_payload)

        frontend_data = self._db_to_frontend_format(project_db)
        self.logger.info(f"âœ… Project ready for frontend: {project_db.name} (ID: {project_db.id})")
        return frontend_data

        #except Exception as e:
           # self.logger.error(f"âŒ Error creating project: {e}")
            #raise
    
    def get_user_projects(self, user_id: int) -> List[Dict[str, Any]]:
        """
        Get all projects for user in frontend-compatible format
        
        Args:
            user_id: Authenticated user ID
            
        Returns:
            List of project data for frontend
        """
        try:
            self.logger.info(f"Retrieving projects for user {user_id}")
            
            projects_db = self.project_repo.get_user_projects(user_id)
            frontend_projects = [self._db_to_frontend_format(project) for project in projects_db]
            
            self.logger.info(f"âœ… Retrieved {len(frontend_projects)} projects for user {user_id}")
            return frontend_projects
            
        except Exception as e:
            self.logger.error(f"âŒ Error retrieving user projects: {e}")
            return []
    
    @error_decorator(return_none=True)
    def get_project(self, user_id: int, project_id: int) -> Optional[Dict[str, Any]]:
        """Get project with authorization check"""
        project_db = self.project_repo.get_project(user_id, project_id)
        
        if not project_db:
            raise AppError(
                message="Project not found",
                code="NOT_FOUND",
                details={'project_id': project_id, 'user_id': user_id}
            )
        
        # Verify project belongs to user
        if project_db.user_id != user_id:
            raise AppError(
                message="Access denied to project",
                code="PERMISSION_DENIED",
                details={'project_id': project_id, 'user_id': user_id}
            )
        
        return self._db_to_frontend_format(project_db)
    
    def update_project(self, user_id: int, project_id: int, update_data: Dict[str, Any]) -> bool:
        """
        Update project with authorization check and zones format validation
        
        Args:
            user_id: Authenticated user ID (for authorization)
            project_id: Project ID to update
            update_data: Data to update
            
        Returns:
            True if successful, False otherwise
        """
        try:
            self.logger.info(f"Updating project {project_id} for user {user_id}")
            
            # Verify user owns the project
            project_db = self.project_repo.get_project(user_id,project_id)
            if not project_db or project_db.user_id != user_id:
                self.logger.warning(f"âŒ User {user_id} unauthorized to update project {project_id}")
                return False
            
            # Validate zones format if provided
            zones = update_data.get('zones') 
            if zones is not None:
                self._validate_zones_format(zones)
            
            # Prepare update payload
            update_payload = {
                'name': update_data.get('name', project_db.name),
                'description': update_data.get('description', project_db.description),
                'project_type':  update_data.get('project_type', project_db.project_type),
                'owner': update_data.get('owner', project_db.owner),
                'start_date' : update_data.get('start_date', project_db.start_date),
                'zones': update_data.get('zones', project_db.zones),
                'updated_at': datetime.now()
            }
            
            # Handle advanced settings
            advanced_settings = update_data.get('advanced_settings')
            if advanced_settings:
                update_payload['constraints'] = advanced_settings
            
            success = self.project_repo.update_project(user_id, project_id, update_payload)
            
            if success:
                self.logger.info(f"âœ… Project {project_id} updated successfully")
            else:
                self.logger.error(f"âŒ Failed to update project {project_id}")
            
            return success
            
        except Exception as e:
            self.logger.error(f"âŒ Error updating project {project_id}: {e}")
            return False
    
    def delete_project(self, user_id: int, project_id: int) -> bool:
        """
        Soft delete project (archive it)
        
        Args:
            user_id: Authenticated user ID
            project_id: Project ID to archive
            
        Returns:
            True if successful, False otherwise
        """
        try:
            # Verify authorization
            project_db = self.project_repo.get_project(user_id,project_id)
            if not project_db or project_db.user_id != user_id:
                return False
            
            update_data = {
                'status': 'archived',
                'updated_at': datetime.now()
            }
            
            return self.project_repo.update_project(project_id, update_data)
            
        except Exception as e:
            self.logger.error(f"âŒ Error deleting project {project_id}: {e}")
            return False
    
    def get_project_progress_summary(self,user_id, project_id: int) -> Dict[str, Any]:
        """
        Get comprehensive project progress summary
        
        Args:
            project_id: Project ID
            
        Returns:
            Progress summary data
        """
        try:
            # Use repository method if available
            if hasattr(self.project_repo, 'get_project_progress_summary'):
                summary = self.project_repo.get_project_progress_summary(project_id)
                if summary:
                    return summary
            
            # Fallback implementation
            project_db = self.project_repo.get_project(user_id,project_id)
            if not project_db:
                return {}
            
            return {
                'project_id': project_id,
                'project_name': project_db.name,
                'project_status': project_db.status,
                'start_date': project_db.start_date,
                'zone_count': len(project_db.zones) if project_db.zones else 0,
                'total_floors': self._calculate_total_floors(project_db.zones),
                'overall_completion': 0,
                'schedule_count': 0,
                'last_updated': project_db.updated_at.isoformat() if project_db.updated_at else None
            }
            
        except Exception as e:
            self.logger.error(f"âŒ Error getting project progress summary: {e}")
            return {}
    
    def _db_to_frontend_format(self, project_db) -> Dict[str, Any]:
        """
        Convert database model to frontend-compatible format
        Preserves zones format: {zone_name: {max_floors: int, sequence: int, description: str}}
        
        Args:
            project_db: SQLAlchemy project model
            
        Returns:
            Frontend-compatible project data
        """
        try:
            # Extract basic info
            frontend_data = {
                'id': project_db.id,
                'name': project_db.name,
                'description': project_db.description or '',
                'start_date': project_db.start_date.isoformat() if project_db.start_date else None,
                'project_type': getattr(project_db, 'project_type', 'Commercial'),
                'owner': getattr(project_db, 'owner', ''),
                'location': getattr(project_db, 'location', ''),
                'status': project_db.status,
                'created_at': project_db.created_at.isoformat() if project_db.created_at else None,
                'updated_at': project_db.updated_at.isoformat() if project_db.updated_at else None
            }
            
            # Handle zones - ensure correct format
            zones = getattr(project_db, 'zones', {})
            if zones:
                # Ensure zones are in correct format
                validated_zones = {}
                for zone_name, zone_config in zones.items():
                    if isinstance(zone_config, dict):
                        # Already in correct format
                        validated_zones[zone_name] = {
                            'max_floors': zone_config.get('max_floors', 0),
                            'sequence': zone_config.get('sequence', 1),
                            'description': zone_config.get('description', '')
                        }
                    else:
                        # Convert simple format to complex format
                        validated_zones[zone_name] = {
                            'max_floors': zone_config,
                            'sequence': 1,
                            'description': ''
                        }
                frontend_data['zones'] = validated_zones
            else:
                frontend_data['zones'] = {}
            
            # Extract advanced settings from constraints
            constraints = getattr(project_db, 'constraints', {})
            if constraints:
                frontend_data['advanced_settings'] = constraints
            else:
                frontend_data['advanced_settings'] = {
                    'work_hours_per_day': 8,
                    'acceleration_factor': 1.0,
                    'risk_allowance': 0.1
                }
            
            return frontend_data
            
        except Exception as e:
            self.logger.error(f"âŒ Error converting project to frontend format: {e}")
            # Return minimal safe data
            return {
                'id': getattr(project_db, 'id', None),
                'name': getattr(project_db, 'name', 'Unknown Project'),
                'zones': {},
                'advanced_settings': {},
                'status': 'error'
            }
    
    def _calculate_total_floors(self, zones: Dict) -> int:
        """Calculate total floors from zones configuration"""
        try:
            if not zones:
                return 0
            
            total = 0
            for zone_name, zone_config in zones.items():
                if isinstance(zone_config, dict):
                    total += zone_config.get('max_floors', 0)
                elif isinstance(zone_config, (int, float)):
                    total += int(zone_config)
            
            return total
        except Exception as e:
            self.logger.error(f"Error calculating total floors: {e}")
            return 0
    
    def _validate_zones_format(self, zones: Dict[str, Any]):
        """
        Validate zones format is correct: {zone_name: {max_floors: int, sequence: int, description: str}}
        
        Args:
            zones: Zones data to validate
            
        Raises:
            ValueError: If zones format is invalid
        """
        if not isinstance(zones, dict):
            raise ValueError("Zones must be a dictionary")
        
        for zone_name, zone_config in zones.items():
            if not isinstance(zone_name, str) or not zone_name.strip():
                raise ValueError(f"Invalid zone name: {zone_name}")
            
            if not isinstance(zone_config, dict):
                raise ValueError(f"Zone configuration for '{zone_name}' must be a dictionary")
            
            # Check required fields
            if 'max_floors' not in zone_config:
                raise ValueError(f"Zone '{zone_name}' missing 'max_floors' field")
            
            max_floors = zone_config['max_floors']
            if not isinstance(max_floors, (int, float)) or max_floors < 0:
                raise ValueError(f"Zone '{zone_name}' has invalid max_floors: {max_floors}")
    
    def validate_project_configuration(self, project_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Professional validation of project configuration
        
        Args:
            project_data: Project data to validate
            
        Returns:
            Validation results
        """
        errors = []
        warnings = []
        
        # Required fields validation
        if not project_data.get('name') or not project_data['name'].strip():
            errors.append("Project name is required")
        
        if not project_data.get('start_date'):
            errors.append("Project start date is required")
        
        # Zones validation
        zones = project_data.get('zones', {})
        if not zones:
            warnings.append("No zones configured - project scheduling will be limited")
        else:
            try:
                self._validate_zones_format(zones)
                
                # Additional business logic validation
                for zone_name, zone_config in zones.items():
                    max_floors = zone_config.get('max_floors', 0)
                    if not isinstance(max_floors, int) or max_floors < 1:
                        errors.append(f"Zone '{zone_name}': max_floors must be positive integer")
                    
                    sequence = zone_config.get('sequence', 1)
                    if not isinstance(sequence, int) or sequence < 1:
                        errors.append(f"Zone '{zone_name}': sequence must be positive integer")
                        
            except ValueError as e:
                errors.append(str(e))
        
        # Advanced settings validation
        advanced_settings = project_data.get('advanced_settings', {})
        work_hours = advanced_settings.get('work_hours_per_day', 8)
        if not isinstance(work_hours, (int, float)) or not (1 <= work_hours <= 24):
            errors.append("Work hours per day must be between 1 and 24")
        
        return {
            'is_valid': len(errors) == 0,
            'errors': errors,
            'warnings': warnings,
            'summary': {
                'has_basic_info': bool(project_data.get('name') and project_data.get('start_date')),
                'zone_count': len(zones),
                'total_floors': self._calculate_total_floors(zones),
                'has_advanced_settings': bool(advanced_settings)
            }
        }

# ====== End of backend/services/project_service.py ======



# ====== Begin of backend/db/repositories/project_repo.py ======

"""
PROFESSIONAL Project Repository - PRODUCTION READY
Enhanced with proper transaction handling and zones format support
"""
import logging
from typing import List, Optional, Dict, Any
from sqlalchemy.orm import Session, joinedload
from sqlalchemy import desc

from backend.models.db_models import ProjectDB, ScheduleDB

logger = logging.getLogger(__name__)

class ProjectRepository:
    """Professional project data repository with enhanced error handling"""
    
    def __init__(self, session: Session):
        self.session = session
        self.logger = logger
    
    def get_user_projects(self, user_id: int, include_archived: bool = False) -> List[ProjectDB]:
        """
        Get all projects for a user with proper error handling
        
        Args:
            user_id: User ID to filter projects
            include_archived: Whether to include archived projects
            
        Returns:
            List of ProjectDB objects
        """
        try:
            self.logger.debug(f"Retrieving projects for user {user_id}")
            
            query = self.session.query(ProjectDB).filter(ProjectDB.user_id == user_id)
            
            if not include_archived:
                query = query.filter(ProjectDB.status != 'archived')
            
            projects = query.order_by(desc(ProjectDB.updated_at)).all()
            
            self.logger.info(f"âœ… Retrieved {len(projects)} projects for user {user_id}")
            return projects
            
        except Exception as e:
            self.logger.error(f"âŒ Failed to get user projects for user {user_id}: {e}")
            return []
    
    def get_project(self, user_id: int, project_id: int) -> Optional[ProjectDB]:
        """
        Get a specific project by ID for a given user with schedules and proper error handling.
    
        Args:
        user_id: ID of the authenticated user
        project_id: Project ID to retrieve
        
        Returns:
        ProjectDB object or None if not found or not authorized
        """
        try:
            self.logger.debug(f"Retrieving project {project_id} for user {user_id}")
        
            project = self.session.query(ProjectDB).options(
                joinedload(ProjectDB.schedules)
            ).filter(
                ProjectDB.id == project_id,
                ProjectDB.user_id == user_id
            ).first()
        
            if project:
                self.logger.debug(f"âœ… Retrieved project {project_id} for user {user_id}: {project.name}")
            else:
                self.logger.warning(f"âš ï¸ Project {project_id} not found or unauthorized for user {user_id}")
            
            return project    
        except Exception as e:
            self.logger.error(f"âŒ Failed to get project {project_id} for user {user_id}: {e}")
            return None
    
    def create_project(self, project_data: Dict[str, Any]) -> Optional[ProjectDB]:
        """
        Create new project with proper error handling and logging
        
        Args:
            project_data: Dictionary containing project attributes
            
        Returns:
            Created ProjectDB object or None if failed
        """
        try:
            self.logger.info(f"Creating project: {project_data.get('name')}")
            
            # Validate required fields
            if not project_data.get('name'):
                raise ValueError("Project name is required")
            
            # Create project instance
            project = ProjectDB(**project_data)
            
            self.session.add(project)
            #self.session.commit() 
            self.session.flush()

            self.logger.info(f"âœ… Project created successfully: {project.name} (ID: {project.id})")
            return project
            
        except Exception as e:
            self.logger.error(f"âŒ Failed to create project '{project_data.get('name')}': {e}")
            #self.session.rollback()
            return None
    
    def update_project(self,user_id, project_id: int, update_data: Dict[str, Any]) -> bool:
        """
        Update project with proper error handling and validation
        
        Args:
            project_id: Project ID to update
            update_data: Dictionary of fields to update
            
        Returns:
            True if successful, False otherwise
        """
        try:
            self.logger.info(f"Updating project {project_id}")
            
            # Verify project exists
            project = self.get_project(user_id,project_id)
            if not project:
                self.logger.error(f"âŒ Project {project_id} not found for update")
                return False
            
            # Update fields
            for key, value in update_data.items():
                if hasattr(project, key):
                    setattr(project, key, value)
                    self.logger.debug(f"Updated field {key} for project {project_id}")
                else:
                    self.logger.warning(f"âš ï¸ Field {key} does not exist on ProjectDB, skipping")
            
            #self.session.commit()  # commit in the same session
            self.session.flush()
            self.logger.info(f"âœ… Project {project_id} updated successfully")
            return True
            
        except Exception as e:
            self.logger.error(f"âŒ Failed to update project {project_id}: {e}")
            #self.session.rollback()
            return False
    def get_or_create_project(self, user_id: int, project_data: Dict[str, Any]) -> ProjectDB:
        """
        Get existing project by name for user, or create a new one.
        Enforces the rule: One project per name per user.
        """
        try:
            project = self.session.query(ProjectDB).filter_by(
                user_id=user_id,
                name=project_data.get("name"),
                status="active"
            ).first()
        
            if project:
                self.logger.info(f"âœ… Project already exists: {project.name} (ID: {project.id})")
                return project
        
            return self.create_project({**project_data, "user_id": user_id})
    
        except Exception as e:
            self.logger.error(f"âŒ Failed in get_or_create_project: {e}")
            self.session.rollback()
            return None  # âœ… Return None instead of re-raising to handle gracefully
    def delete_project(self, user_id,project_id: int) -> bool:
        """
        Hard delete project (use with caution)
        
        Args:
            project_id: Project ID to delete
            
        Returns:
            True if successful, False otherwise
        """
        try:
            self.logger.warning(f"ðŸš¨ Hard deleting project {project_id}")
            
            project = self.get_project(user_id,project_id)
            if not project:
                self.logger.error(f"âŒ Project {project_id} not found for deletion")
                return False
            
            self.session.delete(project)
            self.session.flush()
            
            self.logger.info(f"âœ… Project {project_id} deleted successfully")
            return True
            
        except Exception as e:
            self.logger.error(f"âŒ Failed to delete project {project_id}: {e}")
            self.session.rollback()
            return False
    
    def get_project_progress_summary(self,user_id, project_id: int) -> Dict[str, Any]:
        """
        Get comprehensive progress summary for a project
        
        Args:
            project_id: Project ID to get summary for
            
        Returns:
            Dictionary with progress metrics
        """
        try:
            self.logger.debug(f"Generating progress summary for project {project_id}")
            
            project = self.get_project(user_id,project_id)
            if not project:
                self.logger.warning(f"âš ï¸ Project {project_id} not found for progress summary")
                return {}
            
            # Get schedules for this project
            schedules = self.session.query(ScheduleDB).filter(
                ScheduleDB.project_id == project_id
            ).all()
            
            # Calculate progress metrics
            total_tasks = 0
            completed_tasks = 0
            in_progress_tasks = 0
            delayed_tasks = 0
            total_completion = 0
            
            for schedule in schedules:
                for task in schedule.tasks:
                    total_tasks += 1
                    total_completion += task.completion_percentage
                    
                    if task.status == 'completed':
                        completed_tasks += 1
                    elif task.status == 'in_progress':
                        in_progress_tasks += 1
                    elif task.status == 'delayed':
                        delayed_tasks += 1
            
            overall_completion = total_completion / total_tasks if total_tasks > 0 else 0
            
            summary = {
                'project_name': project.name,
                'project_status': project.status,
                'start_date': project.start_date,
                'target_end_date': project.target_end_date,
                'schedule_count': len(schedules),
                'total_tasks': total_tasks,
                'overall_completion': round(overall_completion, 2),
                'completed_tasks': completed_tasks,
                'in_progress_tasks': in_progress_tasks,
                'delayed_tasks': delayed_tasks,
                'last_schedule_date': max([s.generated_at for s in schedules]) if schedules else None,
                'zone_count': len(project.zones) if project.zones else 0,
                'total_floors': self._calculate_total_floors(project.zones)
            }
            
            self.logger.debug(f"âœ… Progress summary generated for project {project_id}")
            return summary
            
        except Exception as e:
            self.logger.error(f"âŒ Failed to get project progress summary for {project_id}: {e}")
            return {}
    
    def _calculate_total_floors(self, zones: Dict) -> int:
        """
        Calculate total floors from zones configuration
        
        Args:
            zones: Zones dictionary
            
        Returns:
            Total number of floors
        """
        try:
            if not zones:
                return 0
            
            total = 0
            for zone_name, zone_config in zones.items():
                if isinstance(zone_config, dict):
                    total += zone_config.get('max_floors', 0)
                elif isinstance(zone_config, (int, float)):
                    total += int(zone_config)
            
            return total
        except Exception as e:
            self.logger.error(f"Error calculating total floors: {e}")
            return 0
    
    def project_exists(self, user_id: int, project_name: str) -> bool:
        """
        Check if a project with the same name exists for the user
        
        Args:
            user_id: User ID to check
            project_name: Project name to check
            
        Returns:
            True if project exists, False otherwise
        """
        try:
            count = self.session.query(ProjectDB).filter(
                ProjectDB.user_id == user_id,
                ProjectDB.name == project_name,
                ProjectDB.status != 'archived'
            ).count()
            
            return count > 0
            
        except Exception as e:
            self.logger.error(f"âŒ Failed to check project existence: {e}")
            return False
    
    def get_recent_projects(self, user_id: int, limit: int = 5) -> List[ProjectDB]:
        """
        Get most recently updated projects for a user
        
        Args:
            user_id: User ID to filter projects
            limit: Maximum number of projects to return
            
        Returns:
            List of recent ProjectDB objects
        """
        try:
            return self.session.query(ProjectDB).filter(
                ProjectDB.user_id == user_id,
                ProjectDB.status != 'archived'
            ).order_by(
                desc(ProjectDB.updated_at)
            ).limit(limit).all()
            
        except Exception as e:
            self.logger.error(f"âŒ Failed to get recent projects for user {user_id}: {e}")
            return []

# ====== End of backend/db/repositories/project_repo.py ======



# ====== Begin of frontend/components/forms/project_forms.py ======

"""
PROFESSIONAL Project Forms - PRODUCTION READY
Enhanced with session state persistence to prevent rerun issues
"""
import streamlit as st
import pandas as pd
from typing import Dict, List, Optional, Tuple, Any
from datetime import datetime, date
import traceback
import logging

logger = logging.getLogger(__name__)

class ProjectBasicInfoForm:
    """Professional project basic information form with session state persistence"""
    
    def __init__(self, db_session=None, form_prefix="basic_info", user_id=None, page_context="project_setup"):
        """
        Initialize professional project form
        
        Args:
            db_session: Database session for data operations
            form_prefix: Unique prefix for widget keys
            user_id: Current user ID for context
            page_context: Page context for widget management
        """
        self.db_session = db_session
        self.form_prefix = form_prefix
        self.user_id = user_id
        self.page_context = page_context
        
        # Initialize widget manager
        from backend.utils.widget_manager import widget_manager
        self.widget_manager = widget_manager
        
        # âœ… INITIALIZE SESSION STATE FOR FORM DATA PERSISTENCE
        self._initialize_form_session_state()
        
        logger.debug(f"âœ… ProjectBasicInfoForm initialized for user {user_id}")
    
    def _initialize_form_session_state(self):
        """Initialize session state for form data persistence"""
        form_key = f"basic_form_data_{self.user_id}_{self.page_context}"
        
        if form_key not in st.session_state:
            st.session_state[form_key] = {
                'project_name': 'Professional Construction Project',
                'project_manager': '',
                'start_date': datetime.now().date(),
                'description': '',
                'project_type': 'Commercial',
                'owner': '',
                'location': ''
            }
            logger.debug(f"âœ… Form session state initialized: {form_key}")
        
        self.form_data = st.session_state[form_key]
    
    def render(self) -> Optional[Dict[str, Any]]:
        """
        Render professional project information form with session state persistence
        
        Returns:
            Dict with form data if saved, None otherwise
        """
        logger.debug("ðŸ”„ Rendering ProjectBasicInfoForm")
        
        st.markdown("### ðŸ—ï¸ Professional Project Details")
        
        # Professional two-column layout
        col1, col2 = st.columns(2)
        
        with col1:
            # Project Name - âœ… USE SESSION STATE DATA
            project_name_key = self.widget_manager.generate_key("project_name", self.page_context, self.user_id)
            project_name = st.text_input(
                "ðŸ“‹ Project Name *",
                value=self.form_data['project_name'],  # âœ… Session state value
                help="Official name of your construction project",
                placeholder="e.g., Downtown Commercial Tower Construction",
                key=project_name_key
            )
            
            # Project Type - âœ… USE SESSION STATE DATA
            project_type_key = self.widget_manager.generate_key("project_type", self.page_context, self.user_id)
            project_type_options = ['Commercial', 'Residential', 'Industrial', 'school', 'hospital']
            current_type_index = project_type_options.index(self.form_data['project_type']) if self.form_data['project_type'] in project_type_options else 0
            
            project_type = st.selectbox(
                "ðŸ¢ Project Type *",
                options=project_type_options,
                index=current_type_index,  # âœ… Session state value
                help="Category of construction project",
                key=project_type_key
            )
            
            # Owner - âœ… USE SESSION STATE DATA
            owner_key = self.widget_manager.generate_key("owner", self.page_context, self.user_id)
            owner = st.text_input(
                "ðŸ‘¥ owner/Maitre d'ouvrage",
                value=self.form_data['owner'],  # âœ… Session state value
                help="Name of the project client or project master",
                placeholder="e.g., ABC Development Corporation",
                key=owner_key
            )
            
        with col2:
            # Project Manager - âœ… USE SESSION STATE DATA
            project_manager_key = self.widget_manager.generate_key("project_manager", self.page_context, self.user_id)
            project_manager = st.text_input(
                "ðŸ‘¨â€ðŸ’¼ Project Manager *",
                value=self.form_data['project_manager'],  # âœ… Session state value
                help="Lead project manager responsible for delivery",
                placeholder="e.g., Marie Dubois - Senior Project Manager",
                key=project_manager_key
            )
            
            # Start Date - âœ… USE SESSION STATE DATA
            start_date_key = self.widget_manager.generate_key("start_date", self.page_context, self.user_id)
            start_date = st.date_input(
                "ðŸ“… Project Start Date *",
                value=self.form_data['start_date'],  # âœ… Session state value
                min_value=date.today(),
                help="Planned commencement date for construction activities",
                key=start_date_key
            )
            
            # Location - âœ… USE SESSION STATE DATA
            location_key = self.widget_manager.generate_key("location", self.page_context, self.user_id)
            location = st.text_input(
                "ðŸ“ Project Location",
                value=self.form_data['location'],  # âœ… Session state value
                help="Physical address or location of construction site",
                placeholder="e.g., 123 Main Street, Downtown District",
                key=location_key
            )
        
        # Professional project description - âœ… USE SESSION STATE DATA
        description_key = self.widget_manager.generate_key("professional_description", self.page_context, self.user_id)
        description = st.text_area(
            "ðŸ“ Project Description & Scope",
            value=self.form_data['description'],  # âœ… Session state value
            help="Comprehensive description of project scope, objectives, and key deliverables",
            placeholder="Describe the project in detail...",
            height=100,
            key=description_key
        )
        
        # âœ… CRITICAL: UPDATE SESSION STATE WITH CURRENT FORM VALUES ON EVERY RENDER
        # This ensures data persists through Streamlit reruns
        self.form_data.update({
            'project_name': project_name,
            'project_type': project_type,
            'project_manager': project_manager,
            'start_date': start_date,
            'owner': owner,
            'location': location,
            'description': description
        })
        
        # Professional validation and submission
        save_button_key = self.widget_manager.generate_key("save_project_info", self.page_context, self.user_id)
        
        if st.button("ðŸ’¾ Save Professional Project Information", 
                    type="primary", 
                    use_container_width=True,
                    key=save_button_key):
            
            logger.info("ðŸ’¾ Save project information button clicked")
            
            validation_result = self._validate_form_data(
                project_name, project_manager, start_date
            )
            
            if validation_result['is_valid']:
                form_data = {
                    'project_name': project_name.strip(),
                    'project_type': project_type,
                    'project_manager': project_manager.strip(),
                    'start_date': start_date,
                    'owner': owner.strip(),
                    'location': location.strip(),
                    'description': description.strip(),
                    'created_at': datetime.now().isoformat(),
                    'status': 'planned'
                }
                
                logger.info(f"âœ… Project basic info validated and prepared: {project_name}")
                
                # âœ… Clear form data after successful save if needed
                # self._clear_form_data()
                
                return form_data
            else:
                for error in validation_result['errors']:
                    st.error(f"âŒ {error}")
                logger.warning(f"âŒ Project basic info validation failed: {validation_result['errors']}")
        
        return None
    
    def _clear_form_data(self):
        """Clear form data from session state (optional)"""
        form_key = f"basic_form_data_{self.user_id}_{self.page_context}"
        if form_key in st.session_state:
            st.session_state[form_key] = {
                'project_name': '',
                'project_manager': '',
                'start_date': datetime.now().date(),
                'description': '',
                'project_type': 'Commercial',
                'owner': '',
                'location': ''
            }
    
    def _validate_form_data(self, project_name: str, project_manager: str, start_date: date) -> Dict[str, Any]:
        """
        Professional form validation with comprehensive checks
        
        Args:
            project_name: Project name input
            project_manager: Project manager input  
            start_date: Project start date input
            
        Returns:
            Validation results dictionary
        """
        errors = []
        
        # Project name validation
        if not project_name or not project_name.strip():
            errors.append("Project name is required for identification")
        elif len(project_name.strip()) < 4:
            errors.append("Project name should be at least 4 characters for proper identification")
        elif len(project_name.strip()) > 200:
            errors.append("Project name cannot exceed 200 characters")
        
        # Project manager validation
        if not project_manager or not project_manager.strip():
            errors.append("Project manager designation is required for accountability")
        elif len(project_manager.strip()) < 2:
            errors.append("Project manager name should be at least 2 characters")
        
        # Start date validation
        if start_date < date.today():
            errors.append("Project start date cannot be in the past for planning purposes")
        
        return {
            'is_valid': len(errors) == 0,
            'errors': errors
        }


class ZoneConfigurationForm:
    """Professional zone configuration form with correct zones format"""
    
    def __init__(self, db_session=None, user_id=None, page_context="project_setup"):
        """
        Initialize professional zone configuration form
        
        Args:
            db_session: Database session for data operations
            user_id: Current user ID for context
            page_context: Page context for widget management
        """
        self.db_session = db_session
        self.form_prefix = "zone"
        self.user_id = user_id
        self.page_context = page_context
        
        # Initialize widget manager
        from backend.utils.widget_manager import widget_manager
        self.widget_manager = widget_manager
        
        # âœ… INITIALIZE ZONES SESSION STATE FOR PERSISTENCE
        self._initialize_zones_session_state()
        
        logger.debug(f"âœ… ZoneConfigurationForm initialized for user {user_id}")
    
    def _initialize_zones_session_state(self):
        """Initialize zones session state for persistence"""
        # Your existing zones initialization is correct
        if 'project_zones' not in st.session_state:
            st.session_state.project_zones = {}
            logger.debug("âœ… project_zones initialized in session state")
        
        # âœ… ADDITIONAL: Initialize zone creation form state
        zone_form_key = f"zone_creation_form_{self.user_id}_{self.page_context}"
        if zone_form_key not in st.session_state:
            st.session_state[zone_form_key] = {
                'zone_name': '',
                'max_floors': 7,
                'zone_sequence': 1,
                'zone_description': ''
            }
        
        self.zone_form_data = st.session_state[zone_form_key]
    
    def render(self) -> None:
        """
        Render complete zone management interface
        """
        logger.debug("ðŸ”„ Rendering ZoneConfigurationForm")
        
        st.markdown("### ðŸ¢ Professional Zone Configuration")
        
        # Section 1: Add New Zone Form
        self._render_zone_creation_section()
        
        # Section 2: Current Zones Display & Management
        if st.session_state.project_zones:
            self._render_zones_management_section()
        else:
            st.info("ðŸ“ No zones configured yet. Add your first zone above.")
            logger.debug("â„¹ï¸ No zones configured in session state")
    
    def _render_zone_creation_section(self) -> None:
        """
        Render zone creation form with session state persistence
        """
        logger.debug("ðŸ”„ Rendering zone creation section")
        
        st.markdown("#### âž• Add New Zone")
        
        col1, col2, col3 = st.columns([3, 1, 1])
        
        with col1:
            zone_name_key = self.widget_manager.generate_key("zone_name", self.page_context, self.user_id)
            zone_name = st.text_input(
                "ðŸ·ï¸ Zone Name *",
                value=self.zone_form_data['zone_name'],  # âœ… Session state value
                placeholder="e.g., Tower A, West Wing, Basement Parking",
                help="Unique identifier for this building zone or section",
                key=zone_name_key
            )
        
        with col2:
            max_floors_key = self.widget_manager.generate_key("max_floors", self.page_context, self.user_id)
            max_floors = st.number_input(
                "ðŸ—ï¸ Max Floors *",
                min_value=0, max_value=200, 
                value=self.zone_form_data['max_floors'],  # âœ… Session state value
                help="Total number of floors in this zone",
                key=max_floors_key
            )
        
        with col3:
            zone_sequence_key = self.widget_manager.generate_key("zone_sequence", self.page_context, self.user_id)
            zone_sequence = st.number_input(
                "ðŸ”¢ Sequence",
                min_value=1, max_value=20, 
                value=self.zone_form_data['zone_sequence'],  # âœ… Session state value
                help="Construction sequence order for this zone",
                key=zone_sequence_key
            )
        
        zone_description_key = self.widget_manager.generate_key("zone_description", self.page_context, self.user_id)
        zone_description = st.text_area(
            "ðŸ“ Zone Description",
            value=self.zone_form_data['zone_description'],  # âœ… Session state value
            placeholder="Describe this zone's characteristics...",
            help="Additional information about this zone",
            height=60,
            key=zone_description_key
        )
        
        # âœ… UPDATE ZONE CREATION FORM STATE
        self.zone_form_data.update({
            'zone_name': zone_name,
            'max_floors': max_floors,
            'zone_sequence': zone_sequence,
            'zone_description': zone_description
        })
        
        add_zone_key = self.widget_manager.generate_key("add_zone", self.page_context, self.user_id)
        
        if st.button("âž• Add Professional Zone", 
                    use_container_width=True,
                    key=add_zone_key):
            
            logger.info(f"âž• Add zone button clicked: {zone_name}")
            
            validation_result = self._validate_zone_data(zone_name, max_floors)
            
            if validation_result['is_valid']:
                # âœ… CORRECT FORMAT: {zone_name: {max_floors: x, sequence: y, description: z}}
                st.session_state.project_zones[zone_name.strip()] = {
                    'max_floors': max_floors,
                    'sequence': zone_sequence,
                    'description': zone_description.strip()
                }
                
                # âœ… CLEAR ZONE CREATION FORM AFTER SUCCESSFUL ADD
                self._clear_zone_creation_form()
                
                st.success(f"âœ… Zone '{zone_name}' added with {max_floors} floors (Sequence: {zone_sequence})!")
                logger.info(f"âœ… Zone added to session state: {zone_name} with {max_floors} floors, sequence {zone_sequence}")
                st.rerun()
            else:
                for error in validation_result['errors']:
                    st.error(f"âŒ {error}")
                logger.warning(f"âŒ Zone validation failed: {validation_result['errors']}")
    
    def _clear_zone_creation_form(self):
        """Clear zone creation form data"""
        zone_form_key = f"zone_creation_form_{self.user_id}_{self.page_context}"
        st.session_state[zone_form_key] = {
            'zone_name': '',
            'max_floors': 7,
            'zone_sequence': 1,
            'zone_description': ''
        }
        self.zone_form_data = st.session_state[zone_form_key]
    
    def _render_zones_management_section(self):
        """
        Render zones management interface with professional controls
        """
        logger.debug("ðŸ”„ Rendering zones management section")
        
        st.markdown("---")
        st.markdown("#### ðŸ“‹ Current Zones")
        
        # Display zones table
        self._render_zones_table()
        
        # Zone management controls
        self._render_zone_management_controls()
    
    def _render_zones_table(self):
        """
        Render professional zones table with summary metrics
        """
        logger.debug("ðŸ”„ Rendering zones table")
        
        zones_data = []
        for zone_name, zone_config in st.session_state.project_zones.items():
            zones_data.append({
                'Zone Name': zone_name,
                'Max Floors': zone_config.get('max_floors', 0),
                'Sequence': zone_config.get('sequence', 1),
                'Description': zone_config.get('description', '')
            })
        
        if zones_data:
            df = pd.DataFrame(zones_data)
            st.dataframe(
                df,
                use_container_width=True,
                hide_index=True
            )
            
            # Professional summary metrics
            col1, col2, col3 = st.columns(3)
            with col1:
                total_zones = len(st.session_state.project_zones)
                st.metric("Total Zones", total_zones)
            with col2:
                total_floors = sum(zone_config.get('max_floors', 0) for zone_config in st.session_state.project_zones.values())
                st.metric("Total Floors", total_floors)
            with col3:
                sequences = [zone_config.get('sequence', 1) for zone_config in st.session_state.project_zones.values()]
                if sequences:
                    st.metric("Sequence Range", f"{min(sequences)}-{max(sequences)}")
                else:
                    st.metric("Sequence Range", "N/A")
            
            logger.debug(f"âœ… Zones table rendered with {len(zones_data)} zones")
    
    def _render_zone_management_controls(self):
        """
        Render professional zone management controls
        """
        logger.debug("ðŸ”„ Rendering zone management controls")
        
        st.markdown("#### ðŸ› ï¸ Zone Management")
        
        col1, col2 = st.columns(2)
        
        with col1:
            removal_selector_key = self.widget_manager.generate_key("zone_removal_selector", self.page_context, self.user_id)
            zones_to_remove = st.multiselect(
                "Select zones to remove:",
                options=list(st.session_state.project_zones.keys()),
                help="Select zones to remove from configuration",
                key=removal_selector_key
            )
            
            remove_button_key = self.widget_manager.generate_key("remove_zones_btn", self.page_context, self.user_id)
            
            if st.button("ðŸ—‘ï¸ Remove Selected Zones", 
                        use_container_width=True,
                        key=remove_button_key) and zones_to_remove:
                
                logger.info(f"ðŸ—‘ï¸ Removing zones: {zones_to_remove}")
                
                for zone in zones_to_remove:
                    del st.session_state.project_zones[zone]
                
                st.success(f"âœ… Removed zones: {', '.join(zones_to_remove)}")
                logger.info(f"âœ… Zones removed successfully: {zones_to_remove}")
                st.rerun()
        
        with col2:
            clear_button_key = self.widget_manager.generate_key("clear_all_zones_btn", self.page_context, self.user_id)
            
            if st.button("ðŸ”„ Clear All Zones", 
                        use_container_width=True, 
                        type="secondary",
                        key=clear_button_key):
                
                confirm_key = self.widget_manager.generate_key("confirm_clear_checkbox", self.page_context, self.user_id)
                if st.checkbox("Confirm clear all zones", key=confirm_key):
                    st.session_state.project_zones = {}
                    st.success("âœ… All zones cleared!")
                    logger.info("âœ… All zones cleared from session state")
                    st.rerun()
    
    def _validate_zone_data(self, zone_name: str, max_floors: int) -> Dict[str, Any]:
        """
        Professional zone data validation
        
        Args:
            zone_name: Zone name input
            max_floors: Maximum floors input
            
        Returns:
            Validation results dictionary
        """
        errors = []
        
        # Zone name validation
        if not zone_name or not zone_name.strip():
            errors.append("Zone name is required for identification")
        elif len(zone_name.strip()) < 2:
            errors.append("Zone name should be at least 2 characters")
        elif len(zone_name.strip()) > 50:
            errors.append("Zone name cannot exceed 50 characters")
        elif zone_name.strip() in st.session_state.project_zones:
            errors.append(f"Zone '{zone_name}' already exists")
        
        # Max floors validation
        if max_floors < 0:
            errors.append("Maximum floors cannot be negative")
        elif max_floors > 200:
            errors.append("Maximum floors cannot exceed 200 for practical planning")
        elif max_floors == 0:
            errors.append("Maximum floors must be at least 1")
        
        return {
            'is_valid': len(errors) == 0,
            'errors': errors
        }
    
    def get_zones_data(self) -> Dict[str, Dict[str, Any]]:
        """
        Get current zones data in database-compatible format
        
        Returns:
            Dictionary with zone names as keys and zone config as values
            Format: {zone_name: {'max_floors': int, 'sequence': int, 'description': str}}
        """
        zones_data = st.session_state.project_zones.copy()
        logger.debug(f"ðŸ“Š Retrieved zones data for saving: {zones_data}")
        return zones_data
    
    def get_zones_count(self) -> int:
        """
        Get total number of configured zones
        
        Returns:
            Integer count of zones
        """
        return len(st.session_state.project_zones)
    
    def get_total_floors(self) -> int:
        """
        Get total floors across all zones
        
        Returns:
            Integer sum of all zone floors
        """
        return sum(zone_config.get('max_floors', 0) for zone_config in st.session_state.project_zones.values())

# ====== End of frontend/components/forms/project_forms.py ======



# ====== Begin of frontend/pages/generate_schedule.py ======

"""
Generate Schedule Page - UPDATED with Template Selection & Import/Export
PROFESSIONAL VERSION: Users can choose between Excel upload or Template selection
"""
import streamlit as st
import pandas as pd
import os
import tempfile
import zipfile
import io
import json
from datetime import datetime
from typing import Dict, Any
from sqlalchemy.orm import Session

from frontend.components.charts.gantt_display import render_gantt_with_controls
from frontend.components.charts.progress_charts import render_schedule_metrics
from frontend.components.data_tables.schedule_table import render_schedule_table
from frontend.components.navigation.sidebar import render_project_selector
from frontend.components.auth.auth_guard import require_auth

@require_auth("write")
def show(db_session: Session, services: Dict[str, Any], user_id: int):
    """
    UPDATED Main schedule generation page with template selection option
    """
    # âœ… Use services passed from app.py
    if not services:
        st.error("âŒ Services not initialized")
        return
    # âœ… Get user info from SessionManager
    session_manager = st.session_state.auth_session_manager
    user_info = _get_user_info(session_manager)
    
    st.markdown('<div class="main-header">ðŸ“… Generate Construction Schedule</div>', unsafe_allow_html=True)
    st.caption(f"User: {user_info['username']} | Project: {_get_current_project_name()}")
    
        # âœ… FIXED: Do NOT store db_session or user_id in session state
    # Database sessions are request-scoped and should not persist
    
    # Initialize session state
    _initialize_session_state()
    
    # Render navigation
    render_project_selector(db_session, user_id)
    
    # Check prerequisites
    if not _check_prerequisites():
        return
    
    # Main content - UPDATED with template selection
    _render_input_method_selection(db_session, user_id)
    
    # Results display
    if st.session_state.get('schedule_generated'):
        _render_schedule_results(db_session, user_id)


def _get_user_info(session_manager) -> Dict[str, Any]:
    """Get user information from SessionManager"""
    return {
        'id': session_manager.get_user_id(),
        'username': session_manager.get_username(),
        'role': session_manager.get_user_role(),
        'full_name': session_manager.get_username()
    }


def _get_current_project_name() -> str:
    """Get current project name safely"""
    project_config = st.session_state.get('project_config', {})
    basic_info = project_config.get('basic_info', {})
    return basic_info.get('project_name', 'No Project Selected')


def _initialize_session_state():
    """Initialize session state for schedule generation"""
    defaults = {
        'schedule_generated': False,
        'schedule_results': None,
        'current_project_id': None,
        'input_method': 'templates',  # 'templates' or 'excel'
        'selected_task_template': None,
        'selected_resource_template': None,
        'uploaded_files': {},
        'reports_folder': None
    }
    
    for key, value in defaults.items():
        if key not in st.session_state:
            st.session_state[key] = value


def _check_prerequisites() -> bool:
    """Check if all prerequisites are met for schedule generation"""
    # Check project configuration
    if 'project_config' not in st.session_state or not st.session_state.project_config.get('zones'):
        st.error("âŒ Please configure your project in the Project Setup page first.")
        st.info("Go to Project Setup to define your building zones and floors.")
        return False
    
    return True


def _render_input_method_selection(db_session: Session, services: Dict[str, Any], user_id: int):
    """Render input method selection (Templates vs Excel Upload)"""
    st.subheader("ðŸ”§ Choose Input Method")
    
    # Input method selection
    input_method = st.radio(
        "Select how you want to provide scheduling data:",
        options=["ðŸ“ Use Templates (Recommended)", "ðŸ“¤ Upload Excel Files"],
        key="input_method_selector",
        help="Choose between using your saved templates or uploading Excel files"
    )
    
    st.session_state.input_method = 'templates' if input_method.startswith("ðŸ“") else 'excel'
    
    if st.session_state.input_method == 'templates':
        _render_template_selection(db_session,  services, user_id)
    else:
        _render_excel_upload_section(db_session,  services, user_id)
    
    # Import/Export section (moved from templates_manager)
    _render_import_export_section(services, user_id)


def _render_template_selection(db_session: Session, services: Dict[str, Any],user_id: int):
    """Render template selection interface"""
    st.markdown("---")
    st.subheader("ðŸ“‹ Select Templates for Scheduling")
    
    try:
        template_service = services['template_service']
        
        # Get available templates
        available_templates = template_service.get_available_templates(user_id)
        resource_templates = available_templates.get('resource_templates', [])
        task_templates = available_templates.get('task_templates', [])
        
        if not resource_templates or not task_templates:
            st.error("âŒ No templates found. Please create templates in the Templates Manager first.")
            return
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.markdown("#### ðŸ“ Task Template")
            task_template_options = {t.get('template_name', f"Template_{i}"): t for i, t in enumerate(task_templates)}
            selected_task_template_name = st.selectbox(
                "Select Task Template:",
                options=list(task_template_options.keys()),
                key="task_template_select",
                help="Choose the task template to use for scheduling"
            )
            
            if selected_task_template_name:
                st.session_state.selected_task_template = task_template_options[selected_task_template_name]
                # Display task template info
                task_template = st.session_state.selected_task_template
                st.info(f"**Tasks:** {len(task_template.get('tasks', []))} | **Disciplines:** {len(set(t.get('discipline') for t in task_template.get('tasks', [])))}")
        
        with col2:
            st.markdown("#### ðŸ‘¥ Resource Template")
            resource_template_options = {t.get('name', f"Resource_{i}"): t for i, t in enumerate(resource_templates)}
            selected_resource_template_name = st.selectbox(
                "Select Resource Template:",
                options=list(resource_template_options.keys()),
                key="resource_template_select",
                help="Choose the resource template to use for scheduling"
            )
            
            if selected_resource_template_name:
                st.session_state.selected_resource_template = resource_template_options[selected_resource_template_name]
                # Display resource template info
                resource_template = st.session_state.selected_resource_template
                template_metrics = template_service.get_template_metrics(user_id, 
                                                                        st.session_state.selected_task_template,
                                                                        st.session_state.selected_resource_template)
                st.info(f"**Workers:** {template_metrics.get('worker_count', 0)} | **Equipment:** {template_metrics.get('equipment_count', 0)}")
        
        # Validate template dependency
        if st.session_state.selected_task_template and st.session_state.selected_resource_template:
            validation_result = template_service.validate_template_dependency(
                user_id, 
                st.session_state.selected_task_template, 
                st.session_state.selected_resource_template
            )
            
            if not validation_result['is_valid']:
                st.warning("âš ï¸ Template dependency validation failed:")
                if validation_result['missing_workers']:
                    st.error(f"Missing workers: {', '.join(validation_result['missing_workers'])}")
                if validation_result['missing_equipment']:
                    st.error(f"Missing equipment: {', '.join(validation_result['missing_equipment'])}")
            else:
                st.success("âœ… Template dependency validation passed!")
                
            # Show warnings
            for warning in validation_result['warnings']:
                st.warning(warning)
            
            # Schedule generation parameters
            _render_schedule_parameters(db_session, user_id, method='templates')
            
    except Exception as e:
        st.error(f"âŒ Error loading templates: {e}")


def _render_excel_upload_section(db_session: Session, user_id: int):
    """Render Excel file upload interface"""
    st.markdown("---")
    st.subheader("ðŸ“¤ Upload Excel Files")
    
    st.info("""
    **Required Files:**
    - ðŸ“Š **Quantity Template**: Task quantities per zone/floor
    - ðŸ‘¥ **Resources Template**: Worker definitions and rates  
    - ðŸ› ï¸ **Equipment Template**: Equipment definitions and rates
    """)
    
    col1, col2, col3 = st.columns(3)
    
    with col1:
        quantity_file = st.file_uploader(
            "Quantity Template (Excel)",
            type=["xlsx", "xls"],
            key="quantity_upload",
            help="Upload Excel file with task quantities"
        )
    
    with col2:
        resources_file = st.file_uploader(
            "Resources Template (Excel)", 
            type=["xlsx", "xls"],
            key="resources_upload",
            help="Upload Excel file with worker resources"
        )
    
    with col3:
        equipment_file = st.file_uploader(
            "Equipment Template (Excel)",
            type=["xlsx", "xls"], 
            key="equipment_upload",
            help="Upload Excel file with equipment resources"
        )
    
    # Store uploaded files
    if quantity_file:
        st.session_state.uploaded_files['quantity'] = quantity_file
    if resources_file:
        st.session_state.uploaded_files['resources'] = resources_file
    if equipment_file:
        st.session_state.uploaded_files['equipment'] = equipment_file
    
    # Check if all required files are uploaded
    required_files = ['quantity']
    missing_files = [f for f in required_files if f not in st.session_state.uploaded_files]
    
    if missing_files:
        st.error(f"âŒ Missing required files: {', '.join(missing_files)}")
        return
    
    # Schedule generation parameters
    _render_schedule_parameters(db_session, user_id, method='excel')


def _render_schedule_parameters(db_session: Session, user_id: int, method: str):
    """Render schedule generation parameters"""
    st.markdown("---")
    st.subheader("âš™ï¸ Schedule Parameters")
    
    col1, col2 = st.columns(2)
    
    with col1:
        optimization_level = st.selectbox(
            "Optimization Level",
            options=["Balanced", "Time-Optimized", "Cost-Optimized", "Resource-Efficient"],
            help="Choose the optimization strategy for schedule generation",
            key="optimization_level"
        )
        
        include_risk_analysis = st.checkbox(
            "Include Risk Analysis",
            value=True,
            help="Include risk factors and contingencies in scheduling",
            key="include_risk_analysis"
        )
    
    with col2:
        # Get acceleration factor from project config with fallback
        acceleration_factor = st.session_state.project_config.get(
            'advanced_settings', {}
        ).get('acceleration_factor', 1.0)
        
        acceleration_factor = st.slider(
            "Acceleration Factor",
            min_value=0.5,
            max_value=3.0,
            value=acceleration_factor,
            step=0.1,
            help="Factor to accelerate the schedule (requires more resources)",
            key="acceleration_factor"
        )
        
        generate_reports = st.checkbox(
            "Generate Detailed Reports",
            value=True,
            help="Generate comprehensive Excel reports and analysis",
            key="generate_reports"
        )
    
    # Generate schedule button
    generate_disabled = False
    if method == 'templates' and (not st.session_state.selected_task_template or not st.session_state.selected_resource_template):
        generate_disabled = True
    elif method == 'excel' and 'quantity' not in st.session_state.uploaded_files:
        generate_disabled = True
    
    if st.button("ðŸŽ¯ Generate Optimized Schedule", 
                 type="primary", 
                 use_container_width=True,
                 disabled=generate_disabled):
        _generate_schedule(
            db_session=db_session,
            user_id=user_id,
            method=method,
            optimization_level=optimization_level,
            acceleration_factor=acceleration_factor,
            include_risk_analysis=include_risk_analysis,
            generate_reports=generate_reports
        )


def _generate_schedule(db_session: Session, user_id: int, method: str, optimization_level: str, 
                      acceleration_factor: float, include_risk_analysis: bool, 
                      generate_reports: bool):
    """
    UPDATED: Generate schedule using either templates or Excel files
    """
    try:
        with st.spinner("ðŸ”„ Generating optimized schedule... This may take a few moments."):
            # Prepare scheduling parameters
            scheduling_params = {
                'zones_floors': st.session_state.project_config['zones'],
                'start_date': st.session_state.project_config['basic_info']['start_date'],
                'optimization_level': optimization_level,
                'acceleration_factor': acceleration_factor,
                'include_risk_analysis': include_risk_analysis,
                'work_sequences': st.session_state.get('work_sequences', []),
                'project_id': st.session_state.get('current_project_id'),
                'project_name': st.session_state.project_config['basic_info'].get('project_name', 'Unnamed Project')
            }
            
            from backend.services.scheduling_service import SchedulingService
            scheduling_service = SchedulingService(db_session)
            
            if method == 'templates':
                # Use TemplateService to convert templates to scheduler input
                from backend.services.template_service import TemplateService
                template_service = TemplateService(db_session)
                
                scheduler_input = template_service.convert_templates_to_scheduler_input(
                    user_id,
                    st.session_state.selected_task_template,
                    st.session_state.selected_resource_template,
                    st.session_state.project_config
                )
                
                schedule_results = scheduling_service.generate_schedule(
                    user_id, 
                    scheduler_input['quantity_file'],
                    scheduler_input['resources_file'], 
                    scheduler_input['equipment_file'],
                    scheduling_params
                )
            else:
                # Use uploaded Excel files
                quantity_file = st.session_state.uploaded_files['quantity']
                resources_file = st.session_state.uploaded_files.get('resources')
                equipment_file = st.session_state.uploaded_files.get('equipment')
                
                schedule_results = scheduling_service.generate_schedule(
                    user_id, quantity_file, resources_file, equipment_file, scheduling_params
                )
            
            # Store results
            st.session_state.schedule_results = schedule_results
            st.session_state.schedule_generated = True
            
            # Generate reports if requested
            if generate_reports:
                _generate_detailed_reports(schedule_results, db_session, user_id)
            
            st.success("âœ… Schedule generated successfully!")
            st.balloons()
            
    except Exception as e:
        st.error(f"âŒ Schedule generation failed: {str(e)}")
        import logging
        logging.error(f"Schedule generation error: {e}", exc_info=True)


def _render_import_export_section(services: Dict[str, Any],
                                  user_id: int):
    """Render import/export section (moved from templates_manager)"""
    st.markdown("---")
    st.subheader("ðŸ“¤ Import/Export Templates")
    
    try:
        template_service = services['template_service']
        
        col1, col2 = st.columns(2)

        # Task Templates Import/Export
        with col1:
            st.markdown("#### ðŸ“‹ Task Templates")
            st.markdown("---")
            
            # Export Section
            st.markdown("**ðŸ“¤ Export Task Templates**")
            if st.button("ðŸ“¥ Generate Task Template Export", width='stretch', key="generate_task_export"):
                try:
                    task_json = template_service.export_task_templates( user_id)
                    
                    st.download_button( 
                        label="ðŸ’¾ Download Task Templates",
                        data=task_json,
                        file_name=f"task_templates_export_{datetime.now().strftime('%Y%m%d')}.json",
                        mime="application/json",
                        width='stretch',
                        key="download_task_json"
                    )
                except Exception as e:
                    st.error(f"âŒ Error during export: {e}")

            # Import Section
            st.markdown("**ðŸ“¥ Import Task Templates**")
            task_upload = st.file_uploader("Task Template JSON", type=["json"], key="task_upload")
            if task_upload and st.button("ðŸ“¤ Import Task Templates", width='stretch', key="upload_tasks"):
                try:
                    if template_service.import_task_templates(user_id, task_upload):
                        st.success("âœ… Task templates imported successfully!")
                        st.rerun()
                    else:
                        st.error("âŒ Failed to import task templates")
                except Exception as e:
                    st.error(f"âŒ Error during import: {e}")

        # Resource Templates Import/Export
        with col2:
            st.markdown("#### ðŸ‘¥ Resource Templates")
            st.markdown("---")
            
            # Export Section
            st.markdown("**ðŸ“¤ Export Resource Templates**")
            if st.button("ðŸ“¥ Generate Resource Template Export", width='stretch', key="generate_resource_export"):
                try:
                    resource_json = template_service.export_resource_templates(user_id)
                    
                    st.download_button(
                        label="ðŸ’¾ Download Resource Templates",
                        data=resource_json,
                        file_name=f"resource_templates_export_{datetime.now().strftime('%Y%m%d')}.json",
                        mime="application/json",
                        width='stretch',
                        key="download_resource_json"
                    )
                except Exception as e:
                    st.error(f"âŒ Error during export: {e}")

            # Import Section
            st.markdown("**ðŸ“¥ Import Resource Templates**")
            resource_upload = st.file_uploader("Resource Template JSON", type=["json"], key="resource_upload")
            if resource_upload and st.button("ðŸ“¤ Import Resource Templates", width='stretch', key="upload_resources"):
                try:
                    if template_service.import_resource_templates(user_id, resource_upload):
                        st.success("âœ… Resource templates imported successfully!")
                        st.rerun()
                    else:
                        st.error("âŒ Failed to import resource templates")
                except Exception as e:
                    st.error(f"âŒ Error during import: {e}")

    except Exception as e:
        st.error(f"âŒ Error in import/export section: {e}")


def _generate_detailed_reports(schedule_results, db_session: Session, user_id: int):
    """Generate detailed reports for the schedule"""
    try:
        with st.spinner("ðŸ“Š Generating detailed reports..."):
            from backend.reporting.scheduling_reporter import SchedulingReporter
            
            # Create reporter with proper dependencies
            reporter = SchedulingReporter(
                schedule_results.tasks,
                schedule_results.schedule,
                schedule_results.worker_manager,
                schedule_results.equipment_manager,
                schedule_results.calendar
            )
            
            # Generate all reports
            reports_folder = reporter.export_all_reports()
            st.session_state.reports_folder = reports_folder
            
            # Save schedule to database for history
            _save_schedule_to_database(schedule_results, db_session, user_id)
            
            st.success(f"âœ… Detailed reports generated in: {reports_folder}")
            
    except Exception as e:
        st.warning(f"âš ï¸ Report generation completed with warnings: {e}")


def _save_schedule_to_database(schedule_results, db_session: Session, user_id: int):
    """Save generated schedule to database for history and tracking"""
    try:
        from backend.services.scheduling_service import SchedulingService
        
        scheduling_service = SchedulingService(db_session)
        
        # âœ… FIXED: Use user_id parameter instead of reading from session state
        
        # Convert schedule to saveable format
        schedule_data = {
            'project_id': st.session_state.get('current_project_id'),
            'schedule_data': _convert_schedule_to_dict(schedule_results),
            'generated_by': user_id,
            'generation_date': datetime.now()
        }
        
        scheduling_service.save_schedule(user_id, schedule_data)
        
    except Exception as e:
        # Non-critical operation - log but don't fail the whole process
        import logging
        logging.warning(f"Failed to save schedule to database: {e}")


def _convert_schedule_to_dict(schedule_results) -> Dict[str, Any]:
    """Convert schedule results to dictionary for storage"""
    return {
        'tasks': [
            {
                'id': task.id,
                'name': task.name,
                'discipline': task.discipline,
                'zone': task.zone,
                'floor': task.floor,
                'resource_type': task.resource_type,
                'allocated_crews': getattr(task, 'allocated_crews', 0),  # âœ… FIXED: Use getattr
                'allocated_equipments': getattr(task, 'allocated_equipments', {}),  # âœ… FIXED: Use getattr
                'status': getattr(task.status, 'value', 'Unknown')
            }
            for task in schedule_results.tasks
        ],
        'schedule': {
            task_id: [start.isoformat(), end.isoformat()] 
            for task_id, (start, end) in schedule_results.schedule.items()
        },
        'metadata': {
            'total_tasks': len(schedule_results.tasks),
            'generation_timestamp': datetime.now().isoformat()
        }
    }


def _render_schedule_results(db_session: Session, user_id: int):
    """Render schedule results and visualization"""
    st.markdown("---")
    st.subheader("ðŸ“Š Schedule Results")
    
    # Schedule metrics
    render_schedule_metrics(st.session_state.schedule_results)
    
    # Resource Allocation Summary
    _render_allocation_summary()
    
    # Interactive Gantt Chart
    st.markdown("---")
    st.subheader("ðŸ“ˆ Interactive Gantt Chart")
    
    # Convert schedule to DataFrame for Gantt chart
    schedule_df = _convert_schedule_to_dataframe()
    render_gantt_with_controls(schedule_df)
    
    # Schedule details table
    st.markdown("---")
    st.subheader("ðŸ“‹ Schedule Details")
    
    with st.expander("View Detailed Schedule with Allocations", expanded=False):
        render_schedule_table(schedule_df)
    
    # Export options
    st.markdown("---")
    _render_export_section(db_session, user_id)


def _render_allocation_summary():
    """Render resource allocation summary"""
    schedule_results = st.session_state.schedule_results
    
    if not schedule_results:
        return
    
    st.markdown("#### ðŸ‘¥ Resource Allocation Summary")
    
    # Crew allocations
    col1, col2, col3 = st.columns(3)
    
    with col1:
        total_tasks = len(schedule_results.tasks)
        tasks_with_allocations = sum(1 for task in schedule_results.tasks 
                                   if getattr(task, 'allocated_crews', 0) > 0)
        st.metric("Tasks with Crew Allocations", f"{tasks_with_allocations}/{total_tasks}")
    
    with col2:
        total_allocated_crews = sum(getattr(task, 'allocated_crews', 0) 
                                  for task in schedule_results.tasks)
        st.metric("Total Crews Allocated", total_allocated_crews)
    
    with col3:
        # Calculate utilization
        if hasattr(schedule_results, 'resource_utilization'):
            avg_utilization = sum(schedule_results.resource_utilization.values()) / len(schedule_results.resource_utilization) * 100
            st.metric("Average Utilization", f"{avg_utilization:.1f}%")
    
    # Equipment allocations
    st.markdown("#### ðŸ› ï¸ Equipment Allocations")
    equipment_usage = {}
    for task in schedule_results.tasks:
        allocated_equipments = getattr(task, 'allocated_equipments', {})
        for equip_name, count in allocated_equipments.items():
            equipment_usage[equip_name] = equipment_usage.get(equip_name, 0) + count
    
    if equipment_usage:
        equip_cols = st.columns(3)
        for idx, (equip_name, total_count) in enumerate(equipment_usage.items()):
            with equip_cols[idx % 3]:
                st.metric(f"Total {equip_name}", total_count)


def _convert_schedule_to_dataframe() -> pd.DataFrame:
    """Convert schedule results to DataFrame with allocation data"""
    schedule_results = st.session_state.schedule_results
    
    if not schedule_results or not hasattr(schedule_results, 'tasks'):
        return pd.DataFrame()
    
    rows = []
    
    for task in schedule_results.tasks:
        if (hasattr(schedule_results, 'schedule') and 
            task.id in schedule_results.schedule):
            
            start_date, end_date = schedule_results.schedule[task.id]
            duration = (end_date - start_date).days
            
            # Get allocation data
            allocated_crews = getattr(task, 'allocated_crews', 0)
            allocated_equipments = getattr(task, 'allocated_equipments', {})
            
            rows.append({
                'TaskID': task.id,
                'TaskName': task.name,
                'Discipline': task.discipline,
                'Zone': task.zone,
                'Floor': task.floor,
                'Start': start_date,
                'End': end_date,
                'Duration': duration,
                'ResourceType': getattr(task, 'resource_type', 'Unknown'),
                'MinCrewsNeeded': getattr(task, 'min_crews_needed', 0),
                'AllocatedCrews': allocated_crews,  # âœ… ACTUAL allocation
                'MaxCrewsAllowed': getattr(task, 'max_crews_allowed', 0),  # âœ… NEW
                'AllocatedEquipment': allocated_equipments,  # âœ… ACTUAL allocation
                'Status': getattr(task.status, 'value', 'Unknown'),
                'IsCriticalPath': task.id in getattr(schedule_results, 'critical_path', [])
            })
    
    return pd.DataFrame(rows)


def _render_export_section(db_session: Session, user_id: int):
    """Render schedule export options"""
    st.subheader("ðŸ“¤ Export Results")
    
    col1, col2, col3 = st.columns(3)
    
    with col1:
        if st.session_state.get('reports_folder') and os.path.exists(st.session_state.reports_folder):
            # Create zip of all reports
            zip_buffer = io.BytesIO()
            with zipfile.ZipFile(zip_buffer, 'w') as zip_file:
                for root, dirs, files in os.walk(st.session_state.reports_folder):
                    for file in files:
                        file_path = os.path.join(root, file)
                        arcname = os.path.relpath(file_path, st.session_state.reports_folder)
                        zip_file.write(file_path, arcname)
            
            st.download_button(
                "ðŸ“¦ Download All Reports (ZIP)",
                data=zip_buffer.getvalue(),
                file_name="construction_schedule_reports.zip",
                mime="application/zip",
                use_container_width=True,
                key="download_all_reports"
            )
        else:
            st.button(
                "ðŸ“¦ Download All Reports (ZIP)",
                disabled=True,
                help="Reports not available",
                use_container_width=True
            )
    
    with col2:
        # Export schedule as CSV
        schedule_df = _convert_schedule_to_dataframe()
        if not schedule_df.empty:
            csv_data = schedule_df.to_csv(index=False)
            
            st.download_button(
                "ðŸ“„ Export Schedule (CSV)",
                data=csv_data,
                file_name="construction_schedule.csv",
                mime="text/csv",
                use_container_width=True,
                key="export_csv"
            )
        else:
            st.button(
                "ðŸ“„ Export Schedule (CSV)",
                disabled=True,
                help="No schedule data available",
                use_container_width=True
            )
    
    with col3:
        # Export to Excel
        if (st.session_state.get('reports_folder') and 
            os.path.exists(st.session_state.reports_folder)):
            
            schedule_excel_path = os.path.join(
                st.session_state.reports_folder, 
                "construction_schedule.xlsx"
            )
            
            if os.path.exists(schedule_excel_path):
                with open(schedule_excel_path, 'rb') as f:
                    st.download_button(
                        "ðŸ“Š Export Schedule (Excel)",
                        data=f.read(),
                        file_name="construction_schedule.xlsx",
                        mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                        use_container_width=True,
                        key="export_excel"
                    )
            else:
                st.button(
                    "ðŸ“Š Export Schedule (Excel)",
                    disabled=True,
                    help="Excel report not available",
                    use_container_width=True
                )
        else:
            st.button(
                "ðŸ“Š Export Schedule (Excel)",
                disabled=True,
                help="Reports not available",
                use_container_width=True
            )

# ====== End of frontend/pages/generate_schedule.py ======



# ====== Begin of backend/services/scheduling_service.py ======

"""
FIXED Scheduling Service - Compatible with unified session management
"""
import logging
from datetime import datetime
from typing import Dict, Any, Optional
from sqlalchemy.orm import Session

# Domain models and helper components
from backend.models.domain_models import ScheduleResult
# Core components
from backend.core.calendar import AdvancedCalendar
from backend.core.duration import DurationCalculator
from backend.core.scheduler import AdvancedScheduler
from backend.core.task_generator import generate_tasks
# Repositories
from backend.db.repositories.schedule_repo import ScheduleRepository

logger = logging.getLogger(__name__)

class SchedulingService:
    """
    FIXED Scheduling Service - Pure scheduling logic
    """

    def __init__(self, db_session: Session):
        self.db_session = db_session
        self.schedule_repo = ScheduleRepository(db_session)
        self.logger = logging.getLogger(__name__)

    def generate_schedule(
        self,
        user_id: int,
        quantity_file,
        resources_file,
        equipment_file,
        scheduling_params: Dict[str, Any],
    ) -> ScheduleResult:
        """
        Pure scheduling logic
        """
        try:
            self.logger.info(f"Starting optimized schedule generation for user {user_id}")

            # 1) Validate scheduling_params
            start_date = scheduling_params.get("start_date")
            if start_date is None:
                raise ValueError("scheduling_params must include 'start_date'")

            zones_floors = scheduling_params.get("zones_floors", {})
            project_id = scheduling_params.get("project_id")
            project_name = scheduling_params.get("project_name", "Generated Schedule")

            # 2) Parse input files -> structured dicts for scheduler
            parsed = self._parse_input_files(quantity_file, resources_file, equipment_file)

            # 3) Prepare domain WorkerResource and EquipmentResource objects
            workers_map = self._build_workers_map(parsed.get("workers", {}))
            equipment_map = self._build_equipment_map(parsed.get("equipment", {}))

            # 4) Build quantity structure
            quantity_matrix = parsed.get("quantity_matrix", {})

            # 5) Duration calculator + calendar
            duration_calc = DurationCalculator(workers_map, equipment_map, quantity_matrix)
            calendar = AdvancedCalendar(start_date)

            # 6) Get base tasks for scheduler
            base_tasks_dict = self._get_base_tasks_for_scheduler(user_id, project_id)

            # 7) Generate tasks for the project
            tasks = generate_tasks(
                base_tasks_dict=base_tasks_dict,
                zones_floors=zones_floors,
                cross_floor_links=scheduling_params.get("cross_floor_links", {}),
                ground_disciplines=scheduling_params.get("ground_disciplines", set()),
                discipline_zone_cfg=scheduling_params.get("discipline_zone_cfg", {}),
                user_id=user_id,
                project_id=project_id
            )

            # 8) Apply duration calculation methods
            tasks = self._apply_duration_calculation_methods(
                tasks, base_tasks_dict, quantity_matrix, duration_calc
            )

            # 9) Instantiate AdvancedScheduler and run
            scheduler = AdvancedScheduler(
                tasks=tasks,
                workers=workers_map,
                equipment=equipment_map,
                calendar=calendar,
                duration_calc=duration_calc
            )

            schedule_dict = scheduler.generate()
            self.logger.info(f"Scheduler returned {len(schedule_dict)} scheduled tasks")

            # 10) Create ScheduleResult domain object
            worker_allocations = getattr(scheduler.worker_manager, "allocations", {})
            equipment_allocations = getattr(scheduler.equipment_manager, "allocations", {})

            # Compute project metrics
            project_duration = self._compute_project_duration(schedule_dict, calendar)
            total_cost = self._calculate_total_cost(tasks, schedule_dict, workers_map, equipment_map)
            resource_utilization = self._compute_resource_utilization(scheduler, workers_map, equipment_map)
            critical_path = self._compute_critical_path(tasks, schedule_dict, calendar)

            schedule_result = ScheduleResult(
                tasks=tasks,
                schedule=schedule_dict,
                project_duration=project_duration,
                total_cost=total_cost,
                resource_utilization=resource_utilization,
                critical_path=critical_path,
                worker_manager=getattr(scheduler, "worker_manager", None),
                equipment_manager=getattr(scheduler, "equipment_manager", None),
                calendar=calendar,
                worker_allocations=worker_allocations,
                equipment_allocations=equipment_allocations
            )

            # 11) Persist schedule with enhanced task allocations
            try:
                schedule_record_id = self._persist_schedule_with_tasks(
                    project_id=project_id,
                    user_id=user_id,
                    name=project_name,
                    schedule_result=schedule_result,
                    params=scheduling_params
                )
                self.logger.info(f"Schedule persisted with tasks (id={schedule_record_id})")
            except Exception as e:
                self.logger.warning(f"Failed to persist schedule: {e}", exc_info=True)

            return schedule_result

        except Exception as exc:
            self.logger.error(f"Schedule generation failed: {exc}", exc_info=True)
            raise

    def _get_base_tasks_for_scheduler(self, user_id: int, project_id: Optional[int] = None):
        """Get base tasks for scheduler - optimized version"""
        try:
            from backend.services.user_task_service import UserTaskService
            task_service = UserTaskService(self.db_session)
            return task_service.get_user_base_tasks_for_scheduler(user_id, project_id)
        except Exception as e:
            self.logger.error(f"Error getting base tasks: {e}")
            from backend.defaults.TASKS import BASE_TASKS
            return BASE_TASKS

    def _apply_duration_calculation_methods(self, tasks, base_tasks_dict, quantity_matrix, duration_calc):
        """Apply duration calculation methods - optimized version"""
        updated_tasks = []
        
        for task in tasks:
            base_task = base_tasks_dict.get(task.base_id)
            if not base_task:
                self.logger.warning(f"Base task not found for {task.base_id}, using default duration")
                updated_tasks.append(task)
                continue
            
            duration_method = getattr(base_task, 'duration_calculation_method', 'fixed_duration')
            
            if duration_method == 'fixed_duration':
                task_duration = getattr(base_task, 'base_duration', 1)
                task.base_duration = task_duration
                
            elif duration_method == 'quantity_based':
                task_duration = self._calculate_quantity_based_duration(task, base_task, quantity_matrix)
                task.base_duration = task_duration
                
            elif duration_method == 'resource_calculation':
                task.base_duration = None
                
            else:
                task_duration = getattr(base_task, 'base_duration', 1)
                task.base_duration = task_duration
            
            updated_tasks.append(task)
        
        return updated_tasks

    def _calculate_quantity_based_duration(self, task, base_task, quantity_matrix):
        """Calculate quantity-based duration - optimized version"""
        try:
            unit_duration = getattr(base_task, 'unit_duration', 0.1)
            task_quantity = self._get_task_quantity(task, quantity_matrix)
            
            if task_quantity > 0:
                calculated_duration = task_quantity * unit_duration
                return max(0.5, calculated_duration)
            else:
                return unit_duration
                
        except Exception as e:
            self.logger.error(f"Error calculating quantity-based duration for {task.id}: {e}")
            return getattr(base_task, 'base_duration', getattr(base_task, 'unit_duration', 1))

    def _get_task_quantity(self, task, quantity_matrix):
        """Get task quantity - optimized version"""
        try:
            base_id_quantities = quantity_matrix.get(task.base_id, {})
            floor_quantities = base_id_quantities.get(task.floor, {})
            quantity = floor_quantities.get(task.zone, 0.0)
            return quantity
            
        except Exception as e:
            self.logger.warning(f"Could not get quantity for task {task.id}: {e}")
            return 0.0

    def _parse_input_files(self, quantity_file, resources_file, equipment_file):
        """Parse input files - optimized version"""
        import pandas as pd
        parsed = {}

        # Quantity matrix (required)
        try:
            df_q = pd.read_excel(quantity_file)
            parsed["quantity_matrix"] = self._parse_quantity_df(df_q)
        except Exception as e:
            self.logger.error(f"Failed to parse quantity file: {e}")
            raise

        # Workers (optional)
        if resources_file:
            try:
                df_workers = pd.read_excel(resources_file)
                parsed["workers"] = self._parse_workers_df(df_workers)
            except Exception as e:
                self.logger.warning(f"Could not parse resources file; using defaults. Error: {e}")
                parsed["workers"] = {}
        else:
            parsed["workers"] = {}

        # Equipment (optional)
        if equipment_file:
            try:
                df_equip = pd.read_excel(equipment_file)
                parsed["equipment"] = self._parse_equipment_df(df_equip)
            except Exception as e:
                self.logger.warning(f"Could not parse equipment file; using defaults. Error: {e}")
                parsed["equipment"] = {}
        else:
            parsed["equipment"] = {}

        return parsed

    def _parse_quantity_df(self, df):
        """Parse quantity DataFrame - optimized version"""
        required = {"TaskID", "Zone", "Floor", "Quantity"}
        missing = required - set(df.columns)
        if missing:
            raise ValueError(f"Quantity template missing columns: {missing}")

        qm = {}
        for _, row in df.iterrows():
            task_id = str(row["TaskID"])
            zone = str(row["Zone"])
            floor = int(row["Floor"])
            qty = float(row["Quantity"])

            qm.setdefault(task_id, {}).setdefault(floor, {})[zone] = qty

        return qm

    def _parse_workers_df(self, df):
        """Parse workers DataFrame - optimized version"""
        import json
        result = {}
        for _, r in df.iterrows():
            name = str(r.get("ResourceName") or r.get("Name") or "").strip()
            if not name:
                continue

            result[name] = {
                "count": int(r.get("Count", 1)),
                "hourly_rate": float(r.get("HourlyRate", 0.0)),
                "productivity_rates": self._safe_json_parse(r.get("ProductivityRates", {})),
                "skills": self._parse_skills(r.get("Skills", "")),
                "max_crews": self._safe_json_parse(r.get("MaxCrews", {})),
                "efficiency": float(r.get("Efficiency", 1.0))
            }
        return result

    def _parse_equipment_df(self, df):
        """Parse equipment DataFrame - optimized version"""
        import json
        result = {}
        for _, r in df.iterrows():
            name = str(r.get("EquipmentName") or r.get("Name") or "").strip()
            if not name:
                continue

            result[name] = {
                "count": int(r.get("Count", 1)),
                "hourly_rate": float(r.get("HourlyRate", 0.0)),
                "productivity_rates": self._safe_json_parse(r.get("ProductivityRates", {})),
                "type": r.get("Type", "general"),
                "max_equipment": self._safe_json_parse(r.get("MaxEquipment", {})),
                "efficiency": float(r.get("Efficiency", 1.0))
            }
        return result

    def _safe_json_parse(self, value):
        """Safely parse JSON values"""
        import json
        if isinstance(value, str):
            try:
                return json.loads(value)
            except Exception:
                return {}
        return value if value is not None else {}

    def _parse_skills(self, skills):
        """Parse skills string into list"""
        if isinstance(skills, str):
            return [s.strip() for s in skills.split(",") if s.strip()]
        return skills if skills else []

    def _build_workers_map(self, uploaded_workers):
        """Build workers map - optimized version"""
        from backend.models.domain_models import WorkerResource
        from backend.defaults.resources import workers as DEFAULT_WORKERS

        workers_map = {}

        # Defaults
        for name, default in DEFAULT_WORKERS.items():
            try:
                if isinstance(default, WorkerResource):
                    workers_map[name] = default
                else:
                    workers_map[name] = WorkerResource(
                        name=name,
                        count=getattr(default, "count", default.get("count", 1)),
                        hourly_rate=getattr(default, "hourly_rate", default.get("hourly_rate", 0.0)),
                        productivity_rates=getattr(default, "productivity_rates", default.get("productivity_rates", {})),
                        skills=getattr(default, "skills", default.get("skills", [])),
                        max_crews=getattr(default, "max_crews", default.get("max_crews", {})),
                        efficiency=getattr(default, "efficiency", default.get("efficiency", 1.0))
                    )
            except Exception:
                workers_map[name] = WorkerResource(name=name, count=1, hourly_rate=0.0)

        # Override with uploaded
        for name, spec in uploaded_workers.items():
            workers_map[name] = WorkerResource(
                name=name,
                count=int(spec.get("count", 1)),
                hourly_rate=float(spec.get("hourly_rate", 0.0)),
                productivity_rates=spec.get("productivity_rates", {}),
                skills=spec.get("skills", []),
                max_crews=spec.get("max_crews", {}),
                efficiency=float(spec.get("efficiency", 1.0))
            )

        return workers_map

    def _build_equipment_map(self, uploaded_equipment):
        """Build equipment map - optimized version"""
        from backend.models.domain_models import EquipmentResource
        from backend.defaults.resources import equipment as DEFAULT_EQUIPMENT

        equipment_map = {}

        # Defaults
        for name, default in DEFAULT_EQUIPMENT.items():
            try:
                if isinstance(default, EquipmentResource):
                    equipment_map[name] = default
                else:
                    equipment_map[name] = EquipmentResource(
                        name=name,
                        count=getattr(default, "count", default.get("count", 1)),
                        hourly_rate=getattr(default, "hourly_rate", default.get("hourly_rate", 0.0)),
                        productivity_rates=getattr(default, "productivity_rates", default.get("productivity_rates", {})),
                        type=getattr(default, "type", default.get("type", "general")),
                        max_equipment=getattr(default, "max_equipment", default.get("max_equipment", {})),
                        efficiency=getattr(default, "efficiency", default.get("efficiency", 1.0))
                    )
            except Exception:
                equipment_map[name] = EquipmentResource(name=name, count=1, hourly_rate=0.0)

        # Override with uploaded
        for name, spec in uploaded_equipment.items():
            equipment_map[name] = EquipmentResource(
                name=name,
                count=int(spec.get("count", 1)),
                hourly_rate=float(spec.get("hourly_rate", 0.0)),
                productivity_rates=spec.get("productivity_rates", {}),
                type=spec.get("type", "general"),
                max_equipment=spec.get("max_equipment", {}),
                efficiency=float(spec.get("efficiency", 1.0))
            )

        return equipment_map

    def _compute_project_duration(self, schedule, calendar):
        """Compute project duration - optimized version"""
        if not schedule:
            return 0
        
        start_dates = [s[0] for s in schedule.values() if s[0] is not None]
        end_dates = [s[1] for s in schedule.values() if s[1] is not None]
        
        if not start_dates or not end_dates:
            return 0
            
        project_start = min(start_dates)
        project_end = max(end_dates)
        
        # Count working days
        days = 0
        d = project_start
        while d <= project_end:
            if calendar.is_work_day(d):
                days += 1
            d = calendar.add_calendar_days(d, 1)
        return days

    def _calculate_total_cost(self, tasks, schedule, workers_map, equipment_map):
        """Calculate total cost with proper field access - UPDATED"""
        total = 0.0
        for task in tasks:
            if task.id not in schedule:
                continue
                
            start, end = schedule[task.id]
            duration_days = (end - start).days or 1
            
            # âœ… FIXED: Use consistent attribute names with getattr
            crews = getattr(task, "allocated_crews", None) or getattr(task, "min_crews_needed", 0)
            allocated_equipments = getattr(task, "allocated_equipments", {}) or {}
            
            # Labour cost
            if crews and task.resource_type in workers_map:
                worker = workers_map[task.resource_type]
                total += worker.hourly_rate * 8 * crews * duration_days
            
            # Equipment cost - FIXED: use allocated_equipments (plural)
            for equip_name, units in allocated_equipments.items():
                if equip_name in equipment_map:
                    equip = equipment_map[equip_name]
                    total += equip.hourly_rate * 8 * units * duration_days
                    
        return total

    def _compute_resource_utilization(self, scheduler, workers_map, equipment_map):
        """Compute resource utilization - optimized version"""
        utilization = {}
        wm = getattr(scheduler, "worker_manager", None)
        em = getattr(scheduler, "equipment_manager", None)

        if wm and hasattr(wm, "allocations"):
            for wname, allocs in wm.allocations.items():
                capacity = workers_map.get(wname).count if wname in workers_map else 0
                peak = max((alloc[2] if len(alloc) > 2 else 0) for alloc in allocs) if allocs else 0
                utilization[wname] = (peak / capacity) if capacity else 0.0

        if em and hasattr(em, "allocations"):
            for ename, allocs in em.allocations.items():
                capacity = equipment_map.get(ename).count if ename in equipment_map else 0
                peak = max((alloc[2] if len(alloc) > 2 else 0) for alloc in allocs) if allocs else 0
                utilization[ename] = (peak / capacity) if capacity else 0.0

        return utilization

    def _compute_critical_path(self, tasks, schedule, calendar):
        """Compute critical path - optimized version"""
        try:
            durations = {}
            for t in tasks:
                if t.id in schedule:
                    start, end = schedule[t.id]
                    # Count working days
                    dcount = 0
                    d = start
                    while d <= end:
                        if calendar.is_work_day(d):
                            dcount += 1
                        d = calendar.add_calendar_days(d, 1)
                    durations[t.id] = dcount
                    
            sorted_tasks = sorted(durations.items(), key=lambda x: x[1], reverse=True)
            return [tid for tid, _ in sorted_tasks[:max(1, min(10, len(sorted_tasks)))]]
        except Exception:
            return []

    def _persist_schedule_with_tasks(self, project_id, user_id, name, schedule_result, params):
        """Persist schedule with detailed task allocations - ENHANCED VERSION"""
        try:
            # Convert schedule to storage format
            schedule_data = {
                "schedule": {tid: [sd.isoformat(), ed.isoformat()] 
                            for tid, (sd, ed) in schedule_result.schedule.items()},
                "metadata": {
                    "generated_at": datetime.utcnow().isoformat(),
                    "project_duration": schedule_result.project_duration,
                    "total_tasks": len(schedule_result.tasks),
                    "scheduling_params": params
                }
            }
            
            # Store task-level allocations
            task_allocations = {}
            schedule_tasks_data = []
            
            for task in schedule_result.tasks:
                if task.id in schedule_result.schedule:
                    start_date, end_date = schedule_result.schedule[task.id]
                    
                    # Task allocation record
                    task_allocations[task.id] = {
                        'crews': getattr(task, 'allocated_crews', 0),
                        'equipment': getattr(task, 'allocated_equipments', {}),
                        'duration': (end_date - start_date).days,
                        'cost': self._calculate_task_cost(task, schedule_result.schedule[task.id], 
                                                         schedule_result.worker_allocations, 
                                                         schedule_result.equipment_allocations)
                    }
                    
                    # ScheduleTasksDB record
                    schedule_task_data = {
                        'schedule_id': None,  # Will be set after schedule creation
                        'project_id': project_id,
                        'user_id': user_id,
                        'base_task_id': getattr(task, 'base_id', task.id),
                        'task_name': task.name,
                        'task_unique_id': task.id,
                        'discipline': getattr(task, 'discipline', 'Unknown'),
                        'sub_discipline': getattr(task, 'sub_discipline', ''),
                        'resource_type': getattr(task, 'resource_type', ''),
                        'task_type': getattr(task, 'task_type', 'execution'),
                        'zone': getattr(task, 'zone', ''),
                        'floor': getattr(task, 'floor', 0),
                        'scheduled_start_date': start_date,
                        'scheduled_end_date': end_date,
                        'planned_duration': (end_date - start_date).days,
                        'allocated_crews': getattr(task, 'allocated_crews', 0),  # âœ… ACTUAL allocation
                        'allocated_equipments': getattr(task, 'allocated_equipments', {}),  # âœ… ACTUAL allocation
                        'min_crews_needed': getattr(task, 'min_crews_needed', 1),
                        'max_crews_allowed': getattr(task, 'max_crews_allowed', 1),
                        'min_equipment_needed': getattr(task, 'min_equipment_needed', {}),
                        'max_equipment_allowed': getattr(task, 'max_equipment_allowed', {}),
                        'status': 'scheduled',
                        'is_critical_path': task.id in getattr(schedule_result, 'critical_path', []),
                        'predecessors': getattr(task, 'predecessors', [])
                    }
                    schedule_tasks_data.append(schedule_task_data)
            
            # Create schedule record
            schedule_record_data = {
                "project_id": project_id,
                "user_id": user_id,
                "name": name,
                "version": 1,
                "description": f"Schedule generated for {name}",
                "schedule_data": schedule_data,
                "resource_allocations": {
                    "workers": schedule_result.worker_allocations,
                    "equipment": schedule_result.equipment_allocations
                },
                "task_allocations": task_allocations,  # âœ… NEW: Store task-level allocations
                "project_duration": schedule_result.project_duration,
                "total_cost": schedule_result.total_cost,
                "resource_utilization": schedule_result.resource_utilization,
                "critical_path": schedule_result.critical_path,
                "status": "generated",
                "baseline": True,
                "generated_at": datetime.utcnow()
            }
            
            # Create schedule and associated tasks using enhanced repository method
            created_schedule = self.schedule_repo.create_schedule_with_tasks(
                schedule_record_data, schedule_tasks_data
            )
            
            if created_schedule:
                self.logger.info(f"âœ… Schedule persisted with {len(schedule_tasks_data)} task records")
                return created_schedule.id
            else:
                self.logger.error("âŒ Failed to persist schedule with tasks")
                return None
                
        except Exception as e:
            self.logger.error(f"âŒ Error persisting schedule with tasks: {e}")
            return None

    def _calculate_task_cost(self, task, schedule_dates, worker_allocations, equipment_allocations):
        """Calculate individual task cost"""
        try:
            start_date, end_date = schedule_dates
            duration_days = (end_date - start_date).days or 1
            total_cost = 0.0
            
            # Labor cost
            allocated_crews = getattr(task, 'allocated_crews', 0)
            if allocated_crews > 0 and hasattr(task, 'resource_type'):
                # This would need access to worker rates - simplified for now
                total_cost += allocated_crews * duration_days * 500  # Placeholder rate
            
            # Equipment cost
            allocated_equipments = getattr(task, 'allocated_equipments', {})
            for equip_name, units in allocated_equipments.items():
                total_cost += units * duration_days * 200  # Placeholder rate
                
            return total_cost
            
        except Exception as e:
            self.logger.warning(f"Could not calculate task cost for {task.id}: {e}")
            return 0.0

    def save_schedule(self, user_id: int, schedule_data: Dict) -> bool:
        """Save schedule to database - compatibility method"""
        try:
            created = self.schedule_repo.create_schedule(schedule_data)
            return created is not None
        except Exception as e:
            self.logger.error(f"Error saving schedule: {e}")
            return False
    

# ====== End of backend/services/scheduling_service.py ======



# ====== Begin of backend/db/repositories/schedule_repo.py ======

"""
FIXED Schedule repository - No transaction control
"""
import logging
from typing import List, Optional, Dict, Any
from sqlalchemy.orm import Session, joinedload
from sqlalchemy import func, desc, and_

from backend.models.db_models import ScheduleDB, ScheduleTaskDB

logger = logging.getLogger(__name__)

class ScheduleRepository:
    """FIXED Schedule data repository - no commits"""
    
    def __init__(self, session: Session):
        self.session = session
    
    def get_project_schedules(self, project_id: int, limit: int = 10) -> List[ScheduleDB]:
        """Get schedules for a project with task counts"""
        try:
            return self.session.query(ScheduleDB).options(
                joinedload(ScheduleDB.tasks)
            ).filter(
                ScheduleDB.project_id == project_id
            ).order_by(
                desc(ScheduleDB.generated_at)
            ).limit(limit).all()
            
        except Exception as e:
            logger.error(f"Failed to get project schedules: {e}")
            return []
    
    def get_schedule_by_id(self, schedule_id: int) -> Optional[ScheduleDB]:
        """Get schedule by ID with tasks"""
        try:
            return self.session.query(ScheduleDB).options(
                joinedload(ScheduleDB.tasks)
            ).filter(ScheduleDB.id == schedule_id).first()
        except Exception as e:
            logger.error(f"Failed to get schedule {schedule_id}: {e}")
            return None
    
    def create_schedule(self, schedule_data: Dict[str, Any]) -> Optional[ScheduleDB]:
        """Create new schedule - NO COMMIT"""
        try:
            schedule = ScheduleDB(**schedule_data)
            self.session.add(schedule)
            self.session.flush()
            return schedule
        except Exception as e:
            logger.error(f"Failed to create schedule: {e}")
            return None
    
    def get_user_schedules(self, user_id: int, limit: int = 20) -> List[ScheduleDB]:
        """Get all schedules for a user"""
        try:
            return self.session.query(ScheduleDB).filter(
                ScheduleDB.user_id == user_id
            ).order_by(
                desc(ScheduleDB.generated_at)
            ).limit(limit).all()
        except Exception as e:
            logger.error(f"Failed to get user schedules: {e}")
            return []
    
    def create_schedule_with_tasks(self, schedule_data: Dict[str, Any], tasks_data: List[Dict[str, Any]]) -> Optional[ScheduleDB]:
        """Create schedule with associated tasks - NO COMMIT"""
        try:
            # Create schedule
            schedule = ScheduleDB(**schedule_data)
            self.session.add(schedule)
            self.session.flush()  # Flush to get schedule ID
            
            # Create tasks
            for task_data in tasks_data:
                task_data['schedule_id'] = schedule.id
                task = ScheduleTaskDB(**task_data)
                self.session.add(task)
            
            self.session.flush()
            return schedule
            
        except Exception as e:
            logger.error(f"Failed to create schedule with tasks: {e}")
            return None

# ====== End of backend/db/repositories/schedule_repo.py ======

